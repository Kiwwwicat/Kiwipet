import sys
import io

# Windows コンソールで日本語出力のためのUTF-8設定
# PyInstaller windowedモードではstdout/stderrがNoneになる可能性あり
if sys.platform == 'win32' and sys.stdout is not None and hasattr(sys.stdout, 'buffer'):
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
if sys.platform == 'win32' and sys.stderr is not None and hasattr(sys.stderr, 'buffer'):
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

import os
import random
import math
import base64
import json
import time

# ============ NEW UI SVG ICONS ============
# プレースホルダー画像（画像のないキャラクター用）
PLACEHOLDER_SVG = '''<svg width="808" height="808" viewBox="0 0 808 808" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M336.667 235.667H370.334V269.333H437.667V235.667H471.334V202H606V235.667H639.667V269.333H673.334V437.667H639.667V471.333H606V505H572.334V538.667H538.667V572.333H505V606H471.334V639.667H437.667V673.333H370.334V639.667H336.667V606H303V572.333H269.334V538.667H235.667V505H202V471.333H168.334V437.667H134.667V269.333H168.334V235.667H202V202H336.667V235.667Z" fill="#D5E8DF"/>
<path d="M437.667 673.333V707H370.333V673.333H437.667Z" fill="#9DD4BA"/>
<path d="M370.333 673.333H336.667V639.666H370.333V673.333Z" fill="#9DD4BA"/>
<path d="M471.333 673.333H437.667V639.666H471.333V673.333Z" fill="#9DD4BA"/>
<path d="M336.667 639.666H303V606H336.667V639.666Z" fill="#9DD4BA"/>
<path d="M505 639.666H471.333V606H505V639.666Z" fill="#9DD4BA"/>
<path d="M303 606H269.333V572.333H303V606Z" fill="#9DD4BA"/>
<path d="M538.667 606H505V572.333H538.667V606Z" fill="#9DD4BA"/>
<path d="M269.333 572.333H235.667V538.666H269.333V572.333Z" fill="#9DD4BA"/>
<path d="M572.333 572.333H538.667V538.666H572.333V572.333Z" fill="#9DD4BA"/>
<path d="M235.667 538.666H202V505H235.667V538.666Z" fill="#9DD4BA"/>
<path d="M606 538.666H572.333V505H606V538.666Z" fill="#9DD4BA"/>
<path d="M202 505H168.333V471.333H202V505Z" fill="#9DD4BA"/>
<path d="M639.667 505H606V471.333H639.667V505Z" fill="#9DD4BA"/>
<path d="M168.333 471.333H134.667V437.666H168.333V471.333Z" fill="#9DD4BA"/>
<path d="M673.333 471.333H639.667V437.666H673.333V471.333Z" fill="#9DD4BA"/>
<path d="M134.667 437.666H101V269.333H134.667V437.666Z" fill="#9DD4BA"/>
<path d="M707 437.666H673.333V269.333H707V437.666Z" fill="#9DD4BA"/>
<path d="M168.333 269.333H134.667V235.666H168.333V269.333Z" fill="#9DD4BA"/>
<path d="M437.667 269.333H370.333V235.666H437.667V269.333Z" fill="#9DD4BA"/>
<path d="M673.333 269.333H639.667V235.666H673.333V269.333Z" fill="#9DD4BA"/>
<path d="M202 235.666H168.333V202H202V235.666Z" fill="#9DD4BA"/>
<path d="M370.333 235.666H336.667V202H370.333V235.666Z" fill="#9DD4BA"/>
<path d="M471.333 235.666H437.667V202H471.333V235.666Z" fill="#9DD4BA"/>
<path d="M639.667 235.666H606V202H639.667V235.666Z" fill="#9DD4BA"/>
<path d="M336.667 202H202V168.333H336.667V202Z" fill="#9DD4BA"/>
<path d="M606 202H471.333V168.333H606V202Z" fill="#9DD4BA"/>
<path d="M437.666 437.667H471.333V471.334H336.666V437.667H370.333V404H437.666V437.667Z" fill="#63BA91"/>
<path d="M303 404H269.333V336.667H303V404Z" fill="#63BA91"/>
<path d="M505 336.667H538.666V404H505V336.667Z" fill="#63BA91"/>
</svg>'''

# iボタン（クレジット）
SVG_INFO = '''<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 7H11V8H13V7H14V6H18V7H19V8H20V13H19V14H18V15H17V16H16V17H15V18H14V19H13V20H11V19H10V18H9V17H8V16H7V15H6V14H5V13H4V8H5V7H6V6H10V7Z" fill="#D5E8DF"/>
<path d="M13 20V21H11V20H13Z" fill="#9DD4BA"/>
<path d="M11 20H10V19H11V20Z" fill="#9DD4BA"/>
<path d="M14 20H13V19H14V20Z" fill="#9DD4BA"/>
<path d="M10 19H9V18H10V19Z" fill="#9DD4BA"/>
<path d="M15 19H14V18H15V19Z" fill="#9DD4BA"/>
<path d="M9 18H8V17H9V18Z" fill="#9DD4BA"/>
<path d="M16 18H15V17H16V18Z" fill="#9DD4BA"/>
<path d="M8 17H7V16H8V17Z" fill="#9DD4BA"/>
<path d="M17 17H16V16H17V17Z" fill="#9DD4BA"/>
<path d="M7 16H6V15H7V16Z" fill="#9DD4BA"/>
<path d="M18 16H17V15H18V16Z" fill="#9DD4BA"/>
<path d="M6 15H5V14H6V15Z" fill="#9DD4BA"/>
<path d="M19 15H18V14H19V15Z" fill="#9DD4BA"/>
<path d="M5 14H4V13H5V14Z" fill="#9DD4BA"/>
<path d="M20 14H19V13H20V14Z" fill="#9DD4BA"/>
<path d="M4 13H3V8H4V13Z" fill="#9DD4BA"/>
<path d="M21 13H20V8H21V13Z" fill="#9DD4BA"/>
<path d="M5 8H4V7H5V8Z" fill="#9DD4BA"/>
<path d="M13 8H11V7H13V8Z" fill="#9DD4BA"/>
<path d="M20 8H19V7H20V8Z" fill="#9DD4BA"/>
<path d="M6 7H5V6H6V7Z" fill="#9DD4BA"/>
<path d="M11 7H10V6H11V7Z" fill="#9DD4BA"/>
<path d="M14 7H13V6H14V7Z" fill="#9DD4BA"/>
<path d="M19 7H18V6H19V7Z" fill="#9DD4BA"/>
<path d="M10 6H6V5H10V6Z" fill="#9DD4BA"/>
<path d="M18 6H14V5H18V6Z" fill="#9DD4BA"/>
<path d="M13 13H14V14H10V13H11V12H13V13Z" fill="#63BA91"/>
<path d="M9 12H8V10H9V12Z" fill="#63BA91"/>
<path d="M15 10H16V12H15V10Z" fill="#63BA91"/>
</svg>'''

# ?ボタン（チュートリアル）
SVG_QUESTION = '''<svg width="8" height="14" viewBox="0 0 8 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.81638 3.73947C5.81638 3.2114 5.63454 2.78772 5.27086 2.46842C4.90718 2.14912 4.425 1.98947 3.82432 1.98947C3.45399 1.98947 3.11892 2.06635 2.81909 2.2201C2.51925 2.37386 2.26054 2.59786 2.04295 2.8921C1.83863 3.17456 1.56076 3.3374 1.20934 3.38063C0.857919 3.42385 0.554767 3.3347 0.299885 3.11315C0.121109 2.9535 0.0222718 2.75701 0.00337267 2.52368C-0.0155264 2.29035 0.0450018 2.0693 0.184957 1.86052C0.593587 1.27105 1.11408 0.813718 1.74643 0.488526C2.37879 0.163333 3.07142 0.000491227 3.82432 0C5.06297 0 6.06871 0.337719 6.84153 1.01316C7.61435 1.68859 8.00051 2.5728 8 3.66578C8 4.21842 7.87869 4.71578 7.63606 5.15789C7.39344 5.59999 6.9465 6.12192 6.29525 6.72367C5.82277 7.1535 5.50353 7.48827 5.33752 7.72799C5.17152 7.96771 5.06297 8.24083 5.0119 8.54736C4.96082 8.84209 4.8298 9.08771 4.61884 9.2842C4.40789 9.48069 4.15582 9.57893 3.86262 9.57893C3.56943 9.57893 3.31736 9.48388 3.1064 9.29378C2.89545 9.10367 2.78997 8.86715 2.78997 8.5842C2.78997 8.10525 2.89851 7.66634 3.1156 7.26746C3.33268 6.86859 3.69662 6.44785 4.20741 6.00525C4.85866 5.45262 5.28976 5.02599 5.50072 4.72536C5.71167 4.42473 5.8169 4.0961 5.81638 3.73947ZM3.82432 14C3.40292 14 3.0423 13.8558 2.74247 13.5675C2.44264 13.2791 2.29246 12.9321 2.29195 12.5263C2.29144 12.1205 2.44161 11.7737 2.74247 11.4859C3.04332 11.198 3.40394 11.0536 3.82432 11.0526C4.24469 11.0516 4.60556 11.1961 4.90693 11.4859C5.20829 11.7757 5.35821 12.1225 5.35668 12.5263C5.35514 12.9301 5.20523 13.2771 4.90693 13.5675C4.60863 13.8578 4.24776 14.0019 3.82432 14Z" fill="#317C75"/>
</svg>'''

# Kiwipet タイトルロゴ SVG
SVG_KIWIPET_TITLE = '''<svg width="150" height="76" viewBox="0 0 150 76" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M46.6403 43.9567C47.0397 43.9567 47.347 44.1411 47.5621 44.5098C47.8079 44.8785 47.9308 45.3854 47.9308 46.0306C47.9308 47.2289 47.6389 48.1814 47.0551 48.8881C45.5803 50.6701 44.0901 52.0527 42.5846 53.0359C41.0791 53.9884 39.2971 54.4646 37.2385 54.4646C34.9649 54.4646 33.106 53.804 31.6619 52.4829C30.2179 51.131 28.866 49.0417 27.6063 46.215C26.6845 44.1872 25.9164 42.6816 25.3019 41.6984C24.7181 40.6845 24.1344 39.9779 23.5506 39.5784C22.9668 39.1483 22.2294 38.8871 21.3384 38.7949L20.8314 42.2054C20.1862 46.5991 18.9265 49.7637 17.0523 51.6994C15.2088 53.635 12.6586 54.6029 9.4018 54.6029C7.28179 54.6029 5.39221 54.0959 3.73307 53.082C2.10465 52.0374 0.967833 50.7162 0.322611 49.1185C0.107537 48.5654 0 47.9663 0 47.3211C0 46.3993 0.215074 45.6005 0.645222 44.9246C1.07537 44.2486 1.62842 43.9106 2.30436 43.9106C2.70379 43.9106 3.04176 44.0182 3.31828 44.2332C3.59481 44.4176 3.85597 44.7556 4.10177 45.2472C5.05424 47.0292 5.88381 48.2736 6.59048 48.9802C7.32787 49.6869 8.23426 50.0402 9.30963 50.0402C10.5386 50.0402 11.5833 49.4872 12.4436 48.3811C13.3346 47.2443 13.9644 45.5083 14.3331 43.1732L14.9784 38.7949H14.241C13.5343 38.7949 12.9812 38.5952 12.5818 38.1958C12.1824 37.7964 11.9827 37.2433 11.9827 36.5367C11.9827 35.7378 12.1824 35.108 12.5818 34.6471C13.012 34.1555 13.5343 33.9097 14.1488 33.9097H15.6697C15.8847 32.4042 16.0384 31.3595 16.1305 30.7758L17.5592 20.4061C16.7604 20.314 16.0076 20.2679 15.301 20.2679C12.6894 20.2679 10.7076 20.7287 9.35571 21.6505C8.00382 22.5415 7.32787 23.8319 7.32787 25.5218C7.32787 26.2899 7.40469 26.9198 7.55831 27.4114C7.74266 27.8723 7.9731 28.3946 8.24962 28.9784C8.37252 29.2242 8.43397 29.5007 8.43397 29.8079C8.43397 30.4839 8.11136 31.083 7.46614 31.6053C6.85164 32.0969 6.16033 32.3427 5.39221 32.3427C4.40902 32.3427 3.68698 31.9126 3.22611 31.0523C2.30436 29.4239 1.84349 27.6726 1.84349 25.7983C1.84349 23.8627 2.36581 22.096 3.41046 20.4983C4.48583 18.9006 6.09888 17.6255 8.24962 16.6731C10.4004 15.6899 13.0581 15.1983 16.2227 15.1983C17.6053 15.1983 18.8651 15.2751 20.0019 15.4287C21.1694 15.5823 22.4445 15.8742 23.8271 16.3044C25.3326 16.7652 26.0854 17.6255 26.0854 18.8853C26.0854 20.5751 25.3634 21.42 23.9193 21.42L22.1219 33.8175C25.7167 33.4488 28.6356 31.9126 30.8785 29.2088C33.1521 26.4743 35.0417 22.7719 36.5472 18.1018C36.8237 17.2415 37.2846 16.5809 37.9298 16.12C38.6058 15.6591 39.4507 15.4287 40.4646 15.4287C41.3249 15.4287 41.9855 15.6284 42.4464 16.0278C42.938 16.3965 43.1838 16.9342 43.1838 17.6409C43.1838 17.856 43.1223 18.2093 42.9994 18.7009C41.4632 23.7705 39.2663 27.7955 36.4089 30.7758C33.5515 33.7561 30.433 35.7378 27.0532 36.721C28.2208 36.9975 29.1732 37.4123 29.9106 37.9654C30.6788 38.5184 31.324 39.2097 31.8463 40.0393C32.3686 40.8381 32.9678 41.9596 33.6437 43.4037C34.5962 45.4315 35.4872 46.8756 36.3168 47.7359C37.1463 48.5654 38.1142 48.9802 39.2203 48.9802C40.2035 48.9802 41.1406 48.6576 42.0316 48.0124C42.9226 47.3365 44.0441 46.1996 45.396 44.6019C45.7646 44.1718 46.1794 43.9567 46.6403 43.9567Z" fill="#4FB98F"/>
<path d="M48.8305 29.7158C47.5401 29.7158 46.5723 29.4239 45.927 28.8401C45.2818 28.2256 44.9592 27.3807 44.9592 26.3053C44.9592 25.2299 45.374 24.3389 46.2036 23.6322C47.0639 22.8948 48.1239 22.5261 49.3836 22.5261C50.5204 22.5261 51.4421 22.8027 52.1488 23.3557C52.8555 23.9088 53.2088 24.6922 53.2088 25.7062C53.2088 26.9352 52.8094 27.9184 52.0106 28.6558C51.2117 29.3624 50.1517 29.7158 48.8305 29.7158ZM48.4618 54.4646C46.4647 54.4646 45.0053 53.7579 44.0835 52.3446C43.1925 50.9313 42.747 49.057 42.747 46.722C42.747 45.3393 42.916 43.5727 43.254 41.4219C43.6227 39.2405 44.0835 37.2126 44.6366 35.3384C44.9131 34.3552 45.2818 33.6793 45.7427 33.3106C46.2036 32.9419 46.941 32.7575 47.9549 32.7575C49.5218 32.7575 50.3053 33.2798 50.3053 34.3245C50.3053 35.0926 50.0134 36.8746 49.4297 39.6706C48.6923 43.0503 48.3236 45.3393 48.3236 46.5376C48.3236 47.4594 48.4465 48.166 48.6923 48.6576C48.9381 49.1492 49.3529 49.395 49.9366 49.395C50.4897 49.395 51.181 49.011 52.0106 48.2428C52.8401 47.4747 53.9462 46.2611 55.3288 44.6019C55.6975 44.1718 56.1123 43.9567 56.5732 43.9567C56.9726 43.9567 57.2799 44.1411 57.4949 44.5098C57.7407 44.8785 57.8636 45.3854 57.8636 46.0306C57.8636 47.2596 57.5718 48.2121 56.988 48.8881C53.9462 52.6058 51.1042 54.4646 48.4618 54.4646Z" fill="#4FB98F"/>
<path d="M87.5834 40.2237C87.6756 40.1929 87.8292 40.1776 88.0443 40.1776C88.5052 40.1776 88.8585 40.3312 89.1043 40.6384C89.3501 40.9457 89.473 41.3605 89.473 41.8828C89.473 42.8353 89.2887 43.588 88.92 44.1411C88.5513 44.6634 87.9982 45.0475 87.2608 45.2932C85.8475 45.7541 84.342 45.9846 82.7443 45.9846C81.3924 45.9846 80.1173 45.8002 78.919 45.4315C78.028 46.8756 77.0448 48.3657 75.9694 49.902C74.7404 51.6533 73.6805 52.8516 72.7894 53.4968C71.9291 54.142 70.9459 54.4646 69.8398 54.4646C68.6108 54.4646 67.6737 53.9884 67.0285 53.0359C66.414 52.0834 66.03 50.5165 65.8763 48.335L65.6459 44.9706C64.6934 47.5515 63.8331 49.5179 63.065 50.8698C62.3276 52.2217 61.5749 53.1588 60.8067 53.6811C60.0693 54.2035 59.1937 54.4646 58.1798 54.4646C56.92 54.4646 55.9215 53.973 55.1841 52.9898C54.4774 52.0066 54.0319 50.455 53.8476 48.335C53.4789 44.0335 53.2945 40.2697 53.2945 37.0436V35.4306C53.3252 34.4167 53.6018 33.71 54.1241 33.3106C54.6464 32.9111 55.4299 32.7114 56.4745 32.7114C57.2734 32.7114 57.8572 32.8958 58.2259 33.2645C58.6253 33.6024 58.825 34.1862 58.825 35.0158C58.825 38.5491 59.0401 43.1425 59.4702 48.7959C61.5595 44.4022 63.4798 39.8242 65.2311 35.0619C65.5691 34.1401 65.9685 33.5256 66.4294 33.2184C66.921 32.8804 67.5048 32.7114 68.1807 32.7114C69.0103 32.7114 69.5787 32.8804 69.8859 33.2184C70.2239 33.5564 70.3929 34.1555 70.3929 35.0158C70.3929 38.5491 70.608 43.1425 71.0381 48.7959C72.8816 46.0614 74.2642 43.8799 75.186 42.2515C74.7251 41.3605 74.4947 40.3005 74.4947 39.0715C74.4947 38.0268 74.7251 37.0129 75.186 36.0297C75.6468 35.0465 76.2767 34.2477 77.0755 33.6332C77.8744 33.0187 78.7808 32.7114 79.7947 32.7114C80.6857 32.7114 81.4077 33.034 81.9608 33.6793C82.5138 34.2938 82.7904 35.2001 82.7904 36.3984C82.7904 37.781 82.4217 39.3634 81.6843 41.1454C82.8518 41.0839 84.4034 40.8535 86.3391 40.4541L87.5834 40.2237Z" fill="#4FB98F"/>
<path d="M90.1272 29.7158C88.8368 29.7158 87.869 29.4239 87.2237 28.8401C86.5785 28.2256 86.2559 27.3807 86.2559 26.3053C86.2559 25.2299 86.6707 24.3389 87.5003 23.6322C88.3606 22.8948 89.4206 22.5261 90.6803 22.5261C91.8171 22.5261 92.7389 22.8027 93.4455 23.3557C94.1522 23.9088 94.5055 24.6922 94.5055 25.7062C94.5055 26.9352 94.1061 27.9184 93.3073 28.6558C92.5084 29.3624 91.4484 29.7158 90.1272 29.7158ZM89.7585 54.4646C87.7614 54.4646 86.302 53.7579 85.3802 52.3446C84.4892 50.9313 84.0437 49.057 84.0437 46.722C84.0437 45.3393 84.2127 43.5727 84.5507 41.4219C84.9194 39.2405 85.3803 37.2126 85.9333 35.3384C86.2098 34.3552 86.5785 33.6793 87.0394 33.3106C87.5003 32.9419 88.2377 32.7575 89.2516 32.7575C90.8186 32.7575 91.602 33.2798 91.602 34.3245C91.602 35.0926 91.3101 36.8746 90.7264 39.6706C89.989 43.0503 89.6203 45.3393 89.6203 46.5376C89.6203 47.4594 89.7432 48.166 89.989 48.6576C90.2348 49.1492 90.6496 49.395 91.2333 49.395C91.7864 49.395 92.4777 49.011 93.3073 48.2428C94.1368 47.4747 95.2429 46.2611 96.6255 44.6019C96.9942 44.1718 97.409 43.9567 97.8699 43.9567C98.2693 43.9567 98.5766 44.1411 98.7916 44.5098C99.0374 44.8785 99.1603 45.3854 99.1603 46.0306C99.1603 47.2596 98.8685 48.2121 98.2847 48.8881C95.2429 52.6058 92.4009 54.4646 89.7585 54.4646Z" fill="#4FB98F"/>
<path d="M118.66 43.9567C119.059 43.9567 119.366 44.1411 119.581 44.5098C119.827 44.8785 119.95 45.3854 119.95 46.0306C119.95 47.2596 119.658 48.2121 119.074 48.8881C117.753 50.5165 116.324 51.853 114.788 52.8977C113.283 53.9423 111.562 54.4646 109.626 54.4646C107.998 54.4646 106.677 53.8808 105.663 52.7133C103.912 53.8501 102.084 54.4339 100.179 54.4646C99.7792 60.3945 98.8728 65.3412 97.4594 69.3047C96.0461 73.2989 93.9722 75.2961 91.2377 75.2961C89.5785 75.2961 88.3495 74.6969 87.5507 73.4987C86.7518 72.3004 86.3524 70.6412 86.3524 68.5212C86.3524 65.5102 87.0437 61.9922 88.4263 57.9672C89.8089 53.973 91.9443 49.564 94.8325 44.7402C94.8325 40.2544 94.8017 37.1358 94.7403 35.3845C94.7096 34.4935 95.0629 33.7868 95.8003 33.2645C96.5377 32.7422 97.4594 32.481 98.5655 32.481C99.2107 32.481 99.6716 32.6193 99.9481 32.8958C100.255 33.1416 100.424 33.6485 100.455 34.4167C100.455 35.1848 100.47 35.7532 100.501 36.1219C101.484 34.8929 102.452 34.0172 103.405 33.4949C104.357 32.9419 105.371 32.6653 106.446 32.6653C108.167 32.6653 109.565 33.3566 110.64 34.7393C111.746 36.1219 112.3 37.9347 112.3 40.1776C112.3 41.806 112.038 43.3883 111.516 44.9246C110.994 46.4608 110.272 47.8588 109.35 49.1185C109.995 49.3028 110.533 49.395 110.963 49.395C111.977 49.395 112.945 49.0263 113.866 48.2889C114.788 47.5515 115.971 46.3225 117.415 44.6019C117.784 44.1718 118.199 43.9567 118.66 43.9567ZM100.409 50.0402C101.515 49.7944 102.529 49.1953 103.451 48.2428C104.403 47.2596 105.156 46.0614 105.709 44.648C106.262 43.204 106.539 41.6984 106.539 40.1315C106.539 39.2097 106.354 38.5184 105.986 38.0576C105.617 37.566 105.125 37.3202 104.511 37.3202C103.405 37.3202 102.068 38.4877 100.501 40.8228C100.47 42.1747 100.455 44.1564 100.455 46.768C100.455 48.1814 100.44 49.2721 100.409 50.0402ZM91.6063 70.7795C92.4359 70.7795 93.1272 68.9667 93.6803 65.3412C94.2333 61.7464 94.5867 57.2606 94.7403 51.8837C93.4191 54.9562 92.3745 57.8904 91.6063 60.6864C90.8382 63.4824 90.4542 65.8328 90.4542 67.7378C90.4542 68.7209 90.5771 69.4737 90.8229 69.996C91.0379 70.5183 91.2991 70.7795 91.6063 70.7795Z" fill="#4FB98F"/>
<path d="M135.41 43.9567C135.809 43.9567 136.116 44.1411 136.332 44.5098C136.577 44.8785 136.7 45.3854 136.7 46.0306C136.7 47.2596 136.408 48.2121 135.825 48.8881C134.688 50.2707 133.075 51.5458 130.985 52.7133C128.927 53.8808 126.715 54.4646 124.349 54.4646C121.123 54.4646 118.619 53.589 116.837 51.8376C115.055 50.0863 114.164 47.6898 114.164 44.648C114.164 42.528 114.609 40.5616 115.5 38.7489C116.391 36.9054 117.62 35.4459 119.187 34.3706C120.785 33.2952 122.582 32.7575 124.579 32.7575C126.361 32.7575 127.79 33.2952 128.865 34.3706C129.941 35.4152 130.478 36.8439 130.478 38.6567C130.478 40.7767 129.71 42.6048 128.174 44.1411C126.669 45.6466 124.103 46.8449 120.478 47.7359C121.246 49.1492 122.705 49.8559 124.856 49.8559C126.238 49.8559 127.805 49.3797 129.557 48.4272C131.339 47.444 132.875 46.1689 134.165 44.6019C134.534 44.1718 134.949 43.9567 135.41 43.9567ZM123.796 37.2741C122.659 37.2741 121.691 37.9347 120.892 39.2558C120.124 40.577 119.74 42.1747 119.74 44.0489V44.1411C121.553 43.7109 122.982 43.0657 124.026 42.2054C125.071 41.3451 125.593 40.3466 125.593 39.2097C125.593 38.626 125.424 38.1651 125.086 37.8271C124.779 37.4584 124.349 37.2741 123.796 37.2741Z" fill="#4FB98F"/>
<path d="M139.169 37.1358C139.108 38.672 139.077 39.8703 139.077 40.7306C139.077 42.9428 139.185 44.6788 139.4 45.9385C139.646 47.1675 140.03 48.0585 140.552 48.6115C141.105 49.1339 141.858 49.395 142.81 49.395C143.302 49.395 143.886 49.2414 144.562 48.9341C145.238 48.6269 145.852 48.2275 146.405 47.7359C146.743 47.4286 147.081 47.275 147.419 47.275C147.788 47.275 148.08 47.4901 148.295 47.9202C148.541 48.3196 148.663 48.8112 148.663 49.395C148.663 49.9788 148.541 50.5472 148.295 51.1002C148.08 51.6533 147.742 52.1142 147.281 52.4829C145.683 53.804 143.87 54.4646 141.843 54.4646C138.924 54.4646 136.788 53.251 135.436 50.8237C134.085 48.3657 133.409 45.1704 133.409 41.2376C133.409 39.8857 133.455 38.5184 133.547 37.1358H131.749C130.828 37.1358 130.198 36.9668 129.86 36.6288C129.553 36.2909 129.399 35.7532 129.399 35.0158C129.399 33.2952 130.09 32.4349 131.473 32.4349H134.1C134.622 29.0552 135.421 25.9673 136.496 23.1714C137.572 20.3754 138.862 18.1479 140.368 16.4887C141.904 14.8296 143.548 14 145.299 14C146.59 14 147.603 14.5684 148.341 15.7052C149.078 16.842 149.447 18.2708 149.447 19.9913C149.447 24.7537 147.45 28.9015 143.456 32.4349H148.617C149.109 32.4349 149.462 32.5424 149.677 32.7575C149.892 32.9726 150 33.372 150 33.9558C150 36.0758 148.264 37.1358 144.792 37.1358H139.169ZM144.055 18.4244C143.594 18.4244 143.072 19.0081 142.488 20.1757C141.935 21.3125 141.397 22.9102 140.875 24.9688C140.383 26.9966 139.968 29.2549 139.63 31.7436C141.443 30.1766 142.795 28.4253 143.686 26.4896C144.608 24.5233 145.069 22.7412 145.069 21.1435C145.069 19.3308 144.731 18.4244 144.055 18.4244Z" fill="#4FB98F"/>
</svg>'''

# モニターアイコン
SVG_MONITOR = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.33325 14V12.6667H2.66659C2.29992 12.6667 1.98614 12.5362 1.72525 12.2753C1.46436 12.0144 1.3337 11.7004 1.33325 11.3333V3.33333C1.33325 2.96667 1.46392 2.65289 1.72525 2.392C1.98659 2.13111 2.30036 2.00044 2.66659 2H13.3333C13.6999 2 14.0139 2.13067 14.2753 2.392C14.5366 2.65333 14.667 2.96711 14.6666 3.33333V11.3333C14.6666 11.7 14.5361 12.014 14.2753 12.2753C14.0144 12.5367 13.7004 12.6671 13.3333 12.6667H10.6666V14H5.33325ZM2.66659 11.3333H13.3333V3.33333H2.66659V11.3333Z" fill="#317C75"/>
</svg>'''

# 鍵アイコン（API KEY）
SVG_KEY = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 1.75C7.65279 1.75 5.75 3.65279 5.75 6C5.75023 6.37267 5.79949 6.74369 5.89648 7.10352L1.75 11.25V14.25H4.75V12.75H6.25V11.25H7.75L8.90039 10.0996C9.25878 10.1976 9.62847 10.2482 10 10.25C12.3472 10.25 14.25 8.34722 14.25 6.00001C14.25 3.6528 12.3472 1.75 10 1.75Z" stroke="#317C75" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M10.75 5.75C11.0261 5.75 11.25 5.52614 11.25 5.25C11.25 4.97386 11.0261 4.75 10.75 4.75C10.4739 4.75 10.25 4.97386 10.25 5.25C10.25 5.52614 10.4739 5.75 10.75 5.75Z" fill="#317C75" stroke="#317C75" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# バックアップアイコン
SVG_BACKUP = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.75 10.75H1.75M1.75 10.75C1.75 10.75 4.25 14.25 8 14.25C11.4518 14.25 14.25 11.75 14.25 8.75M1.75 10.75V14.25M11.25 5.25H14.25M14.25 5.25C14.25 5.25 11.75 1.75 8 1.75C4.54822 1.75 1.75 4.25 1.75 7.25M14.25 5.25V1.75" stroke="#317C75" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# ゴミ箱アイコン（キャラクター削除）- デフォルト緑
SVG_TRASH = '''<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.25 1.125V9.875C9.25 10.1875 8.9375 10.5 8.625 10.5H5.5H2.375C2.0625 10.5 1.75 10.1875 1.75 9.875V1.125" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M0.5 1.125H10.5" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.25 0.5H6.75M4.25 3.625V8M6.75 3.625V8" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# ゴミ箱アイコン（赤 - ホバー用）
SVG_TRASH_RED = '''<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.25 1.125V9.875C9.25 10.1875 8.9375 10.5 8.625 10.5H5.5H2.375C2.0625 10.5 1.75 10.1875 1.75 9.875V1.125" stroke="#E57373" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M0.5 1.125H10.5" stroke="#E57373" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.25 0.5H6.75M4.25 3.625V8M6.75 3.625V8" stroke="#E57373" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# ペンアイコン（名前編集）
SVG_PEN = '''<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22 7.24002C22.0008 7.10841 21.9756 6.97795 21.9258 6.85611C21.876 6.73427 21.8027 6.62346 21.71 6.53002L17.47 2.29002C17.3766 2.19734 17.2658 2.12401 17.1439 2.07425C17.0221 2.02448 16.8916 1.99926 16.76 2.00002C16.6284 1.99926 16.4979 2.02448 16.3761 2.07425C16.2543 2.12401 16.1435 2.19734 16.05 2.29002L13.22 5.12002L2.29002 16.05C2.19734 16.1435 2.12401 16.2543 2.07425 16.3761C2.02448 16.4979 1.99926 16.6284 2.00002 16.76V21C2.00002 21.2652 2.10537 21.5196 2.29291 21.7071C2.48045 21.8947 2.7348 22 3.00002 22H7.24002C7.37994 22.0076 7.51991 21.9857 7.65084 21.9358C7.78176 21.8858 7.90073 21.8089 8.00002 21.71L18.87 10.78L21.71 8.00002C21.8011 7.90298 21.8755 7.79146 21.93 7.67002C21.9397 7.59031 21.9397 7.50973 21.93 7.43002C21.9347 7.38347 21.9347 7.33657 21.93 7.29002L22 7.24002ZM6.83002 20H4.00002V17.17L13.93 7.24002L16.76 10.07L6.83002 20ZM18.17 8.66002L15.34 5.83002L16.76 4.42002L19.58 7.24002L18.17 8.66002Z" fill="#65CAA2"/>
</svg>'''

# 吹き出しパレットアイコン
SVG_PALETTE = '''<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 0C7.57372 0 9.09315 0.562557 10.2217 1.57812C11.3521 2.59552 12 3.98881 12 5.45508C11.9999 6.32295 11.6547 7.15487 11.041 7.76855C10.4273 8.38222 9.59544 8.72753 8.72754 8.72754H7.5C7.42411 8.72758 7.34972 8.74916 7.28516 8.78906C7.22063 8.829 7.1687 8.88623 7.13477 8.9541C7.10094 9.02186 7.08606 9.09742 7.09277 9.17285C7.09958 9.24837 7.12742 9.32113 7.17285 9.38184L7.33691 9.59961C7.50401 9.8224 7.60581 10.0879 7.63086 10.3652C7.65587 10.6426 7.60302 10.9218 7.47852 11.1709C7.35394 11.4201 7.16177 11.6299 6.9248 11.7764C6.68796 11.9227 6.4151 12 6.13672 12H6C4.40892 11.9999 2.88294 11.3682 1.75781 10.2432C0.632604 9.11796 0 7.59129 0 6C6.37294e-05 4.4088 0.632661 2.88296 1.75781 1.75781C2.88296 0.632661 4.4088 6.37263e-05 6 0ZM6 1.09082C4.69813 1.09088 3.44987 1.60873 2.5293 2.5293C1.60873 3.44987 1.09088 4.69813 1.09082 6C1.09082 7.30196 1.60867 8.55105 2.5293 9.47168C3.44984 10.3921 4.69824 10.9091 6 10.9092H6.13672C6.21265 10.9092 6.28697 10.8876 6.35156 10.8477C6.41611 10.8077 6.46898 10.7505 6.50293 10.6826C6.53663 10.6149 6.55066 10.5392 6.54395 10.4639C6.53713 10.3883 6.50934 10.3156 6.46387 10.2549L6.2998 10.0371C6.1327 9.8143 6.0309 9.54887 6.00586 9.27148C5.98085 8.99412 6.0337 8.71492 6.1582 8.46582C6.28275 8.21674 6.47504 8.00777 6.71191 7.86133C6.9488 7.71495 7.22154 7.63676 7.5 7.63672H8.72754L8.83594 7.63379C9.3751 7.60698 9.88698 7.3806 10.2705 6.99707C10.6794 6.58801 10.9091 6.03345 10.9092 5.45508C10.9092 4.31744 10.4076 3.21252 9.49219 2.38867C8.57492 1.56323 7.31933 1.09082 6 1.09082ZM3 5.4541C3.4516 5.45425 3.81814 5.82087 3.81836 6.27246C3.81836 6.72423 3.45174 7.09067 3 7.09082C2.54831 7.09061 2.18164 6.7242 2.18164 6.27246C2.18186 5.82091 2.54845 5.45431 3 5.4541ZM9 4.36328C9.45161 4.36343 9.81815 4.73005 9.81836 5.18164C9.81826 5.63333 9.45167 5.99985 9 6C8.54838 5.99979 8.18174 5.63329 8.18164 5.18164C8.18185 4.73008 8.54844 4.36349 9 4.36328ZM4.09082 2.72754C4.54241 2.72759 4.9088 3.0934 4.90918 3.54492C4.90918 3.99676 4.54265 4.36323 4.09082 4.36328C3.63913 4.36307 3.27246 3.99666 3.27246 3.54492C3.27284 3.09351 3.63937 2.72775 4.09082 2.72754ZM6.81836 2.18164C7.26992 2.18185 7.63553 2.54844 7.63574 3C7.63559 3.45161 7.26996 3.81815 6.81836 3.81836C6.36677 3.81815 6.00015 3.45161 6 3C6.00021 2.54844 6.3668 2.18185 6.81836 2.18164Z" fill="#349971"/>
</svg>'''

# 虫眼鏡+アイコン（サイズ調整）
SVG_SCALE = '''<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.19706 0.642873C7.76832 0.972721 8.26543 1.41682 8.65734 1.94744C9.04925 2.47806 9.32754 3.08379 9.47484 3.7268C9.62213 4.36981 9.63526 5.03629 9.51341 5.6846C9.39155 6.33292 9.13733 6.94914 8.76662 7.49478L11.7318 10.4595C11.8969 10.6222 11.9928 10.8423 11.9996 11.074C12.0064 11.3057 11.9235 11.531 11.7682 11.7031C11.613 11.8752 11.3973 11.9807 11.1661 11.9976C10.935 12.0145 10.7062 11.9416 10.5275 11.794L10.4591 11.7322L7.49454 8.76692C6.78527 9.24872 5.95984 9.53164 5.10416 9.58625C4.24847 9.64086 3.39378 9.46517 2.62902 9.07744C1.86425 8.68971 1.21735 8.10412 0.755628 7.3816C0.293903 6.65908 0.0342202 5.82602 0.00359856 4.9691L0 4.79816L0.00299884 4.62722C0.0325031 3.79997 0.275509 2.99443 0.708398 2.28887C1.14129 1.58332 1.74933 1.00177 2.47344 0.600726C3.19755 0.199686 4.01309 -0.00719433 4.8408 0.000191023C5.66851 0.00757638 6.48022 0.228977 7.19706 0.642873ZM4.79804 2.39904C4.65114 2.39905 4.50936 2.45299 4.39958 2.55061C4.2898 2.64823 4.21967 2.78274 4.20249 2.92864L4.19829 2.99882V4.19838H2.99878L2.9286 4.20258C2.78283 4.21992 2.64849 4.29012 2.55101 4.39989C2.45353 4.50965 2.39969 4.65136 2.39969 4.79816C2.39969 4.94497 2.45353 5.08667 2.55101 5.19644C2.64849 5.3062 2.78283 5.37641 2.9286 5.39375L2.99878 5.39794H4.19829V6.59751L4.20249 6.66768C4.21982 6.81346 4.29002 6.94781 4.39978 7.0453C4.50954 7.14278 4.65124 7.19662 4.79804 7.19662C4.94484 7.19662 5.08654 7.14278 5.1963 7.0453C5.30606 6.94781 5.37626 6.81346 5.3936 6.66768L5.3978 6.59751V5.39794H6.59731L6.66748 5.39375C6.81325 5.37641 6.9476 5.3062 7.04508 5.19644C7.14256 5.08667 7.19639 4.94497 7.19639 4.79816C7.19639 4.65136 7.14256 4.50965 7.04508 4.39989C6.9476 4.29012 6.81325 4.21992 6.66748 4.20258L6.59731 4.19838H5.3978V2.99882L5.3936 2.92864C5.37641 2.78274 5.30628 2.64823 5.1965 2.55061C5.08673 2.45299 4.94494 2.39905 4.79804 2.39904Z" fill="#349971"/>
</svg>'''

# 削除アイコン
SVG_DELETE = '''<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.25 1.125V9.875C9.25 10.1875 8.9375 10.5 8.625 10.5H5.5H2.375C2.0625 10.5 1.75 10.1875 1.75 9.875V1.125" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M0.5 1.125H10.5" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.25 0.5H6.75M4.25 3.625V8M6.75 3.625V8" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# カメラアイコン（画像変更）
SVG_CAMERA = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="1" y="4" width="14" height="10" rx="2" stroke="#8ECFB5" stroke-width="1.2" fill="none"/>
<circle cx="8" cy="9" r="3" stroke="#8ECFB5" stroke-width="1.2" fill="none"/>
<path d="M5 4V3C5 2.44772 5.44772 2 6 2H10C10.5523 2 11 2.44772 11 3V4" stroke="#8ECFB5" stroke-width="1.2"/>
</svg>'''

# 吹き出しアイコン（画像変更ボタン用）
SVG_IMAGE_CHANGE = '''<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M0 1.94801C0 1.43137 0.205236 0.935882 0.570559 0.570559C0.935882 0.205236 1.43137 0 1.94801 0H11.0387C11.5554 0 12.0509 0.205236 12.4162 0.570559C12.7815 0.935882 12.9867 1.43137 12.9867 1.94801V6.1687C12.9867 6.22347 12.9797 6.27801 12.966 6.33103C12.9797 6.38405 12.9867 6.4386 12.9867 6.49337V11.0387C12.9867 11.5554 12.7815 12.0509 12.4162 12.4162C12.0509 12.7815 11.5554 12.9867 11.0387 12.9867H1.94801C1.43137 12.9867 0.935882 12.7815 0.570559 12.4162C0.205236 12.0509 0 11.5554 0 11.0387V9.09071C5.2139e-05 9.03594 0.00703388 8.9814 0.0207788 8.92838C0.00703388 8.87536 5.2139e-05 8.82082 0 8.76605V1.94801ZM1.94411 8.33099C1.71814 8.33532 1.503 8.34528 1.29867 8.36086V1.94801C1.29867 1.7758 1.36709 1.61063 1.48886 1.48886C1.61063 1.36709 1.7758 1.29867 1.94801 1.29867H11.0387C11.2109 1.29867 11.3761 1.36709 11.4979 1.48886C11.6196 1.61063 11.6881 1.7758 11.6881 1.94801V5.85442C8.89786 5.94468 6.88297 6.61674 5.46741 7.55763C6.00377 7.74789 6.60375 8.01866 7.19205 8.3732C8.10048 8.91864 9.02383 9.68486 9.64525 10.6998C9.68976 10.7725 9.71951 10.8533 9.7328 10.9375C9.74609 11.0218 9.74265 11.1078 9.7227 11.1907C9.70274 11.2736 9.66664 11.3518 9.61648 11.4207C9.56631 11.4897 9.50305 11.5481 9.43032 11.5926C9.35758 11.6371 9.27679 11.6669 9.19255 11.6802C9.10832 11.6934 9.02229 11.69 8.93938 11.6701C8.85648 11.6501 8.77831 11.614 8.70935 11.5638C8.64039 11.5137 8.58199 11.4504 8.53748 11.3777C8.05957 10.5965 7.31802 9.96342 6.52324 9.48616C5.72975 9.00955 4.92262 8.71215 4.36289 8.58228C3.57438 8.40243 2.76706 8.31828 1.9584 8.33164H1.94411V8.33099ZM3.2324 2.91422C3.52174 2.71016 3.86663 2.59958 4.22069 2.59735C4.48692 2.59735 4.87197 2.67202 5.20898 2.91422C5.5791 3.18045 5.84403 3.6194 5.84403 4.22069C5.84403 4.82197 5.5791 5.26028 5.20898 5.5265C4.91971 5.7308 4.57482 5.84161 4.22069 5.84403C3.95446 5.84403 3.5694 5.76936 3.2324 5.5265C2.86228 5.26028 2.59735 4.82262 2.59735 4.22069C2.59735 3.6194 2.86228 3.1811 3.2324 2.91422Z" fill="#349971"/>
</svg>'''

# 吹き出し設定アイコン（下部ボタン用）- ハートアイコン
SVG_BUBBLE_SETTING = '''<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 10.5C6 10.5 1.5 7.5 1.5 4.5C1.5 3.5 2.5 2 4 2C5 2 5.5 2.5 6 3C6.5 2.5 7 2 8 2C9.5 2 10.5 3.5 10.5 4.5C10.5 7.5 6 10.5 6 10.5Z" stroke="#349971" stroke-width="1.2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# Kiwipet ロゴ SVG（簡略版）
SVG_LOGO = '''<svg width="150" height="40" viewBox="0 0 150 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<text x="0" y="30" font-family="Pretendard JP, Meiryo, sans-serif" font-size="28" font-weight="600" fill="#4FB98F">Kiwipet</text>
</svg>'''
import urllib.request
import urllib.error
import threading
import ssl
from io import BytesIO
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QPushButton, QLabel, QFileDialog, 
                             QScrollArea, QFrame, QMessageBox, QDialog, 
                             QRadioButton, QButtonGroup, QComboBox, QLineEdit,
                             QCheckBox, QColorDialog, QTextEdit, QGridLayout,
                             QGroupBox, QGraphicsDropShadowEffect, QSlider)
from PyQt5.QtCore import Qt, QTimer, QPoint, QPointF, QPropertyAnimation, QEasingCurve, pyqtSignal, QSize
from PyQt5.QtGui import QPixmap, QPainter, QFont, QColor, QPen, QPainterPath, QTransform, QIcon, QMovie, QImage

# SSL証明書検証バイパス（Macでの証明書問題解決用）
try:
    _ssl_context = ssl.create_default_context()
    _ssl_context.check_hostname = False
    _ssl_context.verify_mode = ssl.CERT_NONE
except:
    _ssl_context = None

# Windows ウィンドウ検出用（オプション）
_win32_available = False
try:
    import win32gui
    import win32con
    _win32_available = True
except ImportError:
    pass

# ==================== プラットフォーム別フォント設定 ====================
import platform
from PyQt5.QtGui import QFontDatabase

# Pretendard フォント読み込み関こと
def load_pretendard_font():
    """Pretendard フォント読み込み - 内蔵またはシステム"""
    font_db = QFontDatabase()
    
    # 1. 実行ファイルと同じパスでフォントを探す
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    
    font_files = [
        'PretendardJP-Medium.otf',
        'PretendardJP-Bold.otf'
    ]
    
    loaded = False
    for font_file in font_files:
        font_path = os.path.join(base_path, font_file)
        if os.path.exists(font_path):
            font_id = font_db.addApplicationFont(font_path)
            if font_id >= 0:
                loaded = True
                print(f"[フォント] {font_file} 読み込み成功")
        else:
            print(f"[フォント] {font_file} ファイルなし: {font_path}")
    
    # 2. システムにPretendardがインストールされているか確認
    if not loaded:
        families = font_db.families()
        if 'Pretendard JP' in families or 'Pretendard Variable' in families:
            loaded = True
            print("[フォント] システムPretendard使用")
    
    return loaded

# フォント名設定（後でQApplication生成後に読み込み）
KOREAN_FONT = 'Pretendard JP'
KOREAN_FONT_FALLBACK = 'Apple SD Gothic Neo' if platform.system() == 'Darwin' else 'Meiryo'
KOREAN_FONT_CSS = f"'Pretendard JP', '{KOREAN_FONT_FALLBACK}', sans-serif"

# ==================== 内蔵画像（Base64）====================
# kiwipet_title.png - Base64エンコード
TITLE_IMAGE_BASE64 = """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53Frw8orVXYjY7NrvO3WoWlX3s3hbyt6utl/IEjk7nGcZ9S0PSuv19NnZqi0YAsieitVziqKxKe6/oXAhKKFFYyhvtfC3lb1dbL9chEEmitXIAARkBd80a3hNpaJT3ZeGbz7Q6aQR1U7z2Vs0xFCe85+FcUJH4mNZTOVnTNQZlsrvn2jwPRvPZWzTES04jFUTZ5pp5GcKS9y9nZz53yiXu2bdu3aWFr7R3obxOM64oQaM0xn1R8dLbakCxZ8aJT0fM9PefaPml5noiUygM95q4zDe0fNq5xolPefaPm1c40SnvPtHzaLmqr1aucaJT3n2j5tXONEp7z7R82rm3jLdnT0K1C0q+5NIKJ7+UVquQAmZj/mf3yie/lFarnGiU959o+bVzjRKe8+0PcrrtiU959o+bVzjRKe8+0fNq5xolPebDUZwsWLBBPfyitVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzaubZ5z527weUVqucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzauPRBgguV2d8onv5RWq5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKej5BjtxvtfaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm0XNVcfiz40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm1c40SnpS/NoRVZWP5q5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xokvFCihl+bVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjOWy/Vm+lY5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPSl+acatVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRJVUg3oHyytkwqJ7+UVqucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzStZNnDGXXMm1c40SnvPtHzaucaJT3n2j5tXGgAP0XBU8dUclY0U6OqNJfRNCX4iR8ecPYSdaWgAAELvH/TxS9wAAAAGcvdG/PoqMQLOd+AAAABVrnH5b7E1+jOPow2G39Dw74u+qb/AAAAVU9wc+UYREFniuQhJnMpF9XVrGShkP6MNh8/Q4AAAaf0TQlAObsKMMavC+h7v6KlMG1a9+xECR+iaEnAIH6JwnRIb5VIvlWXc/+fkJZptKZUqfMU5v0TiuQQW30ThOgAbf0ThOiq/Z4bmis+h7v6KqU9wc5z6NEn1uHwWPP9h8z/5+QiQKdci7+imP5duc0v0D4LHoEcNQ4LHe8+ia0TkF6LP8wAABhRQTleRIFqIfVf0ON4KPZKEsKJy/zMFdRCyDFWD4Nvs9C6tYyULD3n/z8hLUxT756iEmcykXVdWsZKFsv6NBezEtKPAyvo0F7MS0o8GF8oRK2dD6KX/9FNBWCb24V0gYREFniQAAKK8/9ubnzaUypUKt7LVuRiLbzADSwjnl3WDStadv0+k4+jQXsxLSjwznZDbA/AAMP6L6r3Rvli3xd9U4CmMfVgiaPosRiNN0I5s2G/v89hqUqDt+yD8cOU7mDmWCb24Vnyd6KLcyZzwjuyG2CE6O6v+2k33ooty/6ve3e9FFuX/V7/wBm3U09oyG2CE6O6v+2mn6MNhQH8opyGTTr+RukXYyR+jQXsxLSkflMHywTe3CtZVzj8t9iGW+7exVW0fCRukY4mHe/obYIhKdkNsEJ0d1f9tlFyMn6teGnY/Rsv0OEAjdIxxM/9FRd9GgvZiWlIjb5VIarAfz+hc4/LfYMDvlUhouyG2CF6DQHWCb24Vo3+UIlbY8ZUiK+3EAAi0Kfo0F7MS0pB8ph9N0J9GFQGbcrMADJkj970UW5V5wdv2Qgpz2cIoHy6u6DfF31Tf51C5xuDKfA2mdRwmVPcHO4+jRJ9KZd1g0oKfNs1lme2kLp7g53H0aJPpTLusGk60wn/RnnX4l25zS8j6L4ux9WCHvn6M87b2rbF3ootyoJVfJoXos/zMxin3wg5uvxqHBY7sv6NEnxJfKEStoURaHOyG2CBlF9AIwxqwUq58wKN0jHErX5PdVt+f0X/70UW5ZfQbmXgfKEStmDvdaL6NEnwvmXAikaBin4D2XdYNLCIPpXF9zAg0bl8OMnvopTyBFtMvoOwX04BFtMhvo0SfR1t5gDoXrRblmX0ZuznjLbmxf0Z+nz2A/oRGdQLNULj6KrP0Vd0R9aDspyEtn0WHquYXIyfq0iF6LP8zEjDGwQ4sicv8zBq0bpGOLiY1wiN0jHElZPcHPOAstdD6M7WXdYNKEhP4kfWsuO6h7tZin35DLtzml4v0Va/ozztvawf+WZ7aWFG6Rji4mNbX2/9ATVuDKeRRM54y25q/+UIlbY8ZIdJD2yJIF1n0Xr+UIlbYaFEr8LKwd6KLctK+jJCZZ6w8NzVgucflvsJq0qlcjJ+rSz6KXyEJM5lIlX5QiVtjxkhcroNROX+Zgo9l3WDSwiDqBk75lIzk2lMqVHvB2/ZB+OHKdzGp9FfK5x+W+whv0WSLLM9tSz6MkAvFgm9uFayzuHCk82b76KtjsfVgiJKN0jHFm44ntT5z6KkG8f9PHWNE0SGKwTe3Cuk/RV7g+GRRukY4q/KcXF90yjgi9Q+QgynwZT0iXIyfq17zrjiS+Nj6KrSxUYuTrEGtOnkFFNoNzX0aJPfkYjdIuxm99GiT39X9GfpyZ+inivP/bm6iJy/zMEknzrjiTU8j7HwFioxcnOjfoqk/Rok+Eyicv8zBMF9GiT4BdnrDwjKlz9GeZYvOxEVDWAmcvopX+IoHy6vCH6NBezEtKQQW93rSlXRSlj7Whu/v89hqIH+jQXsxLSkFU/fwUHtIC39/nspji8RhU17WBrXBlozYfxuZ0y8B1iRfo0Se/x1ioxcnSF42td+jDYjQxP0jOparn60MT9z9GGzA+UIlbP7GGNYg+jDYOGD214sIAP0UqTZ6w8IyoPECznhhnUABcGYC32CAHLOmo4vozztvatQABSM6gAAAAFHbeX9gAAAAVoLgAAAAEnl3WDSgngynkAAAAAAAAAAEfl25zS5d9FKAAAADa8AAAAAjPopQAAAAdtIAAAABafRn6cAAAAAKL6NEnvwAAA"""

# kiwipet_character.png - Base64エンコード（シンプルなキャラクターシルエット）
def get_embedded_pixmap(base64_data):
    """Base64文字列からQPixmapを生成"""
    try:
        image_data = base64.b64decode(base64_data.strip())
        pixmap = QPixmap()
        pixmap.loadFromData(image_data)
        return pixmap
    except:
        return QPixmap()


def find_image_file(app_dir, base_name):
    """様々な拡張子で画像ファイルを探す"""
    extensions = ['.png', '.PNG', '.jpg', '.JPG', '.jpeg', '.JPEG', '.gif', '.GIF', '.bmp', '.BMP']
    
    for ext in extensions:
        file_path = os.path.join(app_dir, base_name + ext)
        if os.path.exists(file_path):
            print(f"[画像発見] {file_path}")
            return file_path
    
    # 拡張子のないファイルも試行
    file_path = os.path.join(app_dir, base_name)
    if os.path.exists(file_path):
        print(f"[画像発見] {file_path}")
        return file_path
    
    print(f"[画像なし] {base_name} in {app_dir}")
    return None


class ToggleSwitch(QWidget):
    """iOSスタイルトグルスイッチ - 33x17サイズ"""
    toggled = pyqtSignal(bool)
    rightClicked = pyqtSignal()  # 右クリックシグナル
    
    def __init__(self, checked=True, parent=None):
        super().__init__(parent)
        self._checked = checked
        self.setFixedSize(33, 17)
        self.setCursor(Qt.PointingHandCursor)
    
    @property
    def checked(self):
        return self._checked
    
    @checked.setter
    def checked(self, value):
        self._checked = value
        self.update()
    
    def isChecked(self):
        return self._checked
    
    def setChecked(self, checked):
        self._checked = checked
        self.update()
    
    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            self.rightClicked.emit()
        else:
            self._checked = not self._checked
            self.toggled.emit(self._checked)
            self.update()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 背景
        if self._checked:
            # ON: パステルミント背景
            painter.setBrush(QColor("#8ECFB5"))
            painter.setPen(Qt.NoPen)
        else:
            # OFF: 暗いミント背景
            painter.setBrush(QColor("#536E6C"))
            painter.setPen(Qt.NoPen)
        
        painter.drawRoundedRect(0, 0, self.width(), self.height(), 8, 8)
        
        # 白い円（直径約14）
        circle_diameter = 14
        circle_y = (self.height() - circle_diameter) // 2
        if self._checked:
            # ON: 白い円右
            circle_x = self.width() - circle_diameter - 2
        else:
            # OFF: 白い円左
            circle_x = 2
        
        painter.setBrush(QColor("#FFFFFF"))
        painter.setPen(Qt.NoPen)
        painter.drawEllipse(circle_x, circle_y, circle_diameter, circle_diameter)


class IconButton(QPushButton):
    """ミニマルアイコンボタン - かわいいパステルミント"""
    def __init__(self, icon_type, parent=None):
        super().__init__(parent)
        self.icon_type = icon_type  # 'pen', 'palette', 'scale'
        self.setFixedSize(28, 28)
        self.setCursor(Qt.PointingHandCursor)
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # ホバーエフェクト - 薄いミント
        if self.underMouse():
            painter.fillRect(self.rect(), QColor("#E8F5EE"))
        
        # アイコン色 - パステルミント
        icon_color = QColor("#8ECFB5")
        pen = QPen(icon_color)
        pen.setWidth(2)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        painter.setPen(pen)
        
        cx, cy = self.width() // 2, self.height() // 2
        
        if self.icon_type == 'pen':
            # シンプルな鉛筆アイコン（斜め鉛筆）
            painter.setPen(QPen(icon_color, 2, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
            # 鉛筆本体（傾いた四角形）
            path = QPainterPath()
            path.moveTo(18, 6)
            path.lineTo(22, 10)
            path.lineTo(10, 22)
            path.lineTo(6, 18)
            path.closeSubpath()
            painter.drawPath(path)
            # 鉛筆先端（三角形）
            painter.drawLine(6, 18, 4, 24)
            painter.drawLine(10, 22, 4, 24)
            # 鉛筆先端線
            painter.drawLine(6, 18, 10, 22)
            
        elif self.icon_type == 'palette':
            # 水滴/カラーアイコン（3つの重なった円）
            painter.setPen(Qt.NoPen)
            # 薄いピンク円
            painter.setBrush(QColor("#FFB5BA"))
            painter.drawEllipse(4, 8, 10, 10)
            # 薄い黄色円
            painter.setBrush(QColor("#FFE5A0"))
            painter.drawEllipse(11, 5, 10, 10)
            # 薄いミント円
            painter.setBrush(QColor("#8ECFB5"))
            painter.drawEllipse(9, 13, 10, 10)
            
        elif self.icon_type == 'scale':
            # 虫眼鏡アイコン
            painter.setBrush(Qt.NoBrush)
            painter.setPen(QPen(icon_color, 2))
            painter.drawEllipse(5, 5, 14, 14)
            painter.setPen(QPen(icon_color, 3, Qt.SolidLine, Qt.RoundCap))
            painter.drawLine(17, 17, 23, 23)

__version__ = "1.1.2"
__author__ = "Kiwipet Team"

# ==================== AIセリフ生成（Gemini API）====================
# API設定
_gemini_api_key = None
_gemini_model = "gemini-2.5-flash-lite"  # デフォルトモデル
_ai_enabled = False

# 使用可能なGeminiモデルリスト
GEMINI_MODELS = [
    ("gemini-2.5-flash-lite", "Gemini 2.5 Flash Lite（デフォルト）"),
    ("gemini-2.0-flash", "Gemini 2.0 Flash"),
    ("gemini-1.5-flash", "Gemini 1.5 Flash"),
    ("gemini-1.5-flash-8b", "Gemini 1.5 Flash 8B"),
]
_ai_dialogues_cache = {}  # {char_id: {'solo': [], 'interaction': [], 'generated_at': time}}
_temp_dialogues_cache = {}  # 時間/日付な時セリフ
_ai_generation_interval = 3600  # 1時間（秒）
_ai_dialogues_count = 10  # キャラクターあたり生成するセリフこと

def is_similar_dialogue(new_dialogue, existing_dialogues, prefix_len=4):
    """
    新しいセリフが既存のセリフと類似しているかチェック
    - 先頭N文字が同じなら類似と判断
    - 完全に同じセリフも類似として処理
    """
    if not new_dialogue or not existing_dialogues:
        return False

    new_clean = new_dialogue.strip()
    if len(new_clean) < prefix_len:
        # 短いセリフは完全に同じ場合のみチェック
        return new_clean in [d.strip() for d in existing_dialogues if d]

    new_prefix = new_clean[:prefix_len]

    for existing in existing_dialogues:
        if not existing:
            continue
        existing_clean = existing.strip()

        # 完全に同じ場合
        if new_clean == existing_clean:
            return True

        # 先頭N文字が同じ場合
        if len(existing_clean) >= prefix_len and existing_clean[:prefix_len] == new_prefix:
            return True

    return False

def sync_dialogues_to_ai_cache(char_id, dialogues):
    """手動セリフをAIキャッシュのreferenceフィールドに同期（AI生成時の参考用のみ、実際のセリフとしては出力しない）"""
    global _ai_dialogues_cache

    if not dialogues:
        return

    if char_id not in _ai_dialogues_cache:
        _ai_dialogues_cache[char_id] = {
            'solo': [],
            'interaction': {},
            'fallback': [],
            'reference': {},  # 参考用手動セリフ (AI生成時のみ使用)
            'generated_at': time.time()
        }

    cache = _ai_dialogues_cache[char_id]

    # referenceフィールド初期化
    if 'reference' not in cache:
        cache['reference'] = {}

    # 基本セリフ → reference['基本']（参考用のみ保存）
    if '基本' in dialogues:
        if '基本' not in cache['reference']:
            cache['reference']['基本'] = []
        for d in dialogues['基本']:
            if d and isinstance(d, str) and d.strip() and d != '（任意）' and d not in cache['reference']['基本']:
                cache['reference']['基本'].append(d)

    # 相互作用セリフ → reference（参考用のみ保存）
    for key, values in dialogues.items():
        if key == '基本':
            continue
        if not isinstance(values, list):
            continue

        # キー形式統な: 'char_X' → int X, int → int, str 数字 → int
        cache_key = None
        if isinstance(key, str):
            if key.startswith('char_'):
                try:
                    cache_key = int(key.replace('char_', ''))
                except ValueError:
                    cache_key = key
            else:
                try:
                    cache_key = int(key)
                except ValueError:
                    cache_key = key
        elif isinstance(key, int):
            cache_key = key
        else:
            cache_key = key

        if cache_key is None:
            continue

        ref_key = f'char_{cache_key}' if isinstance(cache_key, int) else cache_key
        if ref_key not in cache['reference']:
            cache['reference'][ref_key] = []

        for d in values:
            if d and isinstance(d, str) and d.strip() and d != '（任意）' and d not in cache['reference'][ref_key]:
                cache['reference'][ref_key].append(d)

# 時間帯区分
TIME_PERIODS = {
    'dawn': (0, 6),        # 明け方（0-6時）
    'morning': (6, 12),    # 朝（6-12時）
    'afternoon': (12, 15), # 昼（12-15時）
    'late_afternoon': (15, 18), # 夕方（15-18時）
    'evening': (18, 21),   # 夕方（18-21時）
    'night': (21, 24)      # 夜（21-24時）
}

# 月別季節/気温情報
MONTH_SEASON_INFO = {
    1: ("真冬", "とても寒く雪が降ることも"),
    2: ("冬", "寒いけど少しずつ日が長くなる"),
    3: ("初春", "まだ肌寒いけど暖かくなってきた"),
    4: ("春", "暖かくて花が咲く時期"),
    5: ("晩春", "穏やかで晴れやか"),
    6: ("初夏", "暑くなり始め、梅雨の可能性"),
    7: ("真夏", "とても暑くて蒸し暑い"),
    8: ("真夏", "猛暑、酷暑の可能性"),
    9: ("初秋", "涼しくなり始め"),
    10: ("秋", "涼しくて紅葉の時期"),
    11: ("晩秋", "肌寒くて落ち葉"),
    12: ("初冬", "寒くて雪が降ることも")
}

def get_time_period(hour):
    """現在時刻の時間帯を返す"""
    for period, (start, end) in TIME_PERIODS.items():
        if start <= hour < end:
            return period
    return 'night'

def get_season_info(month):
    """月による季節/気温情報を返す"""
    return MONTH_SEASON_INFO.get(month, ("", ""))

def clean_api_key(api_key):
    """APIキーから全ての異常文字を削除（ASCII英数字と_-のみ許可）"""
    if not api_key:
        return ""
    import re
    # 文字列に変換
    api_key = str(api_key)
    # 1. ユニコードBOM削除
    api_key = api_key.replace('\ufeff', '').replace('\ufffe', '')
    # 2. すべての空白、改行、タブ、制御文字削除
    api_key = re.sub(r'[\s\x00-\x1f\x7f-\x9f\u200b-\u200f\u2028-\u202f]', '', api_key)
    # 3. ASCII英数字と_-のみ許可（Google APIキー形式）
    api_key = ''.join(c for c in api_key if c.isascii() and (c.isalnum() or c in '_-'))
    return api_key

def make_safe_url(base_url, api_key):
    """安全なURL生成（制御文字完全削除）"""
    import urllib.parse
    cleaned_key = clean_api_key(api_key)
    # URL安全エンコーディング（追加安全措置）
    safe_key = urllib.parse.quote(cleaned_key, safe='')
    return f"{base_url}?key={safe_key}"

def set_gemini_api_key(api_key):
    """Gemini APIキー設定（制御文字自動削除）"""
    global _gemini_api_key
    _gemini_api_key = clean_api_key(api_key)

def set_gemini_model(model):
    """Geminiモデル設定"""
    global _gemini_model
    _gemini_model = model

def get_gemini_model():
    """現在選択されているGeminiモデルを返す"""
    return _gemini_model

def set_ai_enabled(enabled):
    """AI機能有効化/無効化"""
    global _ai_enabled
    _ai_enabled = enabled

def is_ai_enabled():
    """AI機能有効化状態"""
    return _ai_enabled and bool(_gemini_api_key)

def init_temp_cache(char_id):
    """キャラクターな時キャッシュ初期化"""
    global _temp_dialogues_cache
    from datetime import datetime
    import time
    
    if char_id not in _temp_dialogues_cache:
        _temp_dialogues_cache[char_id] = {
            'time': {
                'dawn': [],           # 明け方
                'morning': [],        # 朝
                'afternoon': [],      # 昼
                'late_afternoon': [], # 夕方
                'evening': [],        # 夕方
                'night': []           # 夜
            },
            'season': [],             # 季節セリフ
            'date': [],               # 日付セリフ
            'last_date': datetime.now().strftime('%Y-%m-%d'),
            'last_month': datetime.now().month,
            'last_cleanup': time.time()
        }

def cleanup_temp_dialogues():
    """な時セリフ整理
    - 時間セリフ: 削除しない（蓄積される）
    - 季節セリフ: 月が変わると削除
    - 日付セリフ: 深夜0時に削除
    """
    global _temp_dialogues_cache
    import time
    from datetime import datetime
    
    today = datetime.now().strftime('%Y-%m-%d')
    current_month = datetime.now().month
    
    for char_id in list(_temp_dialogues_cache.keys()):
        cache = _temp_dialogues_cache[char_id]
        last_date = cache.get('last_date', today)
        last_month = cache.get('last_month', current_month)
        
        # 深夜0時を過ぎると日付セリフ削除
        if last_date != today:
            cache['date'] = []
            cache['last_date'] = today
            print(f"[AI] キャラクター {char_id} 日付セリフ初期化（深夜）")
        
        # 月が変わると季節セリフ削除
        if last_month != current_month:
            cache['season'] = []
            cache['last_month'] = current_month
            print(f"[AI] キャラクター {char_id} 季節セリフ初期化（新しい月）")

def add_temp_dialogue(char_id, dialogue_type, dialogue, sub_type=None):
    """な時セリフ追加
    
    Args:
        char_id: キャラクター ID
        dialogue_type: 'time', 'season', 'date'
        dialogue: セリフテキスト
        sub_type: 時間帯（timeタイプの時）
    """
    global _temp_dialogues_cache
    import time
    
    init_temp_cache(char_id)
    
    if dialogue_type == 'time' and sub_type:
        # 時間セリフは時間帯別に保存（蓄積される）
        if sub_type not in _temp_dialogues_cache[char_id]['time']:
            _temp_dialogues_cache[char_id]['time'][sub_type] = []
        _temp_dialogues_cache[char_id]['time'][sub_type].append(dialogue)
        print(f"[AI] 時間セリフ追加 ({sub_type}): {dialogue}")
    elif dialogue_type == 'season':
        # 季節セリフ
        _temp_dialogues_cache[char_id]['season'].append(dialogue)
        print(f"[AI] 季節セリフ追加: {dialogue}")
    else:
        # 日付セリフ
        _temp_dialogues_cache[char_id]['date'].append(dialogue)
        print(f"[AI] 日付セリフ追加: {dialogue}")

def get_temp_dialogue(char_id, dialogue_type, sub_type=None):
    """な時セリフ取得
    
    Args:
        char_id: キャラクター ID
        dialogue_type: 'time', 'season', 'date'
        sub_type: 時間帯
    """
    if char_id not in _temp_dialogues_cache:
        return None
    
    cache = _temp_dialogues_cache[char_id]
    
    if dialogue_type == 'time':
        # 現在の時間帯のセリフのみ返す
        if sub_type and sub_type in cache.get('time', {}):
            dialogues = cache['time'][sub_type]
            if dialogues:
                return random.choice(dialogues)
        return None
    elif dialogue_type == 'season':
        dialogues = cache.get('season', [])
        if dialogues:
            return random.choice(dialogues)
        return None
    else:  # date
        dialogues = cache.get('date', [])
        if dialogues:
            return random.choice(dialogues)
        return None

def get_cached_dialogue(char_id, dialogue_type='solo', other_char_id=None, other_char_name=None):
    """キャッシュからランダムセリフ取得
    
    Args:
        char_id: キャラクター ID
        dialogue_type: 'solo', 'interaction', 'fallback'のいずれか
        other_char_id: 相互作用相手ID（interactionタイプの時）
        other_char_name: 相互作用相手名（interactionタイプの時、名前で保存された場合）
    """
    import re
    
    if char_id not in _ai_dialogues_cache:
        return None
    
    cache = _ai_dialogues_cache[char_id]
    
    if dialogue_type == 'solo':
        dialogues = cache.get('solo', [])
    elif dialogue_type == 'fallback':
        dialogues = cache.get('fallback', [])
    else:  # interaction
        interaction_cache = cache.get('interaction', {})
        # 1. まずchar_idで検索
        dialogues = interaction_cache.get(other_char_id, [])
        # 2. なければキャラクター名で検索
        if not dialogues and other_char_name:
            dialogues = interaction_cache.get(other_char_name, [])
        # 3. それでもなければdefaultで検索
        if not dialogues:
            dialogues = interaction_cache.get('default', [])
    
    if dialogues:
        dialogue = random.choice(dialogues)
        # メタ情報パターン削除（関係:, 呼び方:等）
        dialogue = re.sub(r'\(関係:\s*[^,)]+,\s*呼び方:\s*[^)]+\)', '', dialogue)
        dialogue = re.sub(r'\(呼び方:\s*[^,)]+,\s*関係:\s*[^)]+\)', '', dialogue)
        dialogue = re.sub(r'\[関係:\s*[^\]]+\]', '', dialogue)
        dialogue = re.sub(r'\[呼び方:\s*[^\]]+\]', '', dialogue)
        # 前後の空白削除
        dialogue = dialogue.strip()
        return dialogue if dialogue else None
    return None

def make_unique_names(other_chars_info):
    """
    同じ名前のキャラクターがいれば区切り文字追加
    例: [("キウイ", ...), ("キウイ", ...)] -> [("キウイ", ...), ("キウイ(2)", ...)]
    
    Args:
        other_chars_info: [(name, nicknames, relationship, story), ...]
    Returns:
        [(unique_name, nicknames, relationship, story), ...]
    """
    if not other_chars_info:
        return []
    
    # 名前別出現回ことカウント
    name_counts = {}
    for info in other_chars_info:
        name = info[0]
        name_counts[name] = name_counts.get(name, 0) + 1
    
    # 重複名にインデックス追加
    name_indices = {}
    result = []
    
    for info in other_chars_info:
        name = info[0]
        
        if name_counts[name] > 1:
            # 重複名 - インデックス追加
            name_indices[name] = name_indices.get(name, 0) + 1
            idx = name_indices[name]
            if idx == 1:
                unique_name = name  # 最初はそのまま
            else:
                unique_name = f"{name}({idx})"  # 2番目から(2), (3)...
        else:
            unique_name = name
        
        # タプル再構成
        if len(info) == 4:
            result.append((unique_name, info[1], info[2], info[3]))
        else:
            result.append((unique_name,) + info[1:])
    
    return result

def generate_dialogues_batch(char_name_orig, personality_orig, sample_dialogues, other_chars_info, callback, background_story="", retry_count=0, existing_dialogues=None):
    """
    Gemini APIを使用してセリフな括生成（非同期）
    429エラー時120秒後リトライ（最大2回）

    Args:
        char_name_orig: キャラクター名
        personality_orig: キャラクター 性格
        sample_dialogues: ユーザーが入力したサンプルセリフリスト（話し方参考1位）
        other_chars_info: [(other_name, nicknames_str, relationship, story), ...] 他キャラクター情報
        callback: 生成完了後呼び出し（solo_dialogues, interaction_dialogues, fallback_dialogues）
        background_story: キャラクター背景ストーリー（任意）
        retry_count: リトライ回こと（内部使用）
        existing_dialogues: 既存セリフdict {'solo': [...], 'interaction': {...}}（重複防止用）
    """
    if not _gemini_api_key:
        callback([], {}, [])
        return
    
    def api_call():
        try:
            import re
            # すべての入力テキストから制御文字削除（URLエラー防止）
            def clean_text(text):
                if not text:
                    return ""
                text = str(text)
                # ユニコードBOM削除
                text = text.replace('\ufeff', '').replace('\ufffe', '')
                # すべての制御文字削除（改行/タブ除外）
                text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]', '', text)
                # 特殊ユニコード空白文字削除
                text = re.sub(r'[\u200b-\u200f\u2028-\u202f\u205f-\u206f]', '', text)
                return text.strip()
            
            char_name = clean_text(char_name_orig)
            personality = clean_text(personality_orig)
            background_story_clean = clean_text(background_story)
            
            print(f"[AI] 整理された入力 - 名前: {char_name}, 性格長さ: {len(personality)}")
            
            # other_chars_infoも整理
            cleaned_other_chars = []
            for info in other_chars_info:
                if len(info) == 4:
                    name, nicknames, rel, story = info
                    cleaned_other_chars.append((clean_text(name), clean_text(nicknames), clean_text(rel), clean_text(story)))
                else:
                    cleaned_other_chars.append(tuple(clean_text(x) for x in info))
            
            # 現在の時間/日付把握
            from datetime import datetime
            now = datetime.now()
            hour = now.hour
            month = now.month
            day = now.day
            
            # 時間帯
            if 5 <= hour < 9:
                time_context = "早朝"
                time_examples = "おはよう！, 起きた？, 今日も頑張ろう！"
            elif 9 <= hour < 12:
                time_context = "午前"
                time_examples = "今日何するの？, 良いな日を！, 頑張ろう～"
            elif 12 <= hour < 14:
                time_context = "お昼時"
                time_examples = "ご飯食べた？, お昼美味しく！, お腹すいた～"
            elif 14 <= hour < 18:
                time_context = "午後"
                time_examples = "ちょっと眠い…, おやつ食べる？, 午後も頑張ろう！"
            elif 18 <= hour < 21:
                time_context = "夕方"
                time_examples = "良い夜を！, 夕飯何食べる？, 今日もお疲れ様！"
            elif 21 <= hour < 24:
                time_context = "夜"
                time_examples = "眠い.., おやすみ！, いい夢見てね～"
            else:  # 0 <= hour < 5
                time_context = "明け方"
                time_examples = "まだ寝てないの？, 遅くなっちゃった.., ぐっすり寝てね！"
            
            # 日付/季節コンテキスト
            date_context = f"{month}月 {day}日"
            special_day = ""
            
            # 特別な日
            if month == 1 and day == 1:
                special_day = "元旦！（あけおめ！、今年もよろしくね～）"
            elif month == 2 and day == 14:
                special_day = "バレンタインデー！（チョコ食べたいな～、ハッピーバレンタイン！）"
            elif month == 3 and day == 14:
                special_day = "ホワイトデー！（飴好き！、甘いな日～）"
            elif month == 3 and day == 1:
                special_day = "ひな祭り！（女の子の日！）"
            elif month == 5 and day == 5:
                special_day = "こどもの日！（プレゼント何？、楽しみ～）"
            elif month == 12 and day == 24:
                special_day = "クリスマスイブ！（明日はクリスマス！、ワクワクする～）"
            elif month == 12 and day == 25:
                special_day = "クリスマス！（メリークリスマス！、サンタ来たかな？）"
            elif month == 12 and day == 31:
                special_day = "大晦日！（今年最後の日！、来年もよろしくね～）"
            elif month == 10 and day == 31:
                special_day = "ハロウィン！（トリックオアトリート！、おばけだぞ～）"
            
            # 季節
            if month in [3, 4, 5]:
                season = "春（いい天気～、お花がきれい）"
            elif month in [6, 7, 8]:
                season = "夏（暑い..、アイス食べたい）"
            elif month in [9, 10, 11]:
                season = "秋（涼しい～、紅葉がきれい）"
            else:
                season = "冬（寒い..、温かいのがいい）"
            
            # 月別特徴
            month_context = ""
            if month == 12:
                month_context = "12月だから年末ムード、クリスマスが楽しみ"
            elif month == 1:
                month_context = "新年だから新しいスタートの雰囲気"
            elif month == 2:
                month_context = "まだ寒い冬"
            
            # 特別な日
            special_context = ""
            if special_day:
                special_context = f"今日は特別な日: {special_day}"
            
            # サンプル セリフで 話し方 分析 (1位) - 制御文字削除
            speech_style = ""
            has_ellipsis_in_samples = False  # 手動セリフに三点リーダーがあるか
            if sample_dialogues:
                valid_samples = [clean_text(d) for d in sample_dialogues if d and d.strip() and d != '（任意）']
                if valid_samples:
                    samples_text = '\n'.join([f'  - "{s}"' for s in valid_samples[:8]])
                    speech_style = f"""
★★★ [最優先 - 話し方参考] ★★★
以下はユーザーが直接入力したこのキャラクターの話し方例です。
必ずこの話し方（語尾、敬語/タメ口、口調、文体）をそのまま合わせてしてください:
{samples_text}

上記 例時の 話し方 特徴を 分析して, 生成する すべての セリフに 同なの 話し方を 適用してください."""
                    # 手動セリフに三点リーダー（'…'または'...'）があるかチェック
                    for sample in valid_samples:
                        if '…' in sample or '...' in sample:
                            has_ellipsis_in_samples = True
                            break
            
            # 三点リーダー制限ルール（手動セリフに三点リーダーがない場合のみ）
            ellipsis_rule = ""
            if not has_ellipsis_in_samples:
                ellipsis_rule = "\n- [重要] 三点リーダー（…）は全セリフ中最大2個まで使用すること（乱用禁止）"
            
            # 相互作用対象情報（呼び方、関係、ストーリー含む）
            interaction_targets = ""
            interaction_prompt_sections = ""
            if cleaned_other_chars:
                targets = []
                sections = []
                for info in cleaned_other_chars[:10]:  # 最大10体までサポート
                    name, nicknames, rel, story = info if len(info) == 4 else (*info, '')
                    target_str = f"{name}(呼び方: {nicknames}, 関係: {rel})"
                    if story:
                        target_str += f" - {story}"
                    targets.append(target_str)
                    # キャラクター別相互作用セリフセクション追加
                    sections.append(f"[{name}]\n{name}への相互作用セリフ 5個 (関係: {rel}, 呼び方: {nicknames}):")
                interaction_targets = "相互作用対象: " + ", ".join(targets)
                interaction_prompt_sections = "\n\n".join(sections)
            
            # ストーリー情報抽出
            story_context = ""
            if cleaned_other_chars:
                stories = []
                for info in cleaned_other_chars[:10]:  # 最大10体までサポート
                    name, nicknames, rel, story = info if len(info) == 4 else (*info, '')
                    if story:
                        stories.append(f"{name}: {story}")
                if stories:
                    story_context = "他のキャラクターとのストーリー:\n" + "\n".join(stories)
            
            # キャラクター背景ストーリー
            bg_story_context = ""
            if background_story_clean:
                bg_story_context = f"キャラクター背景ストーリー: {background_story_clean}"
            
            # 相互作用 セリフ セクション (キャラクター別に 分離)
            interaction_section = ""
            if interaction_prompt_sections:
                interaction_section = f"""
[相互作用]
各キャラクターへの相互作用セリフをキャラクター別に作成してください:

{interaction_prompt_sections}

- 性格が現れる会話
- 呼び方は1～2個のセリフにのみ自然に含める
- ストーリー/関係を反映したセリフ"""
            else:
                interaction_section = """
[相互作用]
他のキャラクターへの相互作用セリフ10個（改行区切り）:
- 性格が現れる会話"""

            # 既存セリフ重複防止用文句生成（セリフが多いほどより多くサンプリング）
            existing_dialogues_text = ""
            if existing_dialogues:
                existing_samples = []
                # 独り言からサンプリング（セリフことに比例、最大25個）
                if existing_dialogues.get('solo'):
                    solo_list = existing_dialogues['solo']
                    solo_count = len(solo_list)
                    # セリフが多いほどより多くサンプリング（100個あたり約8個）
                    sample_count = min(25, max(10, solo_count // 12))
                    # 均等にサンプリング（最初、中間、最新セリフ含む）
                    if solo_count <= sample_count:
                        solo_samples = [clean_text(d) for d in solo_list if d]
                    else:
                        import random
                        # 最新5個は必ず含む
                        recent = solo_list[-5:]
                        # 残りはランダムサンプリング
                        rest = solo_list[:-5]
                        sampled = random.sample(rest, min(sample_count - 5, len(rest)))
                        solo_samples = [clean_text(d) for d in (sampled + recent) if d]
                    existing_samples.extend(solo_samples)
                # 相互作用からキャラクターあたり最大5個ずつ
                if existing_dialogues.get('interaction'):
                    for char_dialogues in existing_dialogues['interaction'].values():
                        if isinstance(char_dialogues, list):
                            interaction_samples = [clean_text(d) for d in char_dialogues[-5:] if d]
                            existing_samples.extend(interaction_samples)
                if existing_samples:
                    # 最大40個まで伝達
                    final_samples = existing_samples[:40]
                    existing_dialogues_text = f"\n[重複禁止] 以下のセリフと同なまたは類似のセリフ（先頭4文字が同じものを含む）は絶対に生成しないでください:\n{', '.join(final_samples)}\n"
                    print(f"[AI] 重複防止用既存セリフ {len(final_samples)}個含む")

            # プロンプト - 性格、ストーリー、基本セリフ含む
            prompt = f"""デスクトップペットキャラクターのセリフを生成してください。

キャラクター: {char_name}
性格: {personality if personality else "親しみやすくてかわいい性格"}
{bg_story_context}
{speech_style}
{interaction_targets}
{story_context}
{existing_dialogues_text}

以下の形式でセリフを生成してください。必ず性格とストーリーを反映してください。

[独り言]
独り言セリフ15個（改行区切り）:
- 性格が 現れる 独り言, 感嘆詞
- ストーリーがあればストーリーを反映したセリフ
- 例: "暇だな。", "何しようかな…", "今日も平和だね。"
- 時間/天気/季節/曜日への言及禁止
{interaction_section}

ルール:
★ [最優先] 上に提示された参考セリフの話し方を必ず合わせてすること! 語尾(-です, -だ, -ます, -かな 等), 敬語/タメ口, 口調を同じように使用!
★ [最優先] 参考セリフがタメ口ならタメ口で, 敬語なら敬語で, 特別な語尾があればその語尾を使用!
- [絶対禁止] 絵文字, 特殊文字絵文字(😀💕🎵 等) 絶対使用禁止
- [絶対禁止] 笑, www, 草 等ネットスラング使用禁止
- 各 セリフ 15字以内
- 自然な 口語体, 正しい スペース
- すべての セリフ 終わりに 句点(.) または 感嘆符(!) または 疑問符(?) 付ける
- 性格と 背景 ストーリーを よく 反映すること
- 呼び方は 適切な 頻度でのみ 使用 (毎回 呼ばないこと)
- 番号を付けないこと
- セリフのみ 作成 (説明 禁止)
- 三点リーダーは 必ず '…' または …で 作成 ('..' 使用 禁止){ellipsis_rule}
- 日本語と 基本 句読点(.,!?)のみ 使用"""

            # API キーから 制御文字削除 (安全 措置)
            cleaned_key = clean_api_key(_gemini_api_key)
            if not cleaned_key:
                print("[AI] APIキーが空です。")
                callback([], {}, [])
                return
            
            if len(cleaned_key) != 39:
                print(f"[AI] APIキー長さエラー: {len(cleaned_key)}文字（39文字必要）")
                callback([], {}, [])
                return
            
            url = make_safe_url(f"https://generativelanguage.googleapis.com/v1beta/models/{get_gemini_model()}:generateContent", cleaned_key)
            print(f"[AI] URL生成完了（モデル: {get_gemini_model()}, キー長さ: {len(cleaned_key)})")
            
            data = {
                "contents": [{"parts": [{"text": prompt}]}],
                "generationConfig": {
                    "temperature": 0.9,
                    "maxOutputTokens": 8192
                }
            }
            
            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode('utf-8'),
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            
            with urllib.request.urlopen(req, timeout=30, context=_ssl_context) as response:
                result = json.loads(response.read().decode('utf-8'))
            
            # デバッグ: レスポンス 構造 出力
            print(f"[AI] レスポンスキー: {result.keys()}")
            
            if 'candidates' in result and result['candidates']:
                candidate = result['candidates'][0]
                print(f"[AI] candidateキー: {candidate.keys()}")
                
                # テキスト 抽出 (複数の 形式 サポート)
                text = ""
                if 'content' in candidate:
                    content = candidate['content']
                    if 'parts' in content and content['parts']:
                        text = content['parts'][0].get('text', '')
                    elif 'text' in content:
                        text = content['text']
                elif 'text' in candidate:
                    text = candidate['text']
                elif 'output' in candidate:
                    text = candidate['output']
                
                if not text:
                    print(f"[AI] テキスト抽出失敗。candidate内容: {str(candidate)[:300]}")
                    callback([], {}, [])
                    return
                
                print(f"[AI] レスポンステキスト長さ: {len(text)}")
                
                # キャラクター 名前 リスト 抽出 (cleaned_other_charsから 取得しなければ AI レスポンスと マッチする)
                char_names_list = [info[0] for info in cleaned_other_chars] if cleaned_other_chars else []
                print(f"[AI] 相互作用対象キャラクターリスト: {char_names_list}")
                
                # パース
                solo_dialogues = []
                interaction_dialogues = {}  # {キャラクター名前: [セリフたち]}
                
                current_section = None
                current_char_name = None
                
                for line in text.split('\n'):
                    line = line.strip()
                    if not line:
                        continue
                    
                    # セクション 検出
                    if '[独り言]' in line or '独り' in line and ('つぶやき' in line or 'セリフ' in line):
                        current_section = 'solo'
                        current_char_name = None
                        continue
                    elif '[相互作用]' in line:
                        current_section = 'interaction'
                        current_char_name = None
                        continue
                    elif '[基本]' in line:
                        current_section = 'solo'
                        current_char_name = None
                        continue
                    elif '[' in line and ']' in line:
                        # キャラクター 名前 セクションかどうか 確認
                        bracket_content = line.split('[')[1].split(']')[0].strip()
                        
                        # 正確に マッチされる 名前 探す
                        matched_name = None
                        for char_name in char_names_list:
                            if bracket_content == char_name:
                                matched_name = char_name
                                break
                            # 部分マッチ試行 (名前が含まれていれば)
                            if char_name in bracket_content or bracket_content in char_name:
                                matched_name = char_name
                                break
                        
                        if matched_name:
                            current_section = 'char_interaction'
                            current_char_name = matched_name
                            if current_char_name not in interaction_dialogues:
                                interaction_dialogues[current_char_name] = []
                            print(f"[AI] キャラクターセクション検出: {matched_name}")
                            continue
                        else:
                            # 他の セクションは 無視
                            current_section = None
                            current_char_name = None
                            continue
                    
                    # "キャラクター名へ" または "キャラクター名:" 形式検出
                    for char_name in char_names_list:
                        if line.startswith(f"{char_name}へ") or line.startswith(f"{char_name}:") or f"## {char_name}" in line:
                            current_section = 'char_interaction'
                            current_char_name = char_name
                            if current_char_name not in interaction_dialogues:
                                interaction_dialogues[current_char_name] = []
                            print(f"[AI] キャラクターセクション検出（代替形式）: {char_name}")
                            continue
                    
                    # セリフ 整理
                    dialogue = line.strip('- ').strip('"\'').strip()
                    # 数字で 始まる 場合 削除 (1. 2. 等)
                    if dialogue and dialogue[0].isdigit() and '.' in dialogue[:3]:
                        dialogue = dialogue.split('.', 1)[-1].strip()
                    
                    # メタ情報パターン削除（関係:, 呼び方:等）
                    dialogue = re.sub(r'\(関係:\s*[^,)]+,\s*呼び方:\s*[^)]+\)', '', dialogue)
                    dialogue = re.sub(r'\(呼び方:\s*[^,)]+,\s*関係:\s*[^)]+\)', '', dialogue)
                    dialogue = re.sub(r'\[関係:\s*[^\]]+\]', '', dialogue)
                    dialogue = re.sub(r'\[呼び方:\s*[^\]]+\]', '', dialogue)
                    dialogue = dialogue.strip()
                    
                    # 笑, www 等フィルタリング
                    if dialogue in ['笑', 'www', 'ww', '草', '笑笑']:
                        continue
                    
                    # 絵文字/絵文字 フィルタリング (ユニコード 範囲 チェック)
                    has_emoji = False
                    for char in dialogue:
                        code = ord(char)
                        # 絵文字 ユニコード 範囲
                        if (0x1F300 <= code <= 0x1F9FF or  # 様々な シンボル
                            0x2600 <= code <= 0x26FF or    # 記号
                            0x2700 <= code <= 0x27BF or    # ディングバット
                            0x1F600 <= code <= 0x1F64F or  # 絵文字
                            0x1F680 <= code <= 0x1F6FF):   # 交通/地図
                            has_emoji = True
                            break
                    if has_emoji:
                        continue
                    
                    if dialogue and len(dialogue) <= 20 and current_section:
                        if current_section == 'solo':
                            solo_dialogues.append(dialogue)
                        elif current_section == 'interaction':
                            # な般 相互作用は 'default'に 保存
                            if 'default' not in interaction_dialogues:
                                interaction_dialogues['default'] = []
                            interaction_dialogues['default'].append(dialogue)
                        elif current_section == 'char_interaction' and current_char_name:
                            interaction_dialogues[current_char_name].append(dialogue)
                
                total_interaction = sum(len(d) for d in interaction_dialogues.values())
                interaction_detail = {k: len(v) for k, v in interaction_dialogues.items()}
                print(f"[AI] {char_name} セリフ生成完了: ソロ {len(solo_dialogues)}個、相互作用 {total_interaction}個")
                print(f"[AI] 相互作用詳細: {interaction_detail}")
                callback(solo_dialogues, interaction_dialogues, [])
            else:
                print(f"[AI] レスポンスにcandidatesなし: {str(result)[:300]}")
                callback([], {}, [], True)  # エラー フラグ
                
        except urllib.error.HTTPError as e:
            error_body = e.read().decode('utf-8') if e.fp else ""
            print(f"[AI] HTTPエラー {e.code}: {e.reason}")
            print(f"[AI] 詳細: {error_body[:200]}")
            
            # 429 エラー 時 リトライ
            if e.code == 429 and retry_count < 2:
                wait_time = 120  # 2分 待機
                print(f"[AI] 429 エラー - {wait_time}秒後リトライ ({retry_count + 1}/2)")
                import time as time_module
                time_module.sleep(wait_time)
                # 再帰 呼び出しで リトライ
                generate_dialogues_batch(char_name_orig, personality_orig, sample_dialogues, other_chars_info, callback, background_story, retry_count + 1, existing_dialogues)
                return
            
            # エラー 発生 時 _error フラグと とともに 空の データ 伝達 (既存 キャッシュ 保存)
            callback([], {}, [], True)  # 4番目の引こと: is_error
        except ValueError as e:
            # URL 関連 エラー 詳細 出力
            print(f"[AI] ValueError - URLまたはデータエラー: {e}")
            print(f"[AI] APIキー長さ: {len(cleaned_key) if cleaned_key else 0}")
            print(f"[AI] キャラクター名: '{char_name}' （長さ: {len(char_name)})")
            # 制御 文字 確認
            for i, c in enumerate(cleaned_key or ""):
                if ord(c) < 32 or ord(c) > 126:
                    print(f"[AI] APIキー異常文字発見: 位置 {i}, コード {ord(c)}")
            callback([], {}, [], True)  # エラー フラグ
        except Exception as e:
            print(f"[AI] セリフ生成失敗: {type(e).__name__}: {e}")
            import traceback
            print(f"[AI] スタックトレース:\n{traceback.format_exc()}")
            callback([], {}, [], True)  # エラー フラグ
    
    # 非同期 実行
    thread = threading.Thread(target=api_call, daemon=True)
    thread.start()

def generate_time_weather_dialogue(char_id, char_name, personality, current_time, weather_info=None, callback=None):
    """時間/季節 ベース セリフ生成 (な時キャッシュに保存)
    
    - 時間 セリフ: 削除 しない, 同じ 時間帯にのみ 出力
    - 日付 セリフ: 日付が 変わると 削除
    - 月別 季節/気温 情報を 自動的に 推測して プロンプトに 含む
    """
    if not _gemini_api_key or not personality:
        if callback:
            callback(None)
        return
    
    # 現在 時間帯 取得する
    hour = current_time.hour
    current_period = get_time_period(hour)
    
    # 月別 季節 情報 取得
    month = current_time.month
    season_name, season_desc = get_season_info(month)
    
    def api_call():
        try:
            import re
            # 制御文字削除
            clean_char_name = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', str(char_name)) if char_name else ''
            clean_personality = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', str(personality)) if personality else ''
            
            # 時間 情報 (6段階)
            if 0 <= hour < 6:
                time_desc = "明け方"
            elif 6 <= hour < 12:
                time_desc = "朝"
            elif 12 <= hour < 15:
                time_desc = "昼"
            elif 15 <= hour < 18:
                time_desc = "夕方"
            elif 18 <= hour < 21:
                time_desc = "夕方"
            else:  # 21 <= hour < 24
                time_desc = "夜"
            
            weekday = ["月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日", "日曜日"][current_time.weekday()]
            date_str = current_time.strftime("%m月 %d日")
            
            # 日付 関連 キーワード チェック (月曜日, 金曜日, 特別な 日 等)
            is_date_specific = weekday in ["月曜日", "金曜日", "土曜日", "日曜日"]
            
            prompt = f"""キャラクター: {clean_char_name}
性格: {clean_personality}

現在 時間: {time_desc} ({weekday}, {date_str})
季節: {season_name} ({season_desc})

が キャラクターが 現在 時間/季節/曜日に ふさわしい 短い 独り言 1個のみ 生成してください.
15文字以内で作成してください。絵文字は使用しないでください。"""

            data = {
                "contents": [{"parts": [{"text": prompt}]}],
                "generationConfig": {
                    "temperature": 0.9,
                    "maxOutputTokens": 50,
                    "topP": 0.95
                }
            }
            
            # API キーから 制御文字削除 (安全 措置)
            cleaned_key = clean_api_key(_gemini_api_key)
            if not cleaned_key or len(cleaned_key) != 39:
                print(f"[AI] APIキーエラー: 長さ {len(cleaned_key) if cleaned_key else 0}")
                if callback:
                    callback(None)
                return
            
            url = make_safe_url(f"https://generativelanguage.googleapis.com/v1beta/models/{get_gemini_model()}:generateContent", cleaned_key)

            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode('utf-8'),
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            
            with urllib.request.urlopen(req, timeout=15, context=_ssl_context) as response:
                result = json.loads(response.read().decode('utf-8'))
            
            if 'candidates' in result and result['candidates']:
                text = result['candidates'][0]['content']['parts'][0]['text']
                dialogue = text.strip().strip('"').strip("'").strip()
                
                # な時キャッシュに保存
                if is_date_specific:
                    # 日付セリフ (日付 変わると 削除)
                    add_temp_dialogue(char_id, 'date', dialogue)
                else:
                    # 時間 セリフ (時間帯別に 保存, 削除 しない)
                    add_temp_dialogue(char_id, 'time', dialogue, current_period)
                
                if callback:
                    callback(dialogue)
            else:
                if callback:
                    callback(None)
                    
        except urllib.error.HTTPError as e:
            # 429 エラー 等は 静かに 失敗
            print(f"[AI] 時間/季節セリフ生成失敗（HTTP {e.code})")
            if callback:
                callback(None)
        except Exception as e:
            print(f"[AI] 時間/季節セリフ生成失敗: {e}")
            if callback:
                callback(None)
    
    # 非同期 実行
    thread = threading.Thread(target=api_call, daemon=True)
    thread.start()

def update_character_cache(char_id, char_name, personality, sample_dialogues, other_chars_info, background_story=""):
    """キャラクターのセリフキャッシュ更新（既存セリフに追加）"""
    global _ai_dialogues_cache

    # 既存 セリフ 取得 (重複 防止用)
    existing = None
    if char_id in _ai_dialogues_cache:
        existing = _ai_dialogues_cache[char_id]

    def on_generated(solo, interaction, fallback):
        global _ai_dialogues_cache
        if char_id in _ai_dialogues_cache:
            # 既存 キャッシュが いれば 追加 (重複 削除)
            cache = _ai_dialogues_cache[char_id]
            for d in solo:
                if d and d.strip() and d not in cache['solo']:
                    cache['solo'].append(d)
            for d in fallback:
                if d and d.strip() and d not in cache['fallback']:
                    cache['fallback'].append(d)
            if 'interaction' not in cache:
                cache['interaction'] = {}
            # interactionが 辞書の 場合 各 キー別に 追加 (重複 削除)
            if isinstance(interaction, dict):
                for key, dialogues in interaction.items():
                    if key not in cache['interaction']:
                        cache['interaction'][key] = []
                    for d in dialogues:
                        if d and d.strip() and d not in cache['interaction'][key]:
                            cache['interaction'][key].append(d)
            cache['generated_at'] = time.time()
            print(f"[AI] {char_name} キャッシュにセリフ追加（solo +{len(solo)})")
        else:
            # 新しく生成
            _ai_dialogues_cache[char_id] = {
                'solo': solo,
                'interaction': interaction if isinstance(interaction, dict) else {'default': interaction},
                'fallback': fallback,
                'reference': {},  # 参考用手動セリフ
                'generated_at': time.time()
            }
            print(f"[AI] {char_name} キャッシュ新規生成")

    generate_dialogues_batch(char_name, personality, sample_dialogues, other_chars_info, on_generated, background_story, 0, existing)

def clear_dialogue_cache():
    """セリフキャッシュ全削除"""
    global _ai_dialogues_cache
    _ai_dialogues_cache = {}
    print("[AI] セリフキャッシュ初期化")


class CharacterWidget(QWidget):
    collision_detected = pyqtSignal(object)
    
    def __init__(self, image_path, char_id, facing_direction='front', scale=100, bubble_color='#81C784', bubble_size=100):
        super().__init__()
        self.char_id = char_id
        self.image_path = image_path
        self.initial_facing = facing_direction
        self.scale = scale
        self.bubble_color = QColor(bubble_color)
        self.bubble_size = bubble_size  # 吹き出しサイズ (%)
        self.relationships = {}  # {other_char_id: relationship_type}
        self.dialogues = {'基本': []}  # {'基本': [...], 'char_0': [...]}
        self.personality = ""  # キャラクター 性格 説明
        self.background_story = ""  # キャラクター背景ストーリー （任意）
        self.nicknames = {}  # {other_char_id: "呼び方"} - 他のキャラクターを呼ぶ呼び方
        self.stories = {}  # {other_char_id: "ストーリー"} - 他のキャラクターとのストーリー
        self.ai_auto_generate = True  # AI セリフ 自動生成 有効化 可否
        self.char_name = f"キャラクター {char_id + 1}"  # キャラクター 名前
        self.catchphrase = ""  # キャラクター キャッチフレーズ
        self.sample_dialogues = []  # サンプル セリフ リスト
        self.generating_status = ""  # セリフ生成 中 表示
        self.is_previewing_bubble = False  # 吹き出し プレビュー 中かどうか
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        # 透明 領域からも マウス イベント 受け取る
        self.setAttribute(Qt.WA_TransparentForMouseEvents, False)
        
        # ドラッグ 関連
        self.dragging = False
        self.drag_start_pos = None
        self.drag_start_widget_pos = None
        self.was_clicked = False
        
        # 時間 ベース 状態
        self.is_sleepy = False
        self.time_dialogue_timer = 0
        self.check_time_status()
        
        # GIF サポート
        self.is_gif = image_path.lower().endswith('.gif')
        self.gif_movie = None
        
        # 画像 読み込み
        try:
            if self.is_gif:
                # GIF ファイル 場合 QMovie 使用
                self.gif_movie = QMovie(image_path)
                if self.gif_movie.isValid():
                    self.gif_movie.setCacheMode(QMovie.CacheAll)
                    # シグナル まず 接続
                    self.gif_movie.frameChanged.connect(self.on_gif_frame_changed)
                    # アニメーション 開始
                    self.gif_movie.start()
                    # 最初のフレーム 取得 (start 後に)
                    self.original_pixmap = self.gif_movie.currentPixmap()
                    # pixmapが 有効でなければ な般 画像で 読み込み 試行
                    if self.original_pixmap.isNull():
                        print(f"[GIF] 最初のフレーム読み込み失敗、通常画像として試行: {image_path}")
                        self.original_pixmap = QPixmap(image_path)
                        self.is_gif = False
                        self.gif_movie.stop()
                        self.gif_movie = None
                    else:
                        print(f"[GIF] 読み込み成功: {image_path}, フレームこと: {self.gif_movie.frameCount()}, 状態: {self.gif_movie.state()}")
                else:
                    print(f"[GIF] 無効なGIF、通常画像として試行: {image_path}")
                    self.original_pixmap = QPixmap(image_path)
                    self.is_gif = False
                    self.gif_movie = None
            else:
                self.original_pixmap = QPixmap(image_path)
            
            # pixmapが 依然として 有効でなければ 基本 画像 生成
            if self.original_pixmap.isNull():
                print(f"[画像] 読み込み失敗、デフォルト画像生成: {image_path}")
                self.original_pixmap = QPixmap(100, 100)
                self.original_pixmap.fill(QColor(200, 200, 200))
        except Exception as e:
            print(f"[画像] 読み込みエラー: {e}")
            self.original_pixmap = QPixmap(100, 100)
            self.original_pixmap.fill(QColor(200, 200, 200))
            self.is_gif = False
            self.gif_movie = None
        
        self.size = int(100 * (scale / 100))
        self.pixmap = self.original_pixmap.scaled(self.size, self.size, 
                                                   Qt.KeepAspectRatio, 
                                                   Qt.SmoothTransformation)
        
        # 透明 領域 分析して 足の位置 計算
        self.foot_offset = self.calculate_foot_offset(self.pixmap)
        # 透明 領域 分析して 頭の位置 計算
        self.head_offset = self.calculate_head_offset(self.pixmap)
        
        # 最初の方向に 合わせて 画像 設定
        if self.initial_facing == 'right':
            self.pixmap_left = self.pixmap.transformed(QTransform().scale(-1, 1))
            self.pixmap_right = self.pixmap
        elif self.initial_facing == 'left':
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap.transformed(QTransform().scale(-1, 1))
        else:  # 'front'
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap
        
        self.setFixedSize(self.size + 120, self.size + 150)  # 高く 追加で 吹き出し + ジャンプスケール 空間 確保
        
        # 移動 関連変数
        self.velocity_x = random.choice([-2, -1.5, 1.5, 2])
        self.velocity_y = 0
        self.gravity = 0.8
        self.max_fall_speed = 15  # 最大 落下 速度
        self.is_jumping = False
        self.on_ground = True
        self.facing_right = self.velocity_x > 0
        
        # ジャンプ 関連
        self.jump_power = random.uniform(-8, -10)
        self.jump_cooldown = 0
        
        # ジャンプスケール アニメーション
        self.jump_scale = 1.0  # 現在 スケール (1.0 = 100%)
        self.jump_scale_target = 1.0  # 目標スケール
        
        # 停止/歩き 状態
        self.is_moving = True
        self.state_timer = random.randint(60, 180)
        
        # 相互作用 関連
        self.speech_bubble = None
        self.bubble_timer = 0
        self.interaction_cooldown = 0
        
        # 長い イベント 関連
        self.in_event = False
        self.event_type = None
        self.event_partner = None
        self.event_frame = 0
        self.event_duration = 0
        self.event_data = {}  # イベント別 追加 データ
        
        # 画面 情報 (作業 バー 除く 使用可能 領域)
        screen = QApplication.desktop().availableGeometry()
        self.screen_geometry = screen  # モニター選択用
        self.screen_width = screen.width()
        self.screen_height = screen.height()
        self.screen_x = screen.x()  # モニター 開始 X 座標 (マルチモニター用)
        self.screen_y = screen.y()  # モニター 開始 Y 座標 (マルチモニター用)
        
        # foot_offset 制限 (キャラクター 高くの 1/2 以下で)
        max_foot_offset = self.pixmap.height() // 2
        self.foot_offset = min(self.foot_offset, max_foot_offset)
        
        # ground_level 計算 - ウィジェット 下部が 画面 下部(作業バー 上記)に ぴったり付くように
        # キャラクター 画像は ウィジェット下部に 描かれるので, ウィジェット y = screen_bottom - widget_height
        self.ground_level = self.screen_y + self.screen_height - self.height()
        
        # ウィンドウ上に あるか チェック
        self.on_window = False
        self.window_top = 0
        
        # 開始 位置 (床)
        start_x = self.screen_x + random.randint(0, max(0, self.screen_width - self.width()))
        self.move(start_x, self.ground_level)
        
        # 移動 タイマー
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_position)
        self.timer.start(30)
        
        self.show()
    
    def calculate_foot_offset(self, pixmap):
        """画像の透明領域を分析して足の位置（下部余白）を計算"""
        if pixmap.isNull():
            return 0
        
        # QPixmapを QImageで 変換
        image = pixmap.toImage()
        width = image.width()
        height = image.height()
        
        # 以下から 上で スキャンして 不透明ピクセルが ある 最後 行を探す
        last_opaque_row = height - 1
        
        for y in range(height - 1, -1, -1):
            has_opaque = False
            for x in range(width):
                # アルファ値 確認 (0=透明, 255=不透明)
                pixel = image.pixel(x, y)
                alpha = (pixel >> 24) & 0xFF
                if alpha > 10:  # ほとんど 透明で ない ピクセル
                    has_opaque = True
                    break
            if has_opaque:
                last_opaque_row = y
                break
        
        # 足の位置 = 画像 高く - 最後の不透明 行 - 1
        foot_offset = height - last_opaque_row - 1
        
        print(f"[透明度分析] 画像高く: {height}, 最後の不透明行: {last_opaque_row}, foot_offset: {foot_offset}")
        
        return foot_offset
    
    def calculate_head_offset(self, pixmap):
        """画像の上部透明領域を分析して頭の位置（上部余白）を計算"""
        if pixmap.isNull():
            return 0
        
        # QPixmapを QImageで 変換
        image = pixmap.toImage()
        width = image.width()
        height = image.height()
        
        # 上記から 以下で スキャンして 不透明ピクセルが ある 最初の行を探す
        first_opaque_row = 0
        
        for y in range(height):
            has_opaque = False
            for x in range(width):
                pixel = image.pixel(x, y)
                alpha = (pixel >> 24) & 0xFF
                if alpha > 10:
                    has_opaque = True
                    break
            if has_opaque:
                first_opaque_row = y
                break
        
        print(f"[透明度分析] 最初の不透明行: {first_opaque_row}, head_offset: {first_opaque_row}")
        
        return first_opaque_row
    
    def get_current_ground_level(self, x=None):
        """現在のキャラクター位置に該当するモニターのground_levelを動的に計算"""
        if x is None:
            x = self.x()
        
        # 全体 モニター モードが でなければ 既存 ground_level 使用
        if not getattr(self, 'use_all_monitors', False):
            return self.ground_level
        
        # 現在 位置が どの モニターに あるか 探す
        desktop = QApplication.desktop()
        char_center_x = x + self.width() // 2
        
        for i in range(desktop.screenCount()):
            screen_geo = desktop.screenGeometry(i)
            if screen_geo.x() <= char_center_x < screen_geo.x() + screen_geo.width():
                # が モニターの availableGeometry (作業バー 除外)
                available_geo = desktop.availableGeometry(i)
                # が モニターの ground_level 計算
                monitor_ground = available_geo.y() + available_geo.height() - self.height()
                return monitor_ground
        
        # できなかったら 見つけたら 基本 ground_level 返す
        return self.ground_level
    
    def show_dialogue(self, text, duration=180):
        """吹き出し表示"""
        self.speech_bubble = text
        self.bubble_timer = duration
        self.update()
    
    def hide_dialogue(self):
        """吹き出し非表示"""
        self.speech_bubble = None
        self.bubble_timer = 0
        self.update()
    
    def update_scale(self, new_scale):
        """サイズ更新"""
        self.scale = new_scale
        old_size = self.size
        self.size = int(100 * (new_scale / 100))
        
        # GIFである 場合 現在 フレーム 基準として, でない 場合 original_pixmap 基準
        if self.is_gif and self.gif_movie:
            current_pixmap = self.gif_movie.currentPixmap()
            if not current_pixmap.isNull():
                self.pixmap = current_pixmap.scaled(self.size, self.size, 
                                                     Qt.KeepAspectRatio, 
                                                     Qt.SmoothTransformation)
            else:
                self.pixmap = self.original_pixmap.scaled(self.size, self.size, 
                                                           Qt.KeepAspectRatio, 
                                                           Qt.SmoothTransformation)
        else:
            self.pixmap = self.original_pixmap.scaled(self.size, self.size, 
                                                       Qt.KeepAspectRatio, 
                                                       Qt.SmoothTransformation)
        
        # 透明 領域 再度 分析
        self.foot_offset = self.calculate_foot_offset(self.pixmap)
        self.head_offset = self.calculate_head_offset(self.pixmap)
        
        if self.initial_facing == 'right':
            self.pixmap_left = self.pixmap.transformed(QTransform().scale(-1, 1))
            self.pixmap_right = self.pixmap
        elif self.initial_facing == 'left':
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap.transformed(QTransform().scale(-1, 1))
        else:
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap
        
        self.setFixedSize(self.size + 120, self.size + 150)  # 高く 追加で 吹き出し + ジャンプスケール 空間 確保
        
        # foot_offset 制限 (キャラクター 高くの 1/2 以下で)
        max_foot_offset = self.pixmap.height() // 2
        self.foot_offset = min(self.foot_offset, max_foot_offset)
        
        # foot_offset 制限 および ground_level 計算
        screen_y = getattr(self, 'screen_y', 0)
        # ウィジェット 下部が 画面 下部(作業バー 上記)に ぴったり付くように
        self.ground_level = screen_y + self.screen_height - self.height()
        
        # 現在 y 位置が ground_level 以下で 下がったら ground_levelで 再調整
        current_y = self.y()
        if current_y > self.ground_level:
            self.move(self.x(), self.ground_level)
        
        self.update()
    
    def on_gif_frame_changed(self, frame_number):
        """GIFフレーム変更時に呼び出し"""
        try:
            if self.gif_movie and self.is_gif:
                current_pixmap = self.gif_movie.currentPixmap()
                if not current_pixmap.isNull():
                    # 現在 サイズで スケール
                    self.pixmap = current_pixmap.scaled(self.size, self.size, 
                                                        Qt.KeepAspectRatio, 
                                                        Qt.SmoothTransformation)
                    # 方向に 合わせて pixmap アップデート
                    if self.initial_facing == 'right':
                        self.pixmap_left = self.pixmap.transformed(QTransform().scale(-1, 1))
                        self.pixmap_right = self.pixmap
                    elif self.initial_facing == 'left':
                        self.pixmap_left = self.pixmap
                        self.pixmap_right = self.pixmap.transformed(QTransform().scale(-1, 1))
                    else:
                        self.pixmap_left = self.pixmap
                        self.pixmap_right = self.pixmap
                    self.update()
        except Exception as e:
            print(f"[GIF] フレーム更新エラー: {e}")
    
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setRenderHint(QPainter.SmoothPixmapTransform)
            
            # pixmap_rightが なければ リターン
            if not hasattr(self, 'pixmap_right') or self.pixmap_right is None:
                return
            
            # キャラクター 描画 - ウィジェット下部に 配置 (吹き出し 空間は 上に)
            char_x = 60
            # キャラクターを ウィジェット下部に 正確に 合わせる + foot_offset 適用 (透明 領域のみほど下で)
            foot_offset = getattr(self, 'foot_offset', 0)
            char_y = self.height() - self.pixmap_right.height() + foot_offset
            
            # 描く Pixmap 選択
            if self.initial_facing == 'front':
                current_pixmap = self.pixmap_right
            else:
                if getattr(self, 'facing_right', True):
                    current_pixmap = self.pixmap_right
                else:
                    current_pixmap = getattr(self, 'pixmap_left', self.pixmap_right)
            
            # 吹き出し 描画 (キャラクター 描画 前に まず - キャラクター 頭 上に)
            if self.speech_bubble and self.bubble_timer > 0:
                self.draw_speech_bubble(painter, char_x, char_y, current_pixmap.width())
            
            # キャラクター 描画 (スケール なく シンプルして)
            painter.drawPixmap(char_x, char_y, current_pixmap)
            
            # AI セリフ生成 中 表示
            if getattr(self, 'generating_status', ''):
                self.draw_generating_status(painter, char_y)
        except Exception as e:
            # エラー 時 基本 描画 試行
            try:
                if hasattr(self, 'pixmap_right') and self.pixmap_right:
                    painter = QPainter(self)
                    painter.drawPixmap(60, 10, self.pixmap_right)
            except:
                pass
    
    def draw_generating_status(self, painter, char_y):
        """AIセリフ生成中状態表示（薄い文字）"""
        if not hasattr(self, 'pixmap_right') or self.pixmap_right is None:
            return
        
        painter.save()
        
        font = QFont(KOREAN_FONT, 8)
        font.setWeight(QFont.Bold)
        painter.setFont(font)
        
        # 柔らかい 灰色
        painter.setPen(QColor(150, 150, 150, 180))
        
        # キャラクターので 下に 表示
        text = self.generating_status
        metrics = painter.fontMetrics()
        text_width = metrics.horizontalAdvance(text)
        
        # キャラクター 画像 位置 基準
        char_x = 60
        char_height = self.pixmap_right.height()
        
        x = char_x + self.pixmap_right.width() // 2 - text_width // 2
        y = char_y + char_height + 12  # キャラクターので 以下
        
        painter.drawText(x, y, text)
        painter.restore()
    
    def draw_speech_bubble(self, painter, char_x, char_y, char_width):
        """吹き出し描画 - キャラクター頭上中央から上に拡張"""
        # painter 状態 保存
        painter.save()
        
        # 吹き出しサイズ スケール 適用
        size_scale = self.bubble_size / 100.0
        
        # 絵文字かどうか チェック - ハングル/英文が なく 長さが 短い 場合のみ
        def has_text(s):
            for c in s:
                if '\uAC00' <= c <= '\uD7A3':  # ハングル
                    return True
                if 'a' <= c.lower() <= 'z':  # 英文
                    return True
            return False
        
        is_emoji = len(self.speech_bubble) <= 2 and not has_text(self.speech_bubble)
        
        # テキスト サイズ - サイズ スケール 適用
        base_font_size = 12 if is_emoji else 10
        scaled_font_size = max(8, int(base_font_size * size_scale))
        
        font = QFont(KOREAN_FONT, scaled_font_size)
        # 絵文字は Medium, テキストは Bold
        if is_emoji:
            font.setWeight(QFont.Medium)
        else:
            font.setWeight(QFont.Bold)
        painter.setFont(font)
        metrics = painter.fontMetrics()
        
        # 最大 幅 設定 (長い テキスト 改行用) - スケール 適用
        max_bubble_width = int(160 * size_scale)
        
        # テキスト 改行 処理
        text = self.speech_bubble
        text_width = metrics.horizontalAdvance(text)
        
        # パディング スケール 適用
        base_padding_x = 6 if is_emoji else 12
        base_padding_y = 4 if is_emoji else 8
        padding_x = int(base_padding_x * size_scale)
        padding_y = int(base_padding_y * size_scale)
        
        lines = []
        if text_width > max_bubble_width - padding_x * 2:
            # 単語単位で 改行 (スペース 基準)
            words = text.split(' ')
            current_line = ""
            
            for word in words:
                if not current_line:
                    test_line = word
                else:
                    test_line = current_line + ' ' + word
                
                if metrics.horizontalAdvance(test_line) > max_bubble_width - padding_x * 2:
                    # 現在の行が いれば 保存
                    if current_line:
                        lines.append(current_line)
                        current_line = word
                    else:
                        # 単語が あまりに 長ければ 文字 単位で 分ける
                        for char in word:
                            test_char = current_line + char
                            if metrics.horizontalAdvance(test_char) > max_bubble_width - padding_x * 2:
                                if current_line:
                                    lines.append(current_line)
                                current_line = char
                            else:
                                current_line = test_char
                else:
                    current_line = test_line
            
            if current_line:
                lines.append(current_line)
        else:
            lines = [text]
        
        # 最も長い 行の幅 計算
        max_line_width = max(metrics.horizontalAdvance(line) for line in lines)
        text_height = metrics.height()
        total_text_height = text_height * len(lines)
        
        # 吹き出しサイズ 計算
        bubble_width = max_line_width + padding_x * 2
        bubble_height = total_text_height + padding_y * 2
        
        # 尻尾 サイズ
        tail_size = int(6 * size_scale)
        tail_height = int(8 * size_scale)
        
        # 吹き出し 位置 - キャラクター 中央 上に 配置
        char_center_x = char_x + char_width // 2
        bubble_x = char_center_x - bubble_width // 2
        
        # head_offsetを 適用して 実際 キャラクター 頭ので 上に 吹き出し 配置
        head_offset = getattr(self, 'head_offset', 0)
        actual_head_y = char_y + head_offset  # 実際 キャラクター 頭の位置
        
        bubble_bottom = actual_head_y - tail_height - 2  # キャラクター 頭 上記 (尻尾 空間 確保)
        bubble_y = bubble_bottom - bubble_height  # 上で 拡張
        
        # 吹き出しが ウィジェット 領域を 外れ ないように 調整
        if bubble_y < 2:
            bubble_y = 2
            bubble_bottom = bubble_y + bubble_height
        if bubble_x < 2:
            bubble_x = 2
        if bubble_x + bubble_width > self.width() - 2:
            bubble_x = self.width() - bubble_width - 2
        
        # 色 - より 濃く
        base_color = self.bubble_color
        h, s, v, a = base_color.getHsv()
        darker_color = QColor.fromHsv(h, min(255, s + 40), max(0, v - 50))
        
        # 全体 吹き出し パス (ラウンド 四角形 + 下側 尻尾)
        full_path = QPainterPath()
        
        # ラウンド 四角形 開始 - スケール 適用
        radius = int(8 * size_scale)
        
        # 上部 左から時計方向として 描画
        full_path.moveTo(bubble_x + radius, bubble_y)
        
        # 上部 ラウンド
        full_path.lineTo(bubble_x + bubble_width - radius, bubble_y)
        full_path.arcTo(bubble_x + bubble_width - radius * 2, bubble_y, 
                       radius * 2, radius * 2, 90, -90)
        
        # 右 ラウンド
        full_path.lineTo(bubble_x + bubble_width, bubble_bottom - radius)
        full_path.arcTo(bubble_x + bubble_width - radius * 2, 
                       bubble_bottom - radius * 2, 
                       radius * 2, radius * 2, 0, -90)
        
        # 下部 ラウンド (尻尾 直前まで) - 尻尾が 下側(キャラクター 側)を 向く
        tail_center_x = bubble_x + bubble_width // 2
        
        full_path.lineTo(tail_center_x + tail_size, bubble_bottom)
        
        # 尻尾 三角形 (下側に)
        full_path.lineTo(tail_center_x, bubble_bottom + tail_height)
        full_path.lineTo(tail_center_x - tail_size, bubble_bottom)
        
        # 下部 ラウンド 続ける
        full_path.lineTo(bubble_x + radius, bubble_bottom)
        full_path.arcTo(bubble_x, bubble_bottom - radius * 2,
                       radius * 2, radius * 2, 270, -90)
        
        # 左 ラウンド
        full_path.lineTo(bubble_x, bubble_y + radius)
        full_path.arcTo(bubble_x, bubble_y, radius * 2, radius * 2, 180, -90)
        
        full_path.closeSubpath()
        
        # 吹き出し 描画 - ボーダー にも スケール 適用
        border_width = max(1.5, 2.5 * size_scale)
        painter.setBrush(QColor(255, 255, 255, 240))
        painter.setPen(QPen(darker_color, border_width))
        painter.drawPath(full_path)
        
        # テキスト (濃い色) - 複数の 行サポート
        painter.setPen(darker_color)
        for i, line in enumerate(lines):
            text_x = bubble_x + padding_x
            text_y = bubble_y + padding_y + metrics.ascent() + (i * text_height)
            painter.drawText(text_x, text_y, line)
        
        # painter 状態 復元
        painter.restore()
    
    def check_time_status(self):
        """時間帯別状態チェック"""
        from datetime import datetime
        current_hour = datetime.now().hour
        
        # 夜 時間 (22時~6時)
        if current_hour >= 22 or current_hour < 6:
            self.is_sleepy = True
        else:
            self.is_sleepy = False
    
    def update_position(self):
        """位置更新"""
        # 必須 属性 チェック
        if not hasattr(self, 'pixmap_right') or self.pixmap_right is None:
            return
        
        if self.dragging:
            return
        
        # 長い イベント 進行 中
        if self.in_event:
            self.update_long_event()
            # イベント 中にも 重力と 位置 アップデートは 適用
            self._apply_physics()
            return
        
        # 基本セリフ ランダム 表示 (0.2% 確率, 独りでも 話す)
        if random.random() < 0.002 and self.bubble_timer == 0:
            # 絵文字 fallback
            solo_emojis = ["😊", "✨", "💭", "🎵", "😌", "🌸", "💫", "🍀"]
            
            # キャッシュされた AI セリフが いれば API オフにも 表示
            ai_dialogue = get_cached_dialogue(self.char_id, 'solo') if getattr(self, 'personality', '') else None
            
            # AI セリフのみ 使用 (手動 セリフは 話し方 参考用としてのみ 使用)
            all_dialogues = []
            if ai_dialogue:
                all_dialogues.append(ai_dialogue)
            
            if all_dialogues:
                self.speech_bubble = random.choice(all_dialogues)
                self.bubble_timer = 120
            else:
                # 絵文字
                self.speech_bubble = random.choice(solo_emojis)
                self.bubble_timer = 90
        
        # 時間/季節 セリフ タイマー (1時間ごとに チェック)
        self.time_dialogue_timer += 1
        if self.time_dialogue_timer > 108000:  # 1時間ごとに チェック (30fps * 60 * 60)
            if random.random() < 0.85 and self.bubble_timer == 0 and self.personality:
                try:
                    from datetime import datetime
                    current_time = datetime.now()
                    current_period = get_time_period(current_time.hour)
                    
                    # 1. まず 既存 時間帯 セリフが あるか 確認
                    existing_dialogue = get_temp_dialogue(self.char_id, 'time', current_period)
                    
                    if existing_dialogue:
                        # 既存 セリフ 使用 (API オフにも 可能)
                        self.speech_bubble = existing_dialogue
                        self.bubble_timer = 120
                        print(f"[AI] 既存時間帯セリフ使用 ({current_period}): {existing_dialogue}")
                    elif is_ai_enabled():
                        # API オンにいれば 新しい セリフ生成
                        def on_time_dialogue(dialogue):
                            if dialogue and self.bubble_timer == 0:
                                self.speech_bubble = dialogue
                                self.bubble_timer = 120
                        
                        generate_time_weather_dialogue(
                            self.char_id,
                            self.char_name,
                            self.personality,
                            current_time,
                            None,
                            on_time_dialogue
                        )
                except Exception as e:
                    print(f"[エラー] 時間セリフ処理エラー: {e}")
            self.time_dialogue_timer = 0
            self.check_time_status()  # 時間 状態 アップデート
        
        x = self.x()
        y = self.y()
        
        # ウィンドウ 上記から 活動 チェック
        self.check_window_position()
        
        # 状態 切り替え (歩き <-> 停止)
        self.state_timer -= 1
        if self.state_timer <= 0:
            self.is_moving = not self.is_moving
            if self.is_moving:
                # 眠気 モードなら 速度 遅く
                if hasattr(self, 'sleepy_mode') and self.sleepy_mode:
                    self.velocity_x = random.choice([-0.8, -0.6, 0.6, 0.8])
                else:
                    self.velocity_x = random.choice([-2, -1.5, 1.5, 2])
                self.state_timer = random.randint(60, 180)
            else:
                self.velocity_x = 0
                self.state_timer = random.randint(30, 90)
        
        # ジャンプ クールダウン
        if self.jump_cooldown > 0:
            self.jump_cooldown -= 1
        
        # 自動 ジャンプ (床に いて 動いて いる 時)
        if self.on_ground and self.is_moving and self.jump_cooldown == 0:
            if random.random() < 0.05:
                self.velocity_y = self.jump_power
                self.is_jumping = True
                self.on_ground = False
            self.jump_cooldown = random.randint(30, 60)
        
        # 重力 適用
        if not self.on_ground:
            self.velocity_y += self.gravity
        
        # 新しい 位置 計算
        new_x = x + self.velocity_x
        new_y = y + self.velocity_y
        
        # 左右 壁 衝突 (マルチモニター 考慮)
        screen_left = getattr(self, 'screen_x', 0)
        screen_right = screen_left + self.screen_width - self.width()
        if new_x <= screen_left or new_x >= screen_right:
            self.velocity_x = -self.velocity_x
            new_x = max(screen_left, min(new_x, screen_right))
        
        # 床 または ウィンドウ ウィンドウ 上記 衝突
        # 現在 位置の モニターに 合った ground_level 動的 計算
        ground = self.get_current_ground_level(new_x)
        
        # 落下 中なら ウィンドウ 上記 着地 検出
        if self.velocity_y > 0 and not self.on_window:
            window_top = self.detect_window_below(new_x, new_y)
            if window_top is not None and new_y >= window_top:
                # ウィンドウ 上に 着地
                self.on_window = True
                self.window_top = window_top
                ground = window_top
        
        if self.on_window:
            ground = self.window_top
        
        if new_y >= ground:
            new_y = ground
            self.velocity_y = 0
            self.on_ground = True
            self.is_jumping = False
        else:
            self.on_ground = False
        
        # 方向 アップデート (イベント 中には 方向 維持 - 向かい合う)
        if not self.in_event:
            if self.velocity_x > 0:
                self.facing_right = True
            elif self.velocity_x < 0:
                self.facing_right = False
        
        self.move(int(new_x), int(new_y))
        
        # 吹き出し タイマー
        if self.bubble_timer > 0:
            self.bubble_timer -= 1
            if self.bubble_timer == 0:
                self.speech_bubble = None
        
        # 相互作用 クールダウン
        if self.interaction_cooldown > 0:
            self.interaction_cooldown -= 1
        
        self.update()
    
    def _apply_physics(self):
        """物理適用（イベント中も重力、衝突処理）"""
        x = self.x()
        y = self.y()
        
        # 重力 適用
        if not self.on_ground:
            self.velocity_y += self.gravity
            self.velocity_y = min(self.velocity_y, self.max_fall_speed)
        
        # 新しい 位置 計算
        new_x = x + self.velocity_x
        new_y = y + self.velocity_y
        
        # イベント 中 パートナーと 最小 距離 維持
        if self.in_event and self.event_partner:
            partner = self.event_partner
            
            # 愛情 関連 イベントは より 近く 許可
            if self.event_type in ['hug', 'heart', 'blush']:
                min_distance = self.size * 0.35  # ハグ/ハートは とても 近く
            elif self.event_type == 'dance' and self.event_data.get('relationship') == '恋人':
                min_distance = self.size * 0.45  # 恋人 ダンスも 近く
            else:
                min_distance = self.size * 0.6  # 基本 距離
            
            dx = new_x - partner.x()
            distance = abs(dx)
            
            if distance < min_distance:
                # あまりに が近ければ 押し出し
                push = (min_distance - distance) / 2
                if dx > 0:
                    new_x += push
                else:
                    new_x -= push
        
        # 左右 壁 衝突 (マルチモニター 考慮)
        screen_left = getattr(self, 'screen_x', 0)
        screen_right = screen_left + self.screen_width - self.width()
        if new_x <= screen_left or new_x >= screen_right:
            self.velocity_x = 0
            new_x = max(screen_left, min(new_x, screen_right))
        
        # 床 衝突 - 現在 位置の モニターに 合った ground_level 動的 計算
        ground = self.get_current_ground_level(new_x)
        if self.on_window:
            ground = self.window_top
        
        if new_y >= ground:
            new_y = ground
            self.velocity_y = 0
            self.on_ground = True
            self.is_jumping = False
        else:
            self.on_ground = False
        
        # 方向 アップデート (イベント 中には 方向 維持 - 向かい合う)
        if not self.in_event:
            if self.velocity_x > 0:
                self.facing_right = True
            elif self.velocity_x < 0:
                self.facing_right = False
        
        self.move(int(new_x), int(new_y))
        
        # 吹き出し タイマー
        if self.bubble_timer > 0:
            self.bubble_timer -= 1
            if self.bubble_timer == 0:
                self.speech_bubble = None
        
        # 相互作用 クールダウン
        if self.interaction_cooldown > 0:
            self.interaction_cooldown -= 1
        
        self.update()
    
    def apply_gravity_only(self):
        """重力のみ適用（イベント中も地面に張り付くように）"""
        screen = QApplication.primaryScreen().geometry()
        ground = screen.height() - self.height() - 50
        
        y = self.y()
        
        if not self.on_ground:
            self.velocity_y += self.gravity
            self.velocity_y = min(self.velocity_y, self.max_fall_speed)
            y += self.velocity_y
        
        if y >= ground:
            y = ground
            self.velocity_y = 0
            self.on_ground = True
        
        self.move(self.x(), int(y))
        
        # 吹き出し タイマー
        if self.bubble_timer > 0:
            self.bubble_timer -= 1
            if self.bubble_timer == 0:
                self.speech_bubble = None
        
        self.update()
    
    def check_window_position(self):
        """ウィンドウ上にいるか確認して自動で落下"""
        # ウィンドウ 上に いるが 端を 外れたら 落下
        if self.on_window:
            # 現在 位置から ウィンドウが 依然として あるか 確認
            window_top = self.detect_window_below(self.x(), self.y())
            if window_top is None or abs(window_top - self.window_top) > 10:
                # ウィンドウが ないか が動いたら 落下
                self.on_window = False
                self.window_top = 0
                self.on_ground = False
    
    def detect_window_below(self, x, y):
        """現在位置下にウィンドウがあるか検出"""
        if not _win32_available:
            return None
        
        try:
            windows = []
            
            def enum_callback(hwnd, results):
                if win32gui.IsWindowVisible(hwnd):
                    rect = win32gui.GetWindowRect(hwnd)
                    # rect = (left, top, right, bottom)
                    if rect[2] - rect[0] > 100 and rect[3] - rect[1] > 50:  # 最小 サイズ フィルター
                        results.append((hwnd, rect))
                return True
            
            win32gui.EnumWindows(enum_callback, windows)
            
            # キャラクター 位置 基準として 下に ある ウィンドウ 探す
            char_center_x = x + self.width() // 2
            char_bottom = y + self.height()
            
            best_window_top = None
            
            for hwnd, rect in windows:
                left, top, right, bottom = rect
                # キャラクターが ウィンドウの x 範囲 中に いて, ウィンドウ 上部が キャラクター 下に いる 時
                if left < char_center_x < right:
                    if top > char_bottom and top < self.ground_level:
                        if best_window_top is None or top < best_window_top:
                            best_window_top = top - self.height()  # キャラクター 足の位置
            
            return best_window_top
        except:
            return None
    
    def mousePressEvent(self, event):
        """クリックイベント"""
        if event.button() == Qt.LeftButton:
            self.was_clicked = True
            self.dragging = False
            self.drag_start_pos = event.globalPos()
            self.drag_start_widget_pos = self.pos()
    
    def mouseMoveEvent(self, event):
        """ドラッグイベント"""
        if self.was_clicked and self.drag_start_pos:
            delta = event.globalPos() - self.drag_start_pos
            if delta.manhattanLength() > 5:  # 5ピクセル以上 移動すると ドラッグで みなす
                self.dragging = True
                new_pos = self.drag_start_widget_pos + delta
                self.move(new_pos)
    
    def mouseReleaseEvent(self, event):
        """マウスリリースイベント"""
        if event.button() == Qt.LeftButton:
            
            if self.dragging:
                # ドラッグ 終了 - そのまま 落ちる
                self.dragging = False
                self.on_ground = False  # 落下 開始
                self.velocity_y = 2  # 少しの 初期落下 速度
                self.on_window = False
                self.window_top = 0
            elif self.was_clicked:
                # シンプル クリック - 独り言 セリフ 出力
                all_dialogues = []
                
                # AI セリフ 収集
                if self.personality:
                    ai_dialogue = get_cached_dialogue(self.char_id, 'solo')
                    if ai_dialogue:
                        all_dialogues.append(ai_dialogue)
                
                # 手動 セリフは 話し方 参考用としてのみ 使用 (出力 しない)
                
                # セリフ 選択
                if all_dialogues:
                    dialogue = random.choice(all_dialogues)
                else:
                    # 絵文字
                    reactions = ["❤️", "💕", "❗", "❓", "😊", "✨", "💫", "🎵"]
                    dialogue = random.choice(reactions)
                
                self.speech_bubble = dialogue
                self.bubble_timer = 90  # 3秒
                
                # クリックすると ジャンプ
                if self.on_ground:
                    self.velocity_y = self.jump_power * 0.8
                    self.is_jumping = True
                    self.on_ground = False
                self.update()
            
            self.was_clicked = False
            self.drag_start_pos = None
    
    def check_collision_with(self, other_char):
        """他のキャラクターとの衝突チェック"""
        # ドラッグ 中なら 衝突 無視
        if self.dragging or other_char.dragging:
            return False
        
        if self.interaction_cooldown > 0 or other_char.interaction_cooldown > 0:
            return False
        
        distance = math.sqrt((self.x() - other_char.x())**2 + 
                           (self.y() - other_char.y())**2)
        
        if distance < self.size * 0.8:
            return True
        return False
    
    def interact_with(self, other_char):
        """他のキャラクターと相互作用 - 感情ベースシステム"""
        if self.interaction_cooldown > 0 or other_char.interaction_cooldown > 0:
            return
        
        # 既に イベント 中なら 無視
        if self.in_event or other_char.in_event:
            return
        
        # 各自の 感情 確認 (新しい システム: 各 キャラクターが 相手へ 感じる 感情)
        try:
            my_feeling = self.relationships.get(other_char.char_id, "無関心") if isinstance(self.relationships, dict) else "無関心"
            their_feeling = other_char.relationships.get(self.char_id, "無関心") if isinstance(other_char.relationships, dict) else "無関心"
            # 文字列が でなければ デフォルト
            if not isinstance(my_feeling, str):
                my_feeling = "無関心"
            if not isinstance(their_feeling, str):
                their_feeling = "無関心"
        except Exception as e:
            print(f"[interact_with] 感情確認エラー: {e}")
            my_feeling = "無関心"
            their_feeling = "無関心"
        
        # 50% セリフ, 50% イベント (絵文字) - 5:5 比率
        use_dialogue = random.random() < 0.5
        
        # キャッシュされた セリフが いれば セリフ 相互作用 (API オフにも)
        has_cached_dialogue = (self.personality and get_cached_dialogue(self.char_id, 'interaction', other_char.char_id, other_char.char_name)) or \
                              (other_char.personality and get_cached_dialogue(other_char.char_id, 'interaction', self.char_id, self.char_name))
        
        if use_dialogue and has_cached_dialogue:
            # セリフ 相互作用 (イベント なく セリフのみ)
            self.dialogue_interaction(other_char, my_feeling, their_feeling)
        else:
            # イベント 相互作用 (絵文字のみ)
            if random.random() < 0.7:
                self.short_interaction(other_char, my_feeling, their_feeling)
            else:
                # 床に いる 時のみ 長い イベント 開始
                if self.on_ground and other_char.on_ground:
                    self.start_long_event(other_char, my_feeling, their_feeling)
                else:
                    self.short_interaction(other_char, my_feeling, their_feeling)
    
    def dialogue_interaction(self, other_char, my_feeling, their_feeling):
        """セリフ相互作用 - AIセリフと手動セリフ表示"""
        my_dialogues = []
        other_dialogues = []
        
        # 私のセリフ 収集
        if self.personality:
            ai_dialogue = get_cached_dialogue(self.char_id, 'interaction', other_char.char_id, other_char.char_name)
            if ai_dialogue:
                my_dialogues.append(ai_dialogue)
        # 手動 セリフは 話し方 参考用としてのみ 使用 (出力 しない)
        
        # 相手 セリフ 収集
        if other_char.personality:
            ai_dialogue = get_cached_dialogue(other_char.char_id, 'interaction', self.char_id, self.char_name)
            if ai_dialogue:
                other_dialogues.append(ai_dialogue)
        # 相手 手動 セリフも 話し方 参考用としてのみ 使用 (出力 しない)
        
        # セリフが 一つでも いれば 表示
        if my_dialogues or other_dialogues:
            if my_dialogues:
                self.speech_bubble = random.choice(my_dialogues)
                self.bubble_timer = random.randint(120, 180)
            if other_dialogues:
                other_char.speech_bubble = random.choice(other_dialogues)
                other_char.bubble_timer = random.randint(120, 180)
            
            # クールダウン
            self.interaction_cooldown = 120
            other_char.interaction_cooldown = 120
            
            # 向かい合う
            if self.x() < other_char.x():
                self.facing_right = True
                other_char.facing_right = False
            else:
                self.facing_right = False
                other_char.facing_right = True
        else:
            # セリフ なければ イベントで 代替
            self.short_interaction(other_char, my_feeling, their_feeling)
    
    def short_interaction(self, other_char, my_feeling, their_feeling):
        """短い相互作用 - 感情ベース絵文字表示"""
        
        # 感情別 絵文字 定義 (11種類 感情 x 12個) - 壊れる 絵文字 代替される
        feeling_emojis = {
            "愛情": ['💕', '🥰', '💖', '😍', '💗', '☺️', '💘', '❤️', '💝', '😊', '✨', '💓'],
            "友情": ['🤝', '😊', '🙌', '👋', '✨', '💫', '😄', '👍', '🎉', '😁', '🤗', '👊'],
            "憧れ": ['✨', '🤩', '🌟', '👏', '😊', '🙏', '⭐', '💫', '🤍', '😌', '🙏', '🏅'],
            "信頼": ['🤗', '🤝', '💖', '😊', '✨', '💪', '👍', '😌', '🙏', '🙂', '👐', '🤍'],
            "いたずら": ['😜', '🤭', '😝', '🤪', '😏', '👻', '🎉', '😆', '🎭', '😈', '👅', '🤡'],
            "ライバル心": ['🔥', '💪', '😤', '⚡', '🏆', '💥', '😎', '🥇', '👊', '🎯', '⭐', '🏅'],
            "イライラ": ['😤', '💢', '😒', '🙄', '😑', '💦', '😠', '😩', '😫', '🙁', '😩', '🤦'],
            "嫉妬": ['😒', '🔥', '😤', '💢', '😠', '👀', '⚡', '😡', '🤨', '💥', '😾', '👁️'],
            "嫌悪": ['😤', '💢', '😠', '👿', '😡', '🔥', '⚡', '💀', '💥', '🖤', '☠️', '👊'],
            "気まずい": ['😶', '😅', '💦', '🤔', '😬', '😐', '❓', '😳', '👀', '😳', '😅', '🙃'],
            "無関心": ['😐', '🙄', '😑', '💭', '😶', '🤷', '💤', '🥱', '😴', '😶', '😐', '😪']
        }
        
        # 各自の 絵文字 選択
        my_emoji = random.choice(feeling_emojis.get(my_feeling, ['😐']))
        other_emoji = random.choice(feeling_emojis.get(their_feeling, ['😐']))
        
        # ジャンプ 確率 (感情別に 異なる)
        jump_probs = {
            "愛情": 0.2, "友情": 0.3, "憧れ": 0.1, "信頼": 0.2,
            "いたずら": 0.5, "ライバル心": 0.5, "イライラ": 0.3, "嫉妬": 0.4, "嫌悪": 0.4,
            "気まずい": 0.1, "無関心": 0.0
        }
        my_jump = jump_probs.get(my_feeling, 0.1)
        other_jump = jump_probs.get(their_feeling, 0.1)
        
        # 絵文字 表示
        self.speech_bubble = my_emoji
        other_char.speech_bubble = other_emoji
        self.bubble_timer = random.randint(60, 120)
        other_char.bubble_timer = random.randint(60, 120)
        
        # クールダウン
        self.interaction_cooldown = 90
        other_char.interaction_cooldown = 90
        
        # 押し出し 強度 (感情別に 異なる)
        push_strengths = {
            "愛情": 0.8, "友情": 1.2, "憧れ": 1.0, "信頼": 1.0,
            "いたずら": 2.0, "ライバル心": 2.5, "イライラ": 2.0, "嫉妬": 2.0, "嫌悪": 2.5,
            "気まずい": 1.5, "無関心": 1.5
        }
        dx = self.x() - other_char.x()
        my_push = push_strengths.get(my_feeling, 1.5)
        other_push = push_strengths.get(their_feeling, 1.5)
        
        if dx > 0:
            self.velocity_x = my_push
            other_char.velocity_x = -other_push
        else:
            self.velocity_x = -my_push
            other_char.velocity_x = other_push
        
        # ジャンプ
        if random.random() < my_jump and self.on_ground:
            self.velocity_y = self.jump_power * 0.3
            self.on_ground = False
        if random.random() < other_jump and other_char.on_ground:
            other_char.velocity_y = other_char.jump_power * 0.3
            other_char.on_ground = False
    
    def start_long_event(self, other_char, my_feeling, their_feeling):
        """長いイベント開始 - 感情ベースシステム"""
        
        # 感情別 絵文字 シーケンス 定義 (12個ずつ) - 壊れる 絵文字 代替される
        feeling_sequences = {
            "愛情": ['💕', '🥰', '💖', '😍', '💗', '☺️', '💝', '✨', '💓', '❤️', '😊', '💘'],
            "友情": ['🤝', '😊', '🙌', '👋', '✨', '💫', '😄', '🎉', '👍', '😁', '🤗', '👊'],
            "憧れ": ['✨', '🤩', '🌟', '👏', '😊', '🙏', '💫', '⭐', '🤍', '😌', '🙏', '🏅'],
            "信頼": ['🤗', '🤝', '💖', '😊', '✨', '💪', '👍', '😌', '🙏', '🙂', '👐', '🤍'],
            "いたずら": ['😜', '🤭', '😝', '🤪', '😏', '👻', '🎭', '😆', '🎉', '😈', '👅', '🤡'],
            "ライバル心": ['🔥', '💪', '😤', '⚡', '🏆', '💥', '😎', '🥇', '👊', '🎯', '⭐', '🏅'],
            "イライラ": ['😤', '💢', '😒', '🙄', '😑', '💦', '😫', '💢', '😩', '🙁', '😩', '🤦'],
            "嫉妬": ['😒', '🔥', '😤', '💢', '😠', '👀', '😑', '⚡', '🤨', '💥', '😾', '👁️'],
            "嫌悪": ['😤', '💢', '😠', '👿', '😡', '🔥', '⚡', '💀', '💥', '🖤', '☠️', '👊'],
            "気まずい": ['😶', '😅', '💦', '🤔', '😬', '...', '👀', '😳', '😅', '🙃', '😐', '❓'],
            "無関心": ['😐', '🙄', '...', '😑', '💭', '😶', '💤', '...', '🥱', '😴', '😶', '🤷']
        }
        
        # 感情 組み合わせに による イベント タイプと 持続 時間 決定
        # 同じ 感情同士の 組み合わせ (絵文字 シーケンス 10個)
        same_feeling_events = {
            ("愛情", "愛情"): ('love_dance', 210, ['💕', '🎵', '💃', '🕺', '💖', '✨', '🎶', '💝', '❤️', '🥰']),
            ("友情", "友情"): ('friend_dance', 180, ['🎵', '💃', '🕺', '✨', '🎶', '⭐', '🤝', '🙌', '😄', '🎉']),
            ("憧れ", "憧れ"): ('mutual_respect', 150, ['✨', '🌟', '👏', '⭐', '💫', '🤩', '🙏', '🏅', '😊', '🤍']),
            ("信頼", "信頼"): ('partner_bond', 150, ['🤝', '💪', '✨', '👊', '🔥', '🙏', '👍', '😌', '🤍', '🤗']),
            ("いたずら", "いたずら"): ('play_together', 180, ['😜', '🤪', '😝', '👻', '🎉', '😆', '🎭', '😈', '👅', '🤡']),
            ("ライバル心", "ライバル心"): ('compete_battle', 180, ['🔥', '💪', '⚡', '🏆', '💥', '😤', '🥇', '👊', '🎯', '🏅']),
            ("イライラ", "イライラ"): ('mutual_annoy', 120, ['😤', '💢', '😒', '🙄', '😑', '😫', '😩', '🤦', '😩', '💦']),
            ("嫉妬", "嫉妬"): ('rival_battle', 180, ['🔥', '😤', '⚡', '💢', '💥', '😠', '👀', '🤨', '😾', '👁️']),
            ("嫌悪", "嫌悪"): ('enemy_fight', 180, ['😡', '💢', '😠', '💢', '😤', '👿', '💀', '☠️', '💥', '🖤']),
            ("気まずい", "気まずい"): ('awkward_meet', 90, ['😶', '...', '👀', '😳', '😅', '😅', '😬', '🙃', '❓', '💦']),
            ("無関心", "無関心"): ('ignore_each', 60, ['😐', '...', '🙄', '💤', '🥱', '😴', '😑', '😶', '🤷', '💭'])
        }
        
        # 非対称 感情 組み合わせ (各 感情別 最小 6個 イベント 保証)
        asymmetric_events = {
            # 愛情 関連 (6個)
            ("愛情", "嫌悪"): ('unrequited_love', 150),
            ("愛情", "無関心"): ('one_sided_love', 120),
            ("愛情", "気まずい"): ('shy_love', 120),
            ("愛情", "友情"): ('friend_crush', 150),
            ("愛情", "嫉妬"): ('passionate_love', 150),
            ("愛情", "ライバル心"): ('love_rivalry', 150),
            
            # 友情 関連 (6個)
            ("友情", "愛情"): ('friend_zone', 150),
            ("友情", "無関心"): ('trying_to_befriend', 120),
            ("友情", "イライラ"): ('annoying_friend', 120),
            ("友情", "ライバル心"): ('friendly_competition', 150),
            ("友情", "気まずい"): ('new_friendship', 120),
            ("友情", "嫌悪"): ('broken_friendship', 120),
            
            # 憧れ 関連 (6個)
            ("憧れ", "無関心"): ('one_sided_admire', 120),
            ("憧れ", "嫉妬"): ('envied_idol', 150),
            ("憧れ", "愛情"): ('admire_to_love', 150),
            ("憧れ", "友情"): ('fan_meeting', 120),
            ("憧れ", "ライバル心"): ('aspiring_rival', 150),
            ("憧れ", "信頼"): ('mentor_admire', 120),
            
            # 信頼 関連 (6個)
            ("信頼", "愛情"): ('trusted_love', 150),
            ("信頼", "友情"): ('reliable_friend', 120),
            ("信頼", "無関心"): ('unnoticed_trust', 90),
            ("信頼", "気まずい"): ('building_trust', 120),
            ("信頼", "ライバル心"): ('trusted_rival', 150),
            ("信頼", "イライラ"): ('testing_patience', 120),
            
            # いたずら 関連 (6個)
            ("いたずら", "イライラ"): ('teasing', 150),
            ("いたずら", "嫌悪"): ('bullying', 120),
            ("いたずら", "気まずい"): ('awkward_prank', 90),
            ("いたずら", "友情"): ('playful_friend', 150),
            ("いたずら", "愛情"): ('flirty_tease', 150),
            ("いたずら", "無関心"): ('ignored_prank', 90),
            
            # ライバル心 関連 (6個)
            ("ライバル心", "愛情"): ('competitive_crush', 150),
            ("ライバル心", "友情"): ('rival_friendship', 150),
            ("ライバル心", "嫉妬"): ('intense_rivalry', 180),
            ("ライバル心", "無関心"): ('one_sided_rival', 120),
            ("ライバル心", "憧れ"): ('competitive_admire', 150),
            ("ライバル心", "嫌悪"): ('bitter_rival', 180),
            
            # イライラ 関連 (6個)
            ("イライラ", "愛情"): ('annoyed_by_love', 120),
            ("イライラ", "友情"): ('annoyed_friend', 120),
            ("イライラ", "いたずら"): ('annoyed_by_prank', 120),
            ("イライラ", "無関心"): ('mutual_disinterest', 90),
            ("イライラ", "ライバル心"): ('frustrated_rival', 150),
            ("イライラ", "信頼"): ('testing_trust', 120),
            
            # 嫉妬 関連 (6個)
            ("嫉妬", "愛情"): ('jealous_lover', 150),
            ("嫉妬", "憧れ"): ('envious_admirer', 150),
            ("嫉妬", "無関心"): ('ignored_rival', 120),
            ("嫉妬", "友情"): ('jealous_friend', 150),
            ("嫉妬", "ライバル心"): ('envious_competitor', 180),
            ("嫉妬", "嫌悪"): ('hateful_envy', 180),
            
            # 嫌悪 関連 (6個)
            ("嫌悪", "愛情"): ('rejecting_love', 150),
            ("嫌悪", "友情"): ('hostile_friend', 120),
            ("嫌悪", "無関心"): ('ignored_enemy', 90),
            ("嫌悪", "いたずら"): ('hate_pranks', 120),
            ("嫌悪", "ライバル心"): ('hateful_rival', 180),
            ("嫌悪", "嫉妬"): ('mutual_hatred', 180),
            
            # 気まずい 関連 (6個)
            ("気まずい", "愛情"): ('shy_crush', 120),
            ("気まずい", "友情"): ('awkward_friend', 90),
            ("気まずい", "いたずら"): ('confused_by_prank', 90),
            ("気まずい", "無関心"): ('mutual_awkward', 60),
            ("気まずい", "信頼"): ('hesitant_trust', 90),
            ("気まずい", "ライバル心"): ('awkward_rival', 90),
            
            # 無関心 関連 (6個)
            ("無関心", "愛情"): ('cold_response', 90),
            ("無関心", "友情"): ('distant_friend', 90),
            ("無関心", "嫉妬"): ('unbothered', 60),
            ("無関心", "嫌悪"): ('apathetic', 60),
            ("無関心", "ライバル心"): ('uninterested_rival', 60),
            ("無関心", "いたずら"): ('ignoring_prank', 60),
        }
        
        # イベント 情報 決定
        feeling_pair = (my_feeling, their_feeling)
        reverse_pair = (their_feeling, my_feeling)
        
        if feeling_pair in same_feeling_events:
            event_type, duration, emojis = same_feeling_events[feeling_pair]
            is_asymmetric = False
        elif feeling_pair in asymmetric_events:
            event_type, duration = asymmetric_events[feeling_pair]
            emojis = feeling_sequences.get(my_feeling, ['😐'])
            is_asymmetric = True
        elif reverse_pair in asymmetric_events:
            event_type, duration = asymmetric_events[reverse_pair]
            emojis = feeling_sequences.get(my_feeling, ['😐'])
            is_asymmetric = True
        else:
            # 基本イベント
            event_type = 'interaction'
            duration = 120
            emojis = feeling_sequences.get(my_feeling, ['😐'])
            is_asymmetric = True
        
        print(f"[長い イベント] {event_type} 開始 ({self.char_id}:{my_feeling} ↔ {other_char.char_id}:{their_feeling})")
        
        # 各 キャラクターの 絵文字 シーケンス 設定
        my_emojis = emojis if not is_asymmetric else feeling_sequences.get(my_feeling, ['😐'])
        other_emojis = emojis if not is_asymmetric else feeling_sequences.get(their_feeling, ['😐'])
        
        # 両方 イベント 状態で
        self.in_event = True
        self.event_type = event_type
        self.event_partner = other_char
        self.event_frame = 0
        self.event_duration = duration
        self.event_data = {
            'emojis': my_emojis,
            'my_feeling': my_feeling,
            'their_feeling': their_feeling,
            'is_asymmetric': is_asymmetric
        }
        
        other_char.in_event = True
        other_char.event_type = event_type
        other_char.event_partner = self
        other_char.event_frame = 0
        other_char.event_duration = duration
        other_char.event_data = {
            'emojis': other_emojis,
            'my_feeling': their_feeling,
            'their_feeling': my_feeling,
            'is_asymmetric': is_asymmetric
        }
        
        # クールダウン 設定 (イベント 終わって 適用)
        self.interaction_cooldown = duration + 150
        other_char.interaction_cooldown = duration + 150
        
        # 移動 停止
        self.velocity_x = 0
        other_char.velocity_x = 0
        
        # 向かい合う
        if self.x() < other_char.x():
            self.facing_right = True
            other_char.facing_right = False
        else:
            self.facing_right = False
            other_char.facing_right = True
        
        # 最初の絵文字
        self.speech_bubble = random.choice(my_emojis)
        other_char.speech_bubble = random.choice(other_emojis)
        self.bubble_timer = 60
        other_char.bubble_timer = 60
    
    def update_long_event(self):
        """長い イベント アップデート (毎フレーム呼び出し) - 豊富なモーション"""
        if not self.in_event or not self.event_partner:
            return
        
        self.event_frame += 1
        partner = self.event_partner
        emojis = self.event_data.get('emojis', ['✨'])
        event_type = self.event_type
        duration = self.event_duration
        
        # 絵文字 アップデート ヘルパー
        def update_emoji(interval=30):
            if self.event_frame % interval == 0:
                idx = (self.event_frame // interval) % len(emojis)
                self.speech_bubble = emojis[idx]
                self.bubble_timer = interval + 10
        
        # ========== ダンス イベント (一番 華やかに) ==========
        if event_type == 'dance' or event_type == 'love_dance' or event_type == 'friend_dance':
            update_emoji(25)
            relationship = self.event_data.get('relationship', '')
            # love_danceは 恋人 ダンスとして 処理
            if event_type == 'love_dance':
                relationship = '恋人'
            
            # フェーズ別 モーション
            phase = self.event_frame % 90  # 3秒 周期
            
            if phase < 15:
                # 左右で 揺らす (左)
                self.velocity_x = -1.5
            elif phase < 30:
                # 左右で 揺らす （右）
                self.velocity_x = 1.5
            elif phase < 45:
                # ジャンプ!
                if self.on_ground:
                    self.velocity_y = self.jump_power * 0.5
                    self.on_ground = False
                self.velocity_x = 0
            elif phase < 60:
                # 再度 左右 （右）
                self.velocity_x = 1.5
            elif phase < 75:
                # 再度 左右 (左)
                self.velocity_x = -1.5
            else:
                # その場
                self.velocity_x = 0
                # 小さい ジャンプ
                if self.on_ground and phase == 80:
                    self.velocity_y = self.jump_power * 0.3
                    self.on_ground = False
            
            # 恋人の日 時 たまに お互い 近づく
            if relationship == '恋人' and partner:
                dx = partner.x() - self.x()
                close_phase = self.event_frame % 120
                if 90 < close_phase < 110:
                    # 近く 近づく
                    if abs(dx) > self.size * 0.5:
                        self.velocity_x = 0.8 if dx > 0 else -0.8
            
            # 最後に 同時 大きいジャンプ
            if self.event_frame == duration - 30 and self.on_ground:
                self.velocity_y = self.jump_power * 0.7
                self.on_ground = False
                self.speech_bubble = '✨'
                self.bubble_timer = 40
        
        # ========== ハイタッチ/拳 挨拶 ==========
        elif event_type == 'high_five' or event_type == 'fist_bump':
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                if self.event_frame < 25:
                    # 1段階: 近づく (最小 距離までのみ)
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.5 if dx > 0 else -1.5
                    else:
                        self.velocity_x = 0
                elif self.event_frame < 35:
                    # 2段階: ジャンプしながら タッチ!
                    self.velocity_x = 0
                    if self.event_frame == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.6
                        self.on_ground = False
                        self.speech_bubble = '🙌' if event_type == 'high_five' else '👊'
                        self.bubble_timer = 40
                elif self.event_frame < 60:
                    # 3段階: 後退や
                    self.velocity_x = -1.2 if dx > 0 else 1.2
                else:
                    # 4段階: 仕上げ (お互い 向き合って 小さい ジャンプ)
                    self.velocity_x = 0
                    if self.event_frame == 70 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
        
        # ========== 静か ==========
        elif event_type == 'chat':
            update_emoji(35)
            
            # たまに 頭 うなずくように 小さい ジャンプ
            if self.event_frame % 50 == 0 and random.random() < 0.4 and self.on_ground:
                self.velocity_y = self.jump_power * 0.2
                self.on_ground = False
            
            # たまに 左右で 少し 動き
            if self.event_frame % 40 == 0:
                self.velocity_x = random.choice([-0.5, 0, 0.5])
            elif self.event_frame % 40 == 20:
                self.velocity_x = 0
        
        # ========== 一緒に ジャンプ ==========
        elif event_type == 'jump_together':
            update_emoji(30)
            
            # 同時に ジャンプ (パートナーと シンク)
            if self.event_frame % 35 == 0 and self.on_ground:
                self.velocity_y = self.jump_power * 0.6
                self.on_ground = False
            
            # ジャンプ 間に 少し 近づいて 離れて
            phase = self.event_frame % 70
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                if phase < 20:
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.8 if dx > 0 else -0.8
                    else:
                        self.velocity_x = 0
                elif phase < 40:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    self.velocity_x = 0
        
        # ========== ハート/静か ==========
        elif event_type == 'heart' or event_type == 'blush':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                close_dist = self.size * 0.5  # より 近い 距離
                
                # ゆっくり 近づいて 静かに 後退, たまに より 近く
                cycle = self.event_frame % 100
                if cycle < 35:
                    # 少し 近づく
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.6 if dx > 0 else -0.6
                    else:
                        self.velocity_x = 0
                elif cycle < 50:
                    # より 近く 近づく (ときめく 瞬間)
                    if abs(dx) > close_dist:
                        self.velocity_x = 0.3 if dx > 0 else -0.3
                    else:
                        self.velocity_x = 0
                    if cycle == 45 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.15  # ときめく 小さい ジャンプ
                        self.on_ground = False
                elif cycle < 70:
                    # 静かに 後退や
                    self.velocity_x = -0.4 if dx > 0 else 0.4
                else:
                    self.velocity_x = 0
                    # ときめく 小さい ジャンプ
                    if cycle == 85 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.2
                        self.on_ground = False
        
        # ========== ハグ ==========
        elif event_type == 'hug':
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.6  # ハグは より 近く
                close_dist = self.size * 0.4  # とても 近く
                
                if self.event_frame < 40:
                    # 1段階: 近づく
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                    else:
                        self.velocity_x = 0
                elif self.event_frame < 60:
                    # 2段階: より 近く (ハグ)
                    if abs(dx) > close_dist:
                        self.velocity_x = 0.5 if dx > 0 else -0.5
                    else:
                        self.velocity_x = 0
                elif self.event_frame < duration - 30:
                    # 3段階: 近く 維持しながら 幸せ
                    self.velocity_x = 0
                    if abs(dx) > close_dist + 5:
                        self.velocity_x = 0.2 if dx > 0 else -0.2
                    # たまに 幸せな 小さい ジャンプ
                    if self.event_frame % 45 == 0 and random.random() < 0.4 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.12
                        self.on_ground = False
                else:
                    # 4段階: 少し 後退や
                    self.velocity_x = -0.5 if dx > 0 else 0.5
        
        # ========== 応援/訓練 ==========
        elif event_type == 'cheer' or event_type == 'training':
            update_emoji(25)
            
            # 力強い ジャンプ + 左右 動き
            phase = self.event_frame % 50
            if phase < 15:
                self.velocity_x = -1.0
            elif phase < 30:
                self.velocity_x = 1.0
            else:
                self.velocity_x = 0
                if phase == 35 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.55
                    self.on_ground = False
        
        # ========== バトル ==========
        elif event_type == 'battle':
            update_emoji(20)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 攻撃的な 動き
                phase = self.event_frame % 60
                if phase < 20:
                    # 突進! (最小 距離までのみ)
                    if abs(dx) > min_dist:
                        self.velocity_x = 2.0 if dx > 0 else -2.0
                    else:
                        self.velocity_x = 0
                    if phase == 15 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 40:
                    # 後退や
                    self.velocity_x = -1.5 if dx > 0 else 1.5
                else:
                    # 待機
                    self.velocity_x = 0
                    if phase == 50 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
        
        # ========== レース ==========
        elif event_type == 'race':
            update_emoji(20)
            
            if partner:
                # 同じ 方向として 走る!
                if 'race_direction' not in self.event_data:
                    self.event_data['race_direction'] = random.choice([-1, 1])
                
                direction = self.event_data['race_direction']
                
                if self.event_frame < duration - 40:
                    # 走る
                    self.velocity_x = 2.5 * direction
                    
                    # 走しながら ジャンプ
                    if self.event_frame % 25 == 0 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                    
                    # 壁に 触れたら 方向切り替え
                    if self.x() <= 10 or self.x() >= self.screen_width - self.width() - 10:
                        self.event_data['race_direction'] = -direction
                else:
                    # 仕上げ - 停止
                    self.velocity_x *= 0.8
                    if abs(self.velocity_x) < 0.1:
                        self.velocity_x = 0
        
        # ========== 雪合戦 ==========
        elif event_type == 'stare':
            update_emoji(40)
            
            # 離れて 立って 向かい合う (たまに 威嚇的 ジャンプ)
            self.velocity_x = 0
            if self.event_frame % 60 == 30 and self.on_ground:
                self.velocity_y = self.jump_power * 0.3
                self.on_ground = False
        
        # ========== 喧嘩 ==========
        elif event_type == 'argue':
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 怒って ぴょんぴょん
                phase = self.event_frame % 45
                if phase < 15:
                    self.velocity_x = 1.0 if dx > 0 else -1.0  # 近づく
                elif phase < 30:
                    self.velocity_x = -1.0 if dx > 0 else 1.0  # 後退
                    if phase == 20 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                else:
                    self.velocity_x = 0
        
        # ========== 無視 ==========
        elif event_type == 'ignore':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                if self.event_frame == 25:
                    self.facing_right = not self.facing_right  # 等 向ける
                
                # 等 向けて 離れる
                if self.event_frame > 30:
                    self.velocity_x = -0.8 if dx > 0 else 0.8
        
        # ========== 自慢 ==========
        elif event_type == 'showoff':
            update_emoji(25)
            
            # 誇示するように 高く ジャンプ + 左右 アピール
            phase = self.event_frame % 60
            if phase < 20:
                self.velocity_x = 1.5
            elif phase < 40:
                self.velocity_x = -1.5
            else:
                self.velocity_x = 0
                if phase == 45 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.6
                    self.on_ground = False
        
        # ========== も足 ==========
        elif event_type == 'taunt':
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 近づいてが 離れて 後退
                phase = self.event_frame % 50
                if phase < 15:
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.2 if dx > 0 else -1.2
                    else:
                        self.velocity_x = 0
                elif phase < 25:
                    self.velocity_x = 0
                    if phase == 18 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.35
                        self.on_ground = False
                elif phase < 40:
                    self.velocity_x = -1.0 if dx > 0 else 1.0
                else:
                    self.velocity_x = 0
        
        # ========== 競争 ==========
        elif event_type == 'compete':
            update_emoji(20)
            
            # 交互に 高く ジャンプしながら 競争
            if self.event_frame % 40 == 0 and self.on_ground:
                self.velocity_y = self.jump_power * 0.65
                self.on_ground = False
            
            # 左右で 動きながら
            phase = self.event_frame % 40
            if phase < 10:
                self.velocity_x = 1.2
            elif phase < 20:
                self.velocity_x = -1.2
            else:
                self.velocity_x = 0
        
        # ========== にらみ合い ==========
        elif event_type == 'glare':
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # こっそり 近づいてが 威嚇
                phase = self.event_frame % 70
                if phase < 30:
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.5 if dx > 0 else -0.5
                    else:
                        self.velocity_x = 0
                elif phase < 40:
                    self.velocity_x = 0
                    if phase == 35 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
                elif phase < 60:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    self.velocity_x = 0
        
        # ========== 冷淡 ==========
        elif event_type == 'cold':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 視線 避けながら 離れる
                if self.event_frame == 20:
                    self.facing_right = dx < 0  # 反対 方向 見る
                
                self.velocity_x = -0.4 if dx > 0 else 0.4
        
        # ========== 恨み ==========
        elif event_type == 'spite':
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 怒りで ぴょんぴょん
                phase = self.event_frame % 40
                if phase < 15:
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.8 if dx > 0 else -0.8
                    else:
                        self.velocity_x = 0
                    if phase == 10 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                elif phase < 30:
                    self.velocity_x = -0.8 if dx > 0 else 0.8
                else:
                    self.velocity_x = 0
        
        # ========== 緊張感 ==========
        elif event_type == 'tension':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 張り詰めた 対峙 - たまに 威嚇
                phase = self.event_frame % 80
                if phase == 40 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.4
                    self.on_ground = False
                    self.velocity_x = 1.0 if dx > 0 else -1.0
                elif phase > 40 and phase < 55:
                    self.velocity_x = -0.8 if dx > 0 else 0.8
                else:
                    self.velocity_x = 0
        
        # ========== 気まずい/挨拶 ==========
        elif event_type == 'awkward' or event_type == 'wave':
            update_emoji(35)
            
            # 気まずく 手を揺らす (小さい ジャンプ)
            if self.event_frame == 20 and self.on_ground:
                self.velocity_y = self.jump_power * 0.15
                self.on_ground = False
        
        # ========== 好奇心 ==========
        elif event_type == 'curious':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                phase = self.event_frame % 80
                if phase < 30:
                    # こっそり 近づく (最小 距離までのみ)
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.6 if dx > 0 else -0.6
                    else:
                        self.velocity_x = 0
                elif phase < 50:
                    # びっくり 驚いて 後退
                    self.velocity_x = -1.0 if dx > 0 else 1.0
                    if phase == 35 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.2
                        self.on_ground = False
                else:
                    self.velocity_x = 0
        
        # ========== 緊張 ==========
        elif event_type == 'nervous':
            update_emoji(40)
            
            # うろつき
            phase = self.event_frame % 50
            if phase < 15:
                self.velocity_x = 0.6
            elif phase < 30:
                self.velocity_x = -0.6
            else:
                self.velocity_x = 0
                if phase == 40 and self.on_ground and random.random() < 0.4:
                    self.velocity_y = self.jump_power * 0.15
                    self.on_ground = False
        
        # ========== 例の ==========
        elif event_type == 'polite':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 丁寧に 挨拶
                if self.event_frame == 30 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.2  # 挨拶
                    self.on_ground = False
                
                if self.event_frame == 70 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.15  # 再度 挨拶
                    self.on_ground = False
        
        # ========== 観察 ==========
        elif event_type == 'observe':
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.9  # 観察は より 遠くから
                
                # 距離 維持しながら 観察
                if abs(dx) < min_dist:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                elif abs(dx) > self.size * 1.5:
                    self.velocity_x = 0.3 if dx > 0 else -0.3
                else:
                    self.velocity_x = 0
        
        # ========== ライバル心 関連 イベント ==========
        elif event_type in ['compete_battle', 'intense_rivalry', 'envious_competitor', 'bitter_rival', 'hateful_rival']:
            # 熾烈な 競争 - 交互に ジャンプしながら 対決
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.6
                
                phase = self.event_frame % 60
                if phase < 15:
                    # 近づく
                    if abs(dx) > min_dist:
                        self.velocity_x = 2.0 if dx > 0 else -2.0
                    else:
                        self.velocity_x = 0
                elif phase < 25:
                    # ジャンプ 攻撃
                    self.velocity_x = 0
                    if phase == 15 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.7
                        self.on_ground = False
                elif phase < 40:
                    # 後退や
                    self.velocity_x = -1.5 if dx > 0 else 1.5
                else:
                    # 対峙
                    self.velocity_x = 0
                    if phase == 50 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
        
        elif event_type in ['love_rivalry', 'passionate_love', 'competitive_crush', 'jealous_lover']:
            # 愛情+競争 混合 - 近づいて 恥ずかしくて 後退
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                phase = self.event_frame % 80
                
                if phase < 25:
                    # 情熱的として 近づく
                    self.velocity_x = 1.8 if dx > 0 else -1.8
                elif phase < 35:
                    # ジャンプ
                    self.velocity_x = 0
                    if phase == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 55:
                    # 静かに 後退や
                    self.velocity_x = -1.2 if dx > 0 else 1.2
                else:
                    self.velocity_x = 0
        
        elif event_type in ['friendly_competition', 'rival_friendship', 'trusted_rival', 'aspiring_rival']:
            # 友好的 競争 - 一緒に 跳びながら 競争
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                phase = self.event_frame % 50
                
                if phase < 20:
                    # 並んで 走る
                    self.velocity_x = 2.0 if dx > 0 else -2.0
                elif phase < 30:
                    # 同時 ジャンプ
                    self.velocity_x = 0
                    if phase == 20 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.6
                        self.on_ground = False
                else:
                    # その場
                    self.velocity_x = 0
        
        elif event_type in ['one_sided_rival', 'uninterested_rival', 'ignored_rival', 'one_sided_admire', 'one_sided_love']:
            # 一方的 関心 - な側のみ 近づく
            update_emoji(35)
            
            my_feeling = self.event_data.get('my_feeling', '')
            if partner:
                dx = partner.x() - self.x()
                
                # 関心 ある 側のみ 近づく
                if my_feeling in ['ライバル心', '憧れ', '愛情', '嫉妬']:
                    phase = self.event_frame % 60
                    if phase < 25:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                    elif phase < 40:
                        self.velocity_x = 0
                    else:
                        self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    # 無関心な 側は 距離 維持
                    self.velocity_x = 0
                    if self.event_frame % 40 == 0:
                        self.velocity_x = random.choice([-0.5, 0.5])
        
        elif event_type in ['frustrated_rival', 'awkward_rival', 'annoyed_by_prank', 'annoyed_friend', 'annoyed_by_love']:
            # イライラ+不快 - ぴょんぴょん 跳びながら イライラ
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                
                # たまに イライラしながら ジャンプ
                if self.event_frame % 35 == 0 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.4
                    self.on_ground = False
                
                # 距離 維持
                phase = self.event_frame % 50
                if phase < 20:
                    self.velocity_x = -1.0 if dx > 0 else 1.0
                else:
                    self.velocity_x = 0
        
        elif event_type in ['trusted_love', 'reliable_friend', 'playful_friend', 'fan_meeting', 'admire_to_love']:
            # ポジティブ敵 関係 - 近く 近づいて とともに
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.6
                
                phase = self.event_frame % 60
                if phase < 30:
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.2 if dx > 0 else -1.2
                    else:
                        self.velocity_x = 0
                        if phase == 20 and self.on_ground:
                            self.velocity_y = self.jump_power * 0.4
                            self.on_ground = False
                else:
                    self.velocity_x = 0
        
        elif event_type in ['shy_crush', 'building_trust', 'hesitant_trust', 'new_friendship', 'awkward_friend']:
            # 気まずい ポジティブ - 慎重に 近づく
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 80
                if phase < 30:
                    # こっそり 近づく
                    self.velocity_x = 0.5 if dx > 0 else -0.5
                elif phase < 50:
                    # 止まって 気まずい
                    self.velocity_x = 0
                else:
                    # 少し 後退
                    self.velocity_x = -0.3 if dx > 0 else 0.3
        
        elif event_type in ['cold_response', 'distant_friend', 'unbothered', 'apathetic', 'ignoring_prank', 'mutual_disinterest']:
            # 冷淡な 反応 - ほとんど 動種類 ない
            update_emoji(50)
            
            if partner:
                dx = partner.x() - self.x()
                
                # たまに 等 向けるように 離れる
                if self.event_frame % 60 < 20:
                    self.velocity_x = -0.3 if dx > 0 else 0.3
                else:
                    self.velocity_x = 0
        
        elif event_type in ['broken_friendship', 'hostile_friend', 'hate_pranks', 'mutual_hatred', 'hateful_envy']:
            # 敵対的 関係 - お互い 対峙しながら 威嚇
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 70
                if phase < 20:
                    # 威嚇的として 近づく
                    self.velocity_x = 1.5 if dx > 0 else -1.5
                elif phase < 30:
                    # 威嚇 ジャンプ
                    self.velocity_x = 0
                    if phase == 20 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 50:
                    # 後退や
                    self.velocity_x = -1.2 if dx > 0 else 1.2
                else:
                    self.velocity_x = 0
        
        elif event_type in ['flirty_tease', 'confused_by_prank', 'testing_patience', 'testing_trust']:
            # いたずら+反応 - いたずらして 反応 見る
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 60
                if phase < 20:
                    # いたずらしに 近づく
                    self.velocity_x = 1.5 if dx > 0 else -1.5
                elif phase < 35:
                    # いたずら ジャンプ
                    self.velocity_x = 0
                    if phase == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 50:
                    # 逃げ
                    self.velocity_x = -2.0 if dx > 0 else 2.0
                else:
                    self.velocity_x = 0
        
        elif event_type in ['mentor_admire', 'unnoticed_trust', 'jealous_friend', 'competitive_admire']:
            # 複合 感情 - 様々な モーション 混合
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 90
                if phase < 30:
                    # 近づく
                    if abs(dx) > self.size * 0.7:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                elif phase < 45:
                    self.velocity_x = 0
                    if phase == 35 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                elif phase < 70:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    self.velocity_x = 0
        
        # ========== 基本イベント (マッチされ ない 場合) ==========
        else:
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 基本 相互作用: 近づいて 後退や
                phase = self.event_frame % 60
                if phase < 25:
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                    else:
                        self.velocity_x = 0
                elif phase < 35:
                    self.velocity_x = 0
                    if phase == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
                else:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
        
        # イベント 終了 チェック
        if self.event_frame >= self.event_duration:
            self.end_long_event()
    
    def end_long_event(self):
        """長い イベント 終了"""
        if not self.in_event:
            return
            
        print(f"[長い イベント] {self.event_type} 終了 ({self.char_id})")
        
        self.in_event = False
        self.event_type = None
        self.event_partner = None
        self.event_frame = 0
        self.event_duration = 0
        self.event_data = {}
        
        # ランダム 方向として 移動 再開
        self.velocity_x = random.choice([-2, -1.5, 1.5, 2])
        self.facing_right = self.velocity_x > 0
    
    def closeEvent(self, event):
        self.timer.stop()
        # GIF movie 整理
        if self.gif_movie:
            self.gif_movie.stop()
            self.gif_movie = None
        event.accept()


class CharacterCard(QFrame):
    """キャラクター カードウィジェット - CSS スペックベース"""
    remove_clicked = pyqtSignal(int)
    change_image_clicked = pyqtSignal(int)
    change_scale_clicked = pyqtSignal(int)
    change_bubble_color_clicked = pyqtSignal(int)
    change_relationships_clicked = pyqtSignal(int)
    change_dialogues_clicked = pyqtSignal(int)
    change_personality_clicked = pyqtSignal(int)
    name_changed = pyqtSignal(int, str)
    catchphrase_changed = pyqtSignal(int, str)
    toggle_active = pyqtSignal(int, bool)
    batch_toggle_clicked = pyqtSignal()  # トグル 右クリック時に複数 有効化 管理
    
    def __init__(self, char_id, image_path, name="", is_active=True, catchphrase=""):
        super().__init__()
        self.char_id = char_id
        self.image_path = image_path
        self.char_name = name if name else f"キャラクター {char_id + 1}"
        self.is_active = is_active
        self.catchphrase = catchphrase if catchphrase else "キャッチフレーズを 入力してください"
        
        self.setFrameStyle(QFrame.NoFrame)
        self.setStyleSheet("""
            CharacterCard {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 16px;
                margin: 5px;
            }
        """)
        
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(14, 14, 14, 14)
        main_layout.setSpacing(12)
        
        # ===== 上部: 画像 領域 + 情報 領域 =====
        top_section = QHBoxLayout()
        top_section.setSpacing(14)
        top_section.setAlignment(Qt.AlignBottom)  # 下部 ソート
        
        # --- 左: 画像 コンテナ (165x156) ---
        self.image_container = QFrame()
        self.image_container.setFixedSize(165, 156)
        self.image_container.setStyleSheet("""
            QFrame {
                background-color: #E8F5EE;
                border: none;
                border-radius: 10px;
            }
        """)
        
        # 画像 コンテナ 内部 レイアウト
        img_layout = QVBoxLayout(self.image_container)
        img_layout.setContentsMargins(10, 10, 10, 10)
        img_layout.setSpacing(6)
        
        # トグル + 画像変更 ボタン 行 (ラベルなし)
        toggle_row = QHBoxLayout()
        toggle_row.setSpacing(8)
        
        # トグル スイッチ
        self.active_toggle = ToggleSwitch(checked=self.is_active)
        self.active_toggle.toggled.connect(self.on_toggle)
        self.active_toggle.rightClicked.connect(self.batch_toggle_clicked.emit)  # 右クリック 接続
        
        # OFF ラベル (トグル 横に 背景 なく)
        self.toggle_label = QLabel("ON" if self.is_active else "OFF")
        self.toggle_label.setStyleSheet(f"""
            background: transparent;
            color: {'#5A9C85' if self.is_active else '#536E6C'};
            font-size: 12px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        
        toggle_row.addWidget(self.active_toggle)
        toggle_row.addWidget(self.toggle_label)
        toggle_row.addStretch()
        
        # 画像変更 ボタン (25x25, 円形, 白色 背景, 絵文字)
        change_img_btn = QPushButton()
        change_img_btn.setFixedSize(25, 25)
        change_img_btn.setCursor(Qt.PointingHandCursor)
        change_img_btn.clicked.connect(lambda: self.change_image_clicked.emit(self.char_id))
        change_img_btn.setStyleSheet("""
            QPushButton {
                background-color: #FFFFFF;
                border: none;
                border-radius: 12px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
        """)
        # 絵文字 効果
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(4)
        shadow.setOffset(0, 1)
        shadow.setColor(QColor("#BFC8C4"))
        change_img_btn.setGraphicsEffect(shadow)
        self._set_svg_icon(change_img_btn, SVG_IMAGE_CHANGE, 14)
        toggle_row.addWidget(change_img_btn)
        
        img_layout.addLayout(toggle_row)
        
        # キャラクター 画像 (背景 透明)
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setStyleSheet("background: transparent;")
        
        if image_path.lower().endswith('.gif'):
            # GIFである 場合 PILで 最初のフレーム 抽出
            try:
                from PIL import Image as PILImage
                from io import BytesIO
                gif = PILImage.open(image_path)
                gif.seek(0)
                frame = gif.convert('RGBA')
                data = BytesIO()
                frame.save(data, format='PNG')
                data.seek(0)
                pixmap = QPixmap()
                pixmap.loadFromData(data.read())
            except Exception as e:
                print(f"[GIF 読み込み 失敗] {e}")
                pixmap = QPixmap(image_path)
        else:
            pixmap = QPixmap(image_path)
        
        if not pixmap.isNull():
            pixmap = pixmap.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.image_label.setPixmap(pixmap)
        
        img_layout.addWidget(self.image_label, 1)
        
        # 無効化 オーバーレイ（全体 覆う)
        self.inactive_overlay = QFrame(self.image_container)
        self.inactive_overlay.setGeometry(0, 0, 165, 156)
        self.inactive_overlay.setStyleSheet("""
            background-color: rgba(165, 181, 175, 0.88);
            border-radius: 9px;
        """)
        self.inactive_overlay.setVisible(not self.is_active)
        self.inactive_overlay.raise_()
        # トグルは オーバーレイ 上に
        self.active_toggle.raise_()
        
        top_section.addWidget(self.image_container)
        
        # --- 右: 情報 + ボタン 領域 ---
        info_layout = QVBoxLayout()
        info_layout.setSpacing(6)
        
        # キャッチフレーズ (クリック 可能)
        self.catchphrase_label = QLabel(self.catchphrase)
        self.catchphrase_label.setStyleSheet(f"""
            background: transparent;
            color: #7BAF9A;
            font-size: 13px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        self.catchphrase_label.setCursor(Qt.PointingHandCursor)
        self.catchphrase_label.mousePressEvent = self.edit_catchphrase
        info_layout.addWidget(self.catchphrase_label)
        
        # 名前 + ペン アイコン
        name_row = QHBoxLayout()
        name_row.setSpacing(6)
        
        self.name_label = QLabel(self.char_name)
        self.name_label.setStyleSheet(f"""
            background: transparent;
            color: #3D7A5F;
            font-size: 20px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        
        # ペン アイコン ボタン
        edit_btn = QPushButton()
        edit_btn.setFixedSize(22, 22)
        edit_btn.setCursor(Qt.PointingHandCursor)
        edit_btn.clicked.connect(self.edit_name)
        edit_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(101, 202, 162, 0.2);
                border-radius: 4px;
            }
        """)
        self._set_svg_icon(edit_btn, SVG_PEN, 18)
        
        name_row.addWidget(self.name_label)
        name_row.addWidget(edit_btn)
        name_row.addStretch()
        info_layout.addLayout(name_row)
        
        info_layout.addStretch()
        
        # セリフ&性格 設定 ボタン (関係 設定 5px 上記)
        personality_btn = QPushButton("キャラクターセリフ&&性格設定")
        personality_btn.setFixedHeight(40)
        personality_btn.setCursor(Qt.PointingHandCursor)
        personality_btn.clicked.connect(lambda: self.change_personality_clicked.emit(self.char_id))
        personality_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #349971;
                border: none;
                border-radius: 12px;
                padding: 6px 10px;
                font-size: 13px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        info_layout.addWidget(personality_btn)
        
        info_layout.addSpacing(5)  # 関係 設定 ボタンと 5px 間隔
        
        # 関係 設定 ボタン (画像 ボックスと 以下 ソート)
        relation_btn = QPushButton("キャラクター間感情設定")
        relation_btn.setFixedHeight(40)
        relation_btn.setCursor(Qt.PointingHandCursor)
        relation_btn.clicked.connect(lambda: self.change_relationships_clicked.emit(self.char_id))
        relation_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #8ECFB5;
                color: #FFFFFF;
                border: none;
                border-radius: 12px;
                padding: 6px 10px;
                font-size: 13px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #7BC4A8;
            }}
        """)
        info_layout.addWidget(relation_btn)
        
        top_section.addLayout(info_layout, 1)
        main_layout.addLayout(top_section)
        
        # ===== 下部: ボタン 行 (吹き出し, サイズ, 削除) =====
        bottom_row = QHBoxLayout()
        bottom_row.setSpacing(5)
        
        # 吹き出し ボタン
        bubble_btn = QPushButton("吹き出し")
        bubble_btn.setFixedHeight(28)
        bubble_btn.setFixedWidth(90)
        bubble_btn.setCursor(Qt.PointingHandCursor)
        bubble_btn.clicked.connect(lambda: self.change_bubble_color_clicked.emit(self.char_id))
        bubble_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #349971;
                border: 1px solid #C5E8D8;
                border-radius: 14px;
                padding: 4px 10px 4px 8px;
                font-size: 14px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
                text-align: left;
            }}
            QPushButton:hover {{
                background-color: #E8F5EE;
            }}
        """)
        self._set_button_icon_with_text(bubble_btn, SVG_BUBBLE_SETTING, "吹き出し")
        bottom_row.addWidget(bubble_btn)
        
        # サイズ 調節 ボタン
        self.scale_btn = QPushButton("100%")
        self.scale_btn.setFixedHeight(28)
        self.scale_btn.setFixedWidth(70)
        self.scale_btn.setCursor(Qt.PointingHandCursor)
        self.scale_btn.clicked.connect(lambda: self.change_scale_clicked.emit(self.char_id))
        self._update_scale_btn_style(14)
        self._set_button_icon_with_text(self.scale_btn, SVG_SCALE, "100%")
        bottom_row.addWidget(self.scale_btn)
        
        bottom_row.addStretch()
        
        # キャラクター削除 ボタン (緑色, ホバー時 赤い色)
        delete_btn = QPushButton(" キャラクター削除")
        delete_btn.setFixedHeight(28)
        delete_btn.setCursor(Qt.PointingHandCursor)
        delete_btn.clicked.connect(lambda: self.remove_clicked.emit(self.char_id))
        delete_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: white;
                color: #349971;
                border: 1px solid #349971;
                border-radius: 14px;
                padding: 4px 14px;
                font-size: 14px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #FFF0F0;
                border-color: #E57373;
                color: #E57373;
            }}
        """)
        self._set_svg_icon(delete_btn, SVG_TRASH, 11)
        bottom_row.addWidget(delete_btn)
        
        main_layout.addLayout(bottom_row)
        self.setLayout(main_layout)
    
    def _set_svg_icon(self, button, svg_data, size):
        """SVG データで ボタン アイコン 設定 (比率維持)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 元の サイズ 取得
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 比率維持しながら sizeに 合う スケール
            if orig_w >= orig_h:
                scale = size / orig_w
                new_w = size
                new_h = int(orig_h * scale)
            else:
                scale = size / orig_h
                new_h = size
                new_w = int(orig_w * scale)
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
    
    def _set_button_icon_with_text(self, button, svg_data, text):
        """SVG アイコン + テキスト ボタン 設定 (比率維持)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 元の サイズ 取得
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 高く 12px 基準として スケール
            target_size = 12
            if orig_w >= orig_h:
                scale = target_size / orig_w
                new_w = target_size
                new_h = max(1, int(orig_h * scale))
            else:
                scale = target_size / orig_h
                new_h = target_size
                new_w = max(1, int(orig_w * scale))
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
        button.setText(text)

    def _update_scale_btn_style(self, font_size):
        """サイズ ボタン スタイル アップデート"""
        self.scale_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #349971;
                border: 1px solid #C5E8D8;
                border-radius: 14px;
                padding: 4px 8px 4px 4px;
                font-size: {font_size}px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
                text-align: left;
            }}
            QPushButton:hover {{
                background-color: #E8F5EE;
            }}
        """)

    def update_scale_display(self, scale_percent):
        """サイズ 表示 アップデート"""
        text = f"{scale_percent}%"
        # 1000% 以上は フォント サイズ 縮小
        font_size = 11 if scale_percent >= 1000 else 14
        self._update_scale_btn_style(font_size)
        self.scale_btn.setText(text)
        self._set_button_icon_with_text(self.scale_btn, SVG_SCALE, text)
        self.scale_btn.update()  # 画面 更新 強制
        print(f"[CharacterCard] サイズ ボタン テキスト 変更: {text}")
    
    def on_toggle(self, checked):
        """トグル 状態 変更"""
        self.is_active = checked
        self.toggle_label.setText("ON" if checked else "OFF")
        self.toggle_label.setStyleSheet(f"""
            background: transparent;
            color: {'#5A9C85' if checked else '#536E6C'};
            font-size: 12px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        # オーバーレイ 表示/非表示
        self.inactive_overlay.setVisible(not checked)
        self.toggle_active.emit(self.char_id, checked)
    
    def set_active(self, active):
        """外部から 有効化 状態 設定"""
        self.is_active = active
        self.active_toggle.setChecked(active)
        self.toggle_label.setText("ON" if active else "OFF")
        self.toggle_label.setStyleSheet(f"""
            background: transparent;
            color: {'#5A9C85' if active else '#536E6C'};
            font-size: 12px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        # オーバーレイ 表示/非表示
        self.inactive_overlay.setVisible(not active)
    
    def edit_name(self):
        """名前編集 ダイアログ"""
        dialog = NameEditDialog(self.char_name, self)
        if dialog.exec_() == QDialog.Accepted:
            text = dialog.get_name()
            if text:
                self.char_name = text
                self.name_label.setText(text)
                self.name_changed.emit(self.char_id, text)
    
    def edit_catchphrase(self, event):
        """キャッチフレーズ 編集 ダイアログ"""
        from PyQt5.QtWidgets import QInputDialog
        text, ok = QInputDialog.getText(self, 'キャッチフレーズ 編集', 'キャッチフレーズを 入力してください:', 
                                       text=self.catchphrase if self.catchphrase != "キャッチフレーズを 入力してください" else "")
        if ok:
            self.catchphrase = text if text else "キャッチフレーズを 入力してください"
            self.catchphrase_label.setText(self.catchphrase)
            self.catchphrase_changed.emit(self.char_id, self.catchphrase)
    
    def update_image(self, image_path):
        """画像 アップデート (GIFである 場合 最初のフレーム 表示)"""
        self.image_path = image_path
        
        if image_path.lower().endswith('.gif'):
            # GIFである 場合 PILで 最初のフレーム 抽出
            try:
                from PIL import Image as PILImage
                from io import BytesIO
                gif = PILImage.open(image_path)
                gif.seek(0)
                frame = gif.convert('RGBA')
                data = BytesIO()
                frame.save(data, format='PNG')
                data.seek(0)
                pixmap = QPixmap()
                pixmap.loadFromData(data.read())
            except Exception as e:
                print(f"[GIF 読み込み 失敗] {e}")
                pixmap = QPixmap(image_path)
        else:
            pixmap = QPixmap(image_path)
        
        if not pixmap.isNull():
            pixmap = pixmap.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.image_label.setPixmap(pixmap)


class AIDialogueViewDialog(QDialog):
    """生成されたセリフ閲覧/削除 ダイアログ"""
    def __init__(self, char_id, char_name, char_names=None, parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.char_names = char_names or {}  # {char_id: name}
        
        # MainWindow 参照 探す
        self.main_window = None
        p = self.parent()
        while p:
            if hasattr(p, 'dialogues') and hasattr(p, 'character_data'):
                self.main_window = p
                break
            p = p.parent()
        
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}の生成されたセリフ")
        self.setMinimumSize(500, 500)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 10px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(10)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # タイトル
        title = QLabel(f"{self.char_name}の生成されたセリフ目録")
        title.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 18px; font-weight: 700; font-family: 'Pretendard JP', 'Meiryo', sans-serif;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # スクロール 領域
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                background-color: white;
            }
        """)
        
        self.scroll_content = QWidget()
        self.scroll_content.setStyleSheet("background-color: white;")
        self.scroll_layout = QVBoxLayout()
        self.scroll_layout.setSpacing(5)
        self.scroll_layout.setContentsMargins(10, 10, 10, 10)
        
        self.load_dialogues()
        
        self.scroll_content.setLayout(self.scroll_layout)
        scroll.setWidget(self.scroll_content)
        layout.addWidget(scroll, 1)
        
        # ボタン 領域
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        # セリフ追加 ボタン
        add_btn = QPushButton("セリフ追加")
        add_btn.clicked.connect(self.add_dialogue)
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 10px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
        """)
        btn_layout.addWidget(add_btn)
        
        # 閉じる ボタン
        close_btn = QPushButton("閉じる")
        close_btn.clicked.connect(self.accept)
        btn_layout.addWidget(close_btn)
        
        layout.addLayout(btn_layout)
        
        self.setLayout(layout)
    
    def load_dialogues(self):
        """セリフ リスト 読み込み"""
        # 既存 ウィジェット 削除
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                self.clear_layout(item.layout())
        
        global _ai_dialogues_cache
        cache = _ai_dialogues_cache.get(self.char_id, {})
        
        if not cache:
            empty_label = QLabel("生成されたセリフがありません。")
            empty_label.setStyleSheet("color: #888; font-style: italic; font-weight: 700; padding: 20px;")
            empty_label.setAlignment(Qt.AlignCenter)
            self.scroll_layout.addWidget(empty_label)
            self.scroll_layout.addStretch()
            return
        
        # 基本セリフ (solo + fallback 合わせる)
        solo = cache.get('solo', [])
        fallback = cache.get('fallback', [])
        basic_dialogues = solo + fallback
        if basic_dialogues:
            self.add_section("基本セリフ", basic_dialogues, 'solo')
        
        # 相互作用 セリフ (キャラクター別に 分離)
        interaction = cache.get('interaction', {})
        if interaction and isinstance(interaction, dict):
            for other_key, dialogues in interaction.items():
                if isinstance(dialogues, list) and dialogues:
                    # キーに合わせて セクション タイトル 決定
                    if other_key == 'default':
                        section_title = "相互作用 セリフ (な般)"
                    else:
                        # キャラクター 名前が キーである 場合 (新形式)
                        # または キャラクター IDが キーである 場合 (旧形式)
                        try:
                            other_char_id = int(other_key)
                            other_name = self.char_names.get(other_char_id, f"キャラクター {other_char_id + 1}")
                        except (ValueError, TypeError):
                            # 数字が でなければ キャラクター 名前として みなす
                            other_name = str(other_key)
                        section_title = f"↔ {other_name}"
                    
                    self.add_section(section_title, dialogues, f'interaction_{other_key}')
        
        self.scroll_layout.addStretch()
    
    def add_section(self, title, dialogues, section_key):
        """セクション 追加"""
        # セクション ヘッダー
        header = QLabel(f"▸ {title} ({len(dialogues)}個)")
        header.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; font-family: 'Pretendard JP', 'Meiryo', sans-serif; color: #5A9C85; margin-top: 10px;")
        self.scroll_layout.addWidget(header)
        
        # セリフ リスト
        for i, dialogue in enumerate(dialogues):
            row = QHBoxLayout()
            row.setSpacing(5)
            
            # セリフ テキスト (インライン編集可能)
            text_edit = QLineEdit(dialogue)
            text_edit.setStyleSheet("""
                QLineEdit {
                    background-color: #F5F5F5;
                    padding: 8px 12px;
                    border-radius: 10px;
                    color: #333;
                    font-size: 13px;
                    font-weight: 700;
                    border: 1px solid transparent;
                }
                QLineEdit:focus {
                    background-color: white;
                    border: 1px solid #8ECFB5;
                }
            """)
            # フォーカス失うと 自動 保存
            text_edit.editingFinished.connect(
                lambda s=section_key, idx=i, edit=text_edit: self.save_dialogue_inline(s, idx, edit)
            )
            row.addWidget(text_edit, 1)
            
            # 削除 ボタン
            del_btn = QPushButton("✕")
            del_btn.setFixedSize(28, 28)
            del_btn.setStyleSheet("""
                QPushButton {
                    background-color: #FFB5BA;
                    color: white;
                    font-size: 13px;
                    font-weight: 700;
                    padding: 0px;
                    border-radius: 10px;
                }
                QPushButton:hover {
                    background-color: #FFA5AB;
                }
            """)
            del_btn.clicked.connect(lambda checked, s=section_key, idx=i: self.delete_dialogue(s, idx))
            row.addWidget(del_btn)
            
            self.scroll_layout.addLayout(row)
    
    def add_dialogue(self):
        """セリフ 手動 追加 - 種類 選択ダイアログ"""
        # セリフ追加 ダイアログ
        add_dialog = QDialog(self)
        add_dialog.setWindowTitle("セリフ追加")
        add_dialog.setFixedWidth(400)
        add_dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
            }
            QLabel {
                color: #5A9C85;
                font-weight: 700;
            }
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 8px;
                padding: 8px 12px;
                font-size: 13px;
            }
            QComboBox:hover {
                border-color: #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #D4F4DD;
            }
            QTextEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 8px;
                padding: 8px;
                font-size: 13px;
            }
            QTextEdit:focus {
                border-color: #8ECFB5;
            }
        """)
        
        layout = QVBoxLayout(add_dialog)
        layout.setSpacing(12)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # セリフ 種類 選択
        type_label = QLabel("セリフ 種類")
        layout.addWidget(type_label)
        
        type_combo = QComboBox()
        type_combo.addItem("基本セリフ", "solo")
        
        # 他の キャラクター リスト 追加
        if self.char_names:
            for other_id, other_name in self.char_names.items():
                if other_id != self.char_id:
                    type_combo.addItem(f"↔ {other_name}", f"interaction_{other_id}")
        
        layout.addWidget(type_combo)
        
        # セリフ 入力
        text_label = QLabel("セリフ 内容")
        layout.addWidget(text_label)
        
        text_edit = QTextEdit()
        text_edit.setPlaceholderText("セリフを 入力してください...")
        text_edit.setMinimumHeight(100)
        text_edit.setMaximumHeight(150)
        layout.addWidget(text_edit)
        
        # ボタン
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        cancel_btn = QPushButton("キャンセル")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #D0D0D0;
            }
        """)
        cancel_btn.clicked.connect(add_dialog.reject)
        btn_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("追加")
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
        """)
        btn_layout.addWidget(save_btn)
        
        layout.addLayout(btn_layout)
        
        def do_save():
            text = text_edit.toPlainText().strip()
            if not text:
                QMessageBox.warning(add_dialog, "入力必要", "セリフ内容を入力してください。")
                return
            
            dialogue_type = type_combo.currentData()
            
            # MainWindowの dialoguesに 追加 (手動 セリフ リスト)
            # DialogueDialogと 同なの 'char_X' 形式 使用
            if self.main_window:
                if self.char_id not in self.main_window.dialogues:
                    self.main_window.dialogues[self.char_id] = {'基本': []}
                
                char_dialogues = self.main_window.dialogues[self.char_id]
                
                if dialogue_type == "solo":
                    # 基本セリフに 追加
                    if '基本' not in char_dialogues:
                        char_dialogues['基本'] = []
                    char_dialogues['基本'].append(text)
                elif dialogue_type.startswith("interaction_"):
                    # 相互作用 セリフに 追加 - 'char_X' 形式として 保存
                    other_id = dialogue_type.replace("interaction_", "")
                    try:
                        other_id_int = int(other_id)
                        other_key = f'char_{other_id_int}'
                    except ValueError:
                        other_key = other_id
                    
                    if other_key not in char_dialogues:
                        char_dialogues[other_key] = []
                    char_dialogues[other_key].append(text)
                
                # CharacterWidgetの dialoguesも 同期
                for char in self.main_window.characters:
                    if char.char_id == self.char_id:
                        char.dialogues = char_dialogues.copy()
                        break
            
            # AI キャッシュにも 追加 (互換性 維持 + セリフ 表示用)
            # AI キャッシュは int キー 使用
            global _ai_dialogues_cache
            
            if self.char_id not in _ai_dialogues_cache:
                _ai_dialogues_cache[self.char_id] = {
                    'solo': [],
                    'interaction': {},
                    'fallback': [],
                    'generated_at': time.time()
                }
            
            cache = _ai_dialogues_cache[self.char_id]
            
            if dialogue_type == "solo":
                if 'solo' not in cache:
                    cache['solo'] = []
                cache['solo'].append(text)
            elif dialogue_type.startswith("interaction_"):
                other_key = dialogue_type.replace("interaction_", "")
                try:
                    other_key = int(other_key)
                except ValueError:
                    pass
                
                if 'interaction' not in cache:
                    cache['interaction'] = {}
                if other_key not in cache['interaction']:
                    cache['interaction'][other_key] = []
                cache['interaction'][other_key].append(text)
            
            cache['generated_at'] = time.time()
            
            # リスト 更新
            self.load_dialogues()
            
            # 親 ウィンドウから 保存 呼び出し
            if self.parent():
                try:
                    self.parent().save_characters()
                except:
                    pass
            
            add_dialog.accept()
        
        save_btn.clicked.connect(do_save)
        
        add_dialog.exec_()
    
    def delete_dialogue(self, section_key, index):
        """セリフ 削除"""
        global _ai_dialogues_cache
        cache = _ai_dialogues_cache.get(self.char_id, {})
        
        if section_key.startswith('interaction_'):
            # 相互作用 セリフ (interaction_default, interaction_0 等)
            other_id_str = section_key.replace('interaction_', '')
            interaction = cache.get('interaction', {})
            
            # キー マッチ 試行 (文字列 → int 変換)
            actual_key = None
            if other_id_str == 'default':
                actual_key = 'default'
            else:
                try:
                    int_key = int(other_id_str)
                    if int_key in interaction:
                        actual_key = int_key
                    elif other_id_str in interaction:
                        actual_key = other_id_str
                except ValueError:
                    if other_id_str in interaction:
                        actual_key = other_id_str
            
            if actual_key is not None and actual_key in interaction:
                dialogues = interaction[actual_key]
                if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                    dialogues.pop(index)
                    print(f"[セリフ 削除] char_id={self.char_id}, key={actual_key}, index={index}")
        elif section_key == 'solo':
            # 基本セリフ (solo + fallback)
            solo = cache.get('solo', [])
            fallback = cache.get('fallback', [])
            
            if index < len(solo):
                solo.pop(index)
            else:
                fallback_idx = index - len(solo)
                if 0 <= fallback_idx < len(fallback):
                    fallback.pop(fallback_idx)
        else:
            # その他
            dialogues = cache.get(section_key, [])
            if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                dialogues.pop(index)
        
        # UI 更新
        self.load_dialogues()
    
    def save_dialogue_inline(self, section_key, index, line_edit):
        """インライン編集 保存 (フォーカス失うと 自動 保存)"""
        new_text = line_edit.text().strip()
        if not new_text:
            return
        
        global _ai_dialogues_cache
        cache = _ai_dialogues_cache.get(self.char_id, {})
        
        if section_key.startswith('interaction_'):
            # 相互作用 セリフ (interaction_default, interaction_0 等)
            other_id_str = section_key.replace('interaction_', '')
            interaction = cache.get('interaction', {})
            
            # キー マッチ 試行 (文字列 → int 変換)
            actual_key = None
            if other_id_str == 'default':
                actual_key = 'default'
            else:
                try:
                    int_key = int(other_id_str)
                    if int_key in interaction:
                        actual_key = int_key
                    elif other_id_str in interaction:
                        actual_key = other_id_str
                except ValueError:
                    if other_id_str in interaction:
                        actual_key = other_id_str
            
            if actual_key is not None and actual_key in interaction:
                dialogues = interaction[actual_key]
                if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                    dialogues[index] = new_text
                    print(f"[セリフ 編集] char_id={self.char_id}, key={actual_key}, index={index}, text={new_text}")
        elif section_key == 'solo':
            # 基本セリフ (solo + fallback)
            solo = cache.get('solo', [])
            fallback = cache.get('fallback', [])
            
            if index < len(solo):
                solo[index] = new_text
            else:
                fallback_idx = index - len(solo)
                if 0 <= fallback_idx < len(fallback):
                    fallback[fallback_idx] = new_text
        else:
            # その他
            dialogues = cache.get(section_key, [])
            if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                dialogues[index] = new_text
    
    def clear_layout(self, layout):
        """レイアウト 内部 ウィジェットすべて 削除"""
        while layout.count():
            item = layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                self.clear_layout(item.layout())


class PersonalityDialog(QDialog):
    """キャラクター 性格 設定 ダイアログ (セリフ + AI 性格 + ストーリー 統合)"""
    def __init__(self, char_id, char_name, all_characters, current_personality, current_nicknames, current_dialogues, current_stories=None, current_background_story="", parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.all_characters = all_characters  # {char_id: name}
        self.personality = current_personality
        self.background_story = current_background_story  # キャラクター背景ストーリー
        self.nicknames = current_nicknames.copy() if current_nicknames else {}
        self.dialogues = current_dialogues.copy() if current_dialogues else ['', '', '']
        self.stories = current_stories.copy() if current_stories else {}
        self.nickname_edits = {}
        self.story_edits = {}
        self.dialogue_edits = []
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}のセリフ&性格")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setMinimumSize(500, 700)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        from PyQt5.QtGui import QPainterPath, QRegion
        
        # メイン コンテナ (白色 背景, ボーダー)
        self.container = QWidget(self)
        self.container.setObjectName("mainContainer")
        self.container.setStyleSheet("""
            #mainContainer {
                background-color: white;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                background: transparent;
            }
            QLineEdit, QTextEdit {
                background-color: white;
                border: 1px solid #9DD4BA;
                border-radius: 12px;
                padding: 10px 12px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                color: #317C75;
            }
            QLineEdit::placeholder, QTextEdit::placeholder {
                color: #9DD4BA;
            }
            QLineEdit:focus, QTextEdit:focus {
                border: 2px solid #8ECFB5;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 12px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QScrollBar:vertical {
                background: transparent;
                width: 8px;
                margin: 0;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 4px;
                min-height: 30px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0;
            }
        """)
        
        # メイン レイアウト (コンテナ用)
        main_layout = QVBoxLayout(self.container)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(self.container)
        
        # === ヘッダー (タイトル + Xボタン) ===
        header_widget = QWidget()
        header_widget.setStyleSheet("background-color: transparent;")
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(25, 20, 20, 10)
        
        header_layout.addStretch()
        
        # タイトル
        title = QLabel(f"{self.char_name}のセリフ&性格")
        title.setStyleSheet("""
            font-size: 20px; 
            font-weight: 700; 
            color: #317C75;
            background: transparent;
        """)
        title.setAlignment(Qt.AlignCenter)
        header_layout.addWidget(title)
        
        header_layout.addStretch()
        
        # X ボタン (クレジットと 同なの SVG)
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        header_layout.addWidget(close_btn)
        
        main_layout.addWidget(header_widget)
        
        # スクロール 領域
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("QScrollArea { border: none; background-color: transparent; }")
        
        content = QWidget()
        content.setStyleSheet("background-color: transparent;")
        layout = QVBoxLayout(content)
        layout.setSpacing(8)
        layout.setContentsMargins(25, 10, 25, 25)
        
        # === 基本セリフ セクション ===
        dialogue_label = QLabel("基本 セリフ（話し方 参考用）")
        dialogue_label.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #317C75;
            margin-top: 5px;
        """)
        layout.addWidget(dialogue_label)

        dialogue_info = QLabel("入力していただいたセリフを基にキャラクターの話し方を把握します。（手動入力必要）")
        dialogue_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
        layout.addWidget(dialogue_info)
        
        # セリフ 入力 (3個)
        for i in range(3):
            edit = QLineEdit()
            edit.setPlaceholderText(f"セリフ {i+1}")
            edit.setMinimumHeight(40)
            if i < len(self.dialogues):
                text = self.dialogues[i]
                if text and text != '（任意）':
                    edit.setText(text)
            self.dialogue_edits.append(edit)
            layout.addWidget(edit)
        
        # === 性格 セクション ===
        ai_label = QLabel("性格")
        ai_label.setStyleSheet("""
            font-size: 15px; 
            font-weight: 700; 
            color: #317C75;
            margin-top: 12px;
        """)
        layout.addWidget(ai_label)
        
        ai_info = QLabel("性格についての説明を入力すると、キャラクターに合ったセリフが自動生成されます。")
        ai_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
        layout.addWidget(ai_info)
        
        self.personality_edit = QTextEdit()
        self.personality_edit.setPlaceholderText("セリフ 1")
        self.personality_edit.setText(self.personality)
        self.personality_edit.setFixedHeight(100)
        layout.addWidget(self.personality_edit)
        
        # === 背景 ストーリー セクション ===
        story_label = QLabel("背景ストーリー（任意）")
        story_label.setStyleSheet("""
            font-size: 15px; 
            font-weight: 700; 
            color: #317C75;
            margin-top: 12px;
        """)
        layout.addWidget(story_label)
        
        story_info = QLabel("キャラクターの背景やストーリーを入力するとセリフに反映されます。")
        story_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
        layout.addWidget(story_info)
        
        self.background_story_edit = QTextEdit()
        self.background_story_edit.setPlaceholderText("例: 料理人を夢見る学生、雨の日が好き")
        self.background_story_edit.setText(self.background_story)
        self.background_story_edit.setFixedHeight(70)
        layout.addWidget(self.background_story_edit)
        
        # === 呼び方 & ストーリー セクション ===
        other_chars = [(cid, name) for cid, name in self.all_characters.items() if cid != self.char_id]
        
        if other_chars:
            nickname_section_label = QLabel("呼び方・ストーリー")
            nickname_section_label.setStyleSheet("""
                font-size: 15px;
                font-weight: 700;
                color: #317C75;
                margin-top: 12px;
            """)
            layout.addWidget(nickname_section_label)

            nickname_info = QLabel("呼び方はコンマ(,)で区切って複数入力できます。")
            nickname_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
            layout.addWidget(nickname_info)
            
            for other_id, other_name in other_chars:
                # キャラクター 名前 ラベル
                char_header = QLabel(f"キャラクター名前{other_id + 1}" if other_name == f"キャラクター {other_id + 1}" else other_name)
                char_header.setStyleSheet("""
                    font-size: 13px; 
                    font-weight: 700; 
                    color: #317C75;
                    margin-top: 10px;
                """)
                layout.addWidget(char_header)
                
                # 呼び方 入力
                nickname_row = QHBoxLayout()
                nickname_row.setSpacing(10)
                nickname_label_small = QLabel("呼び方:")
                nickname_label_small.setFixedWidth(35)
                nickname_label_small.setStyleSheet("font-size: 13px; font-weight: 700; color: #5A9C85;")
                nickname_row.addWidget(nickname_label_small)
                
                nickname_edit = QLineEdit()
                nickname_edit.setMinimumHeight(38)
                nickname_edit.setText(self.nicknames.get(other_id, ""))
                self.nickname_edits[other_id] = nickname_edit
                nickname_row.addWidget(nickname_edit)
                layout.addLayout(nickname_row)
                
                # ストーリー 入力 （任意）
                story_row = QHBoxLayout()
                story_row.setSpacing(10)
                story_label_small = QLabel("ストーリー:")
                story_label_small.setFixedWidth(35)
                story_label_small.setStyleSheet("font-size: 13px; font-weight: 700; color: #5A9C85;")
                story_row.addWidget(story_label_small)
                
                story_edit = QLineEdit()
                story_edit.setMinimumHeight(38)
                story_edit.setText(self.stories.get(other_id, ""))
                self.story_edits[other_id] = story_edit
                story_row.addWidget(story_edit)
                layout.addLayout(story_row)
        
        # === セリフ 閲覧/初期化 ボタン (スクロール 内部 下部) ===
        layout.addSpacing(20)
        
        manage_btn_layout = QHBoxLayout()
        manage_btn_layout.setSpacing(10)
        
        view_btn = QPushButton("生成されたセリフ閲覧")
        view_btn.setStyleSheet("""
            QPushButton { 
                background-color: #C5E8D8; 
                color: #317C75; 
                font-weight: 700;
                padding: 10px 16px;
                border-radius: 12px;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #B5DBC8; }
        """)
        view_btn.clicked.connect(self.view_ai_dialogues)
        manage_btn_layout.addWidget(view_btn)
        
        reset_btn = QPushButton("セリフリセット")
        reset_btn.setStyleSheet("""
            QPushButton { 
                background-color: #FFD4D4; 
                color: #D35F5F; 
                font-weight: 700;
                padding: 10px 16px;
                border-radius: 12px;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #FFC4C4; }
        """)
        reset_btn.clicked.connect(self.reset_ai_dialogues)
        manage_btn_layout.addWidget(reset_btn)
        
        layout.addLayout(manage_btn_layout)
        
        layout.addStretch()
        
        scroll.setWidget(content)
        scroll.viewport().setStyleSheet("background-color: transparent;")
        main_layout.addWidget(scroll)
        
        # === 下部 ボタン 領域 (閉じる / 保存するのみ) ===
        btn_container = QWidget()
        btn_container.setStyleSheet("background-color: transparent;")
        btn_main_layout = QVBoxLayout(btn_container)
        btn_main_layout.setContentsMargins(25, 10, 25, 20)
        btn_main_layout.setSpacing(10)
        
        # 閉じる / 保存する ボタン
        action_btn_layout = QHBoxLayout()
        action_btn_layout.setSpacing(10)
        
        cancel_btn = QPushButton("閉じる")
        cancel_btn.setStyleSheet("""
            QPushButton { 
                background-color: #E8F5F0; 
                color: #5A9C85; 
                border: 1px solid #C5E8D8;
                font-weight: 700;
                padding: 14px 24px;
            }
            QPushButton:hover { background-color: #D8EBE4; }
        """)
        cancel_btn.clicked.connect(self.reject)
        
        save_btn = QPushButton("保存する")
        save_btn.setStyleSheet("""
            QPushButton { 
                background-color: #5A9C85; 
                color: white; 
                font-weight: 700;
                padding: 14px 24px;
            }
            QPushButton:hover { background-color: #4A8C75; }
        """)
        save_btn.clicked.connect(self.accept)
        
        action_btn_layout.addWidget(cancel_btn)
        action_btn_layout.addWidget(save_btn)
        btn_main_layout.addLayout(action_btn_layout)
        
        main_layout.addWidget(btn_container)
    
    def reset_ai_dialogues(self):
        """AI セリフ キャッシュ初期化"""
        from PyQt5.QtWidgets import QMessageBox
        
        # 確認 ダイアログ
        reply = QMessageBox.question(
            self,
            "生成されたセリフリセット",
            f"本当に{self.char_name}の生成されたセリフを初期化しますか？\nこの操作は元に戻せません。",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            global _ai_dialogues_cache
            if self.char_id in _ai_dialogues_cache:
                del _ai_dialogues_cache[self.char_id]
            
            QMessageBox.information(self, "初期化完了", f"{self.char_name}の生成されたセリフが初期化されました。")
    
    def export_character(self):
        """キャラクター データ バックアップ (JSONファイルで エクスポート)"""
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        import base64
        
        # 保存 パス 選択
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "キャラクターバックアップ",
            f"{self.char_name}_backup.json",
            "JSONファイル (*.json)"
        )
        
        if not file_path:
            return
        
        try:
            # 画像を base64で エンコーディング
            image_data = ""
            image_ext = ".png"
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'character_data'):
                main_window = main_window.parent()
            
            image_path = ""
            if main_window and self.char_id in main_window.character_data:
                char_data = main_window.character_data[self.char_id]
                image_path = char_data.get('image_path', '')
                if image_path and os.path.exists(image_path):
                    with open(image_path, 'rb') as f:
                        image_data = base64.b64encode(f.read()).decode('utf-8')
                    image_ext = os.path.splitext(image_path)[1]
                else:
                    print(f"[バックアップ] 画像 パス なし またはファイルなし: {image_path}")
            
            # 画像が なければ 直接 選択 オプション 提供
            if not image_data:
                reply = QMessageBox.question(
                    self,
                    "画像 なし",
                    "画像 ファイルが見つかりません.\n\n直接 画像を 選択しますか？",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                if reply == QMessageBox.Yes:
                    selected_path, _ = QFileDialog.getOpenFileName(
                        self,
                        f"{self.char_name} 画像選択",
                        "",
                        "画像 ファイル (*.png *.jpg *.jpeg *.gif *.bmp)"
                    )
                    if selected_path and os.path.exists(selected_path):
                        with open(selected_path, 'rb') as f:
                            image_data = base64.b64encode(f.read()).decode('utf-8')
                        image_ext = os.path.splitext(selected_path)[1]
                    else:
                        # 画像 なく バックアップするか 確認
                        reply2 = QMessageBox.question(
                            self,
                            "画像 なし",
                            "画像 なしでバックアップしますか？\n\n(読み込む際 画像を 再度選択する必要があります)",
                            QMessageBox.Yes | QMessageBox.No,
                            QMessageBox.No
                        )
                        if reply2 != QMessageBox.Yes:
                            return
                else:
                    # 画像 なく バックアップするか 確認
                    reply2 = QMessageBox.question(
                        self,
                        "画像 なし",
                        "画像 なしでバックアップしますか？\n\n(読み込む際 画像を 再度選択する必要があります)",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.No
                    )
                    if reply2 != QMessageBox.Yes:
                        return
            
            # 現在 ダイアログから 編集 中である 値 含む
            backup_data = {
                'version': '2.0',
                'backup_type': 'single_character',
                'char_name': self.char_name,
                'personality': self.personality_edit.toPlainText().strip(),
                'background_story': self.background_story_edit.toPlainText().strip(),
                'nicknames': self.get_nicknames(),
                'stories': self.get_stories(),
                'dialogues': self.get_dialogues(),
                'sample_dialogues': getattr(self, 'sample_dialogues', []),
                'image_data': image_data,
                'image_ext': image_ext,
            }
            
            # AI セリフ キャ試行 含む
            global _ai_dialogues_cache
            if self.char_id in _ai_dialogues_cache:
                cache = _ai_dialogues_cache[self.char_id]
                backup_data['ai_cache'] = {
                    'solo': cache.get('solo', []),
                    'interaction': cache.get('interaction', {}),
                    'fallback': cache.get('fallback', [])
                }
            
            # MainWindowから 追加 情報 取得
            if main_window and self.char_id in main_window.character_data:
                char_data = main_window.character_data[self.char_id]
                backup_data['scale'] = char_data.get('scale', 100)
                backup_data['bubble_color'] = char_data.get('bubble_color', '#81C784')
                backup_data['bubble_size'] = char_data.get('bubble_size', 100)
                backup_data['facing_direction'] = char_data.get('facing_direction', 'front')
                backup_data['is_active'] = char_data.get('is_active', True)
                backup_data['catchphrase'] = char_data.get('catchphrase', '')
            
            # JSONファイルで 保存
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, ensure_ascii=False, indent=2)
            
            # 詳細 完了 メッセージ
            has_image = "✅" if image_data else "❌"
            has_ai = "✅" if backup_data.get('ai_cache') else "❌"
            
            QMessageBox.information(self, "バックアップ完了", 
                f"✅ '{self.char_name}' バックアップ完了!\n\n"
                f"📦 含まれるデータ:\n"
                f"• 画像: {has_image}\n"
                f"• 名前/キャッチフレーズ\n"
                f"• 性格/背景 ストーリー\n"
                f"• AI 生成 セリフ: {has_ai}\n"
                f"• 手動 セリフ リスト\n"
                f"• サイズ/吹き出し/方向設定\n\n"
                f"📁 保存 位置:\n{file_path}")
            
        except Exception as e:
            QMessageBox.critical(self, "バックアップ 失敗", f"バックアップ中にエラーが発生しました。\n\n{str(e)}")
    
    def import_character(self):
        """キャラクター データ 読み込む (JSONファイルから 取得)"""
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        import base64
        
        # ファイル選択
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "キャラクター 読み込む",
            "",
            "JSONファイル (*.json)"
        )
        
        if not file_path:
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            # バージョン チェック
            version = backup_data.get('version', '1.0')
            
            # 確認 ポップアップ
            backup_name = backup_data.get('char_name', '不明')
            reply = QMessageBox.question(
                self,
                "キャラクター 読み込む",
                f"'{backup_name}' キャラクター データを 現在 キャラクターに 適用しますか？\n\n現在 キャラクターの データが 上書きされます。",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # UIに データ 適用
            self.personality_edit.setPlainText(backup_data.get('personality', ''))
            self.background_story_edit.setPlainText(backup_data.get('background_story', ''))
            
            # 呼び方 適用
            nicknames = backup_data.get('nicknames', {})
            for char_id_str, nickname in nicknames.items():
                try:
                    char_id = int(char_id_str)
                    if char_id in self.nickname_edits:
                        self.nickname_edits[char_id].setText(nickname)
                except (ValueError, KeyError):
                    pass
            
            # ストーリー 適用
            stories = backup_data.get('stories', {})
            for char_id_str, story in stories.items():
                try:
                    char_id = int(char_id_str)
                    if char_id in self.story_edits:
                        self.story_edits[char_id].setText(story)
                except (ValueError, KeyError):
                    pass
            
            # セリフ 適用
            dialogues = backup_data.get('dialogues', [])
            for i, edit in enumerate(self.dialogue_edits):
                if i < len(dialogues):
                    edit.setText(dialogues[i])
            
            # AI キャッシュ 適用 (interaction キーを intで 変換)
            if 'ai_cache' in backup_data:
                global _ai_dialogues_cache
                raw_interaction = backup_data['ai_cache'].get('interaction', {})
                converted_interaction = {}
                for k, v in raw_interaction.items():
                    try:
                        converted_interaction[int(k)] = v
                    except (ValueError, TypeError):
                        converted_interaction[k] = v
                
                _ai_dialogues_cache[self.char_id] = {
                    'solo': backup_data['ai_cache'].get('solo', []),
                    'interaction': converted_interaction,
                    'fallback': backup_data['ai_cache'].get('fallback', []),
                    'generated_at': time.time()
                }
            
            # 手動 セリフを AI キャッシュに 同期
            dialogues_for_sync = backup_data.get('dialogues', [])
            if isinstance(dialogues_for_sync, list):
                sync_dialogues_to_ai_cache(self.char_id, {'基本': dialogues_for_sync})
            elif isinstance(dialogues_for_sync, dict):
                sync_dialogues_to_ai_cache(self.char_id, dialogues_for_sync)
            
            # MainWindowに 追加 データ 適用
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'character_data'):
                main_window = main_window.parent()
            
            if main_window and self.char_id in main_window.character_data:
                char_data = main_window.character_data[self.char_id]
                
                # 画像 復元
                if backup_data.get('image_data'):
                    try:
                        image_ext = backup_data.get('image_ext', '.png')
                        # 新しい 画像 ファイル 保存
                        image_dir = os.path.join(os.path.expanduser("~"), ".kiwipet_images")
                        os.makedirs(image_dir, exist_ok=True)
                        new_image_path = os.path.join(image_dir, f"char_{self.char_id}_restored{image_ext}")
                        
                        image_bytes = base64.b64decode(backup_data['image_data'])
                        with open(new_image_path, 'wb') as f:
                            f.write(image_bytes)
                        
                        char_data['image_path'] = new_image_path
                    except Exception as e:
                        print(f"[バックアップ] 画像 復元失敗: {e}")
                
                # 他の設定 適用
                if 'scale' in backup_data:
                    char_data['scale'] = backup_data['scale']
                if 'bubble_color' in backup_data:
                    char_data['bubble_color'] = backup_data['bubble_color']
                if 'bubble_size' in backup_data:
                    char_data['bubble_size'] = backup_data['bubble_size']
                if 'facing_direction' in backup_data:
                    char_data['facing_direction'] = backup_data['facing_direction']
                if 'catchphrase' in backup_data:
                    char_data['catchphrase'] = backup_data['catchphrase']
            
            # 詳細 完了 メッセージ
            has_image = "✅" if backup_data.get('image_data') else "❌"
            has_ai = "✅" if backup_data.get('ai_cache') else "❌"
            
            QMessageBox.information(self, "読み込み完了", 
                f"'{backup_name}' データを 読み込みました。\n\n"
                f"💡 保存 ボタンを 押して 適用してください.")
            
        except json.JSONDecodeError:
            QMessageBox.critical(self, "読み込む 失敗", "正しいJSONファイルではありません。")
        except Exception as e:
            QMessageBox.critical(self, "読み込む 失敗", f"読み込み中にエラーが発生しました。\n\n{str(e)}")
    
    def view_ai_dialogues(self):
        """生成されたセリフ閲覧 ダイアログ 開く"""
        dialog = AIDialogueViewDialog(self.char_id, self.char_name, self.all_characters, self)
        dialog.exec_()
    
    def get_personality(self):
        return self.personality_edit.toPlainText().strip()
    
    def get_background_story(self):
        return self.background_story_edit.toPlainText().strip()
    
    def get_nicknames(self):
        result = {}
        for char_id, edit in self.nickname_edits.items():
            nickname = edit.text().strip()
            if nickname:
                result[char_id] = nickname
        return result
    
    def get_stories(self):
        result = {}
        for char_id, edit in self.story_edits.items():
            story = edit.text().strip()
            if story:
                result[char_id] = story
        return result
    
    def get_dialogues(self):
        result = []
        for edit in self.dialogue_edits:
            text = edit.text().strip()
            result.append(text if text else '')
        return result


class DialogueDialog(QDialog):
    """セリフ 設定 ダイアログ"""
    def __init__(self, char_id, char_name, all_characters, current_dialogues, parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.all_characters = all_characters  # {char_id: name}
        self.all_dialogues = current_dialogues  # 全体 セリフ 辞書
        self.dialogues = current_dialogues.get(char_id, {'基本': ['（任意）', '（任意）', '（任意）']})
        self.dialogue_inputs = {}
        self.current_target = '基本'  # 現在 選択された 対象 追跡
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}のセリフ設定")
        self.setMinimumSize(550, 500)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                border: none;
            }
            QComboBox, QLineEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 8px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                color: #5A9C85;
            }
            QComboBox:hover, QLineEdit:focus {
                border: 2px solid #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 6px solid #8ECFB5;
                width: 0px;
                height: 0px;
                margin-right: 8px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                selection-background-color: #E8F5EE;
                selection-color: #5A9C85;
                color: #5A9C85;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                padding: 10px;
                font-size: 14px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # タイトル
        title = QLabel(f"{self.char_name}のセリフ")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 22px;
            font-weight: 700;
            color: #5A9C85;
            padding: 10px;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
        """)
        
        # 対象 選択
        target_layout = QHBoxLayout()
        target_label = QLabel("対象:")
        target_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700; color: #5A9C85;")
        
        self.target_combo = QComboBox()
        self.target_combo.addItem("基本")
        for cid, cname in self.all_characters.items():
            if cid != self.char_id:
                # キャラクター 名前として 表示
                self.target_combo.addItem(cname, cid)
        self.target_combo.currentIndexChanged.connect(self.on_target_changed)
        
        target_layout.addWidget(target_label)
        target_layout.addWidget(self.target_combo, 1)
        
        # スクロール 領域 - きれいな 白色 背景
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                background-color: white;
                border-radius: 12px;
            }
        """)
        
        self.scroll_content = QWidget()
        self.scroll_content.setStyleSheet("background-color: white;")
        self.scroll_layout = QVBoxLayout()
        self.scroll_layout.setSpacing(10)
        self.scroll_layout.setContentsMargins(15, 15, 15, 15)
        
        self.scroll_content.setLayout(self.scroll_layout)
        scroll.setWidget(self.scroll_content)
        
        # 秒 セリフ 入力欄 生成
        self.load_dialogue_inputs('基本')
        
        # ボタン レイアウト
        button_layout = QHBoxLayout()
        
        # 保存 ボタン
        save_button = QPushButton("保存")
        save_button.clicked.connect(self.save_and_stay)
        save_button.setMinimumHeight(45)
        
        # 閉じる ボタン
        close_button = QPushButton("閉じる")
        close_button.clicked.connect(self.accept)
        close_button.setMinimumHeight(45)
        close_button.setStyleSheet("""
            QPushButton {
                background-color: #B8E6D0;
                color: white;
            }
            QPushButton:hover {
                background-color: #A5DBC3;
            }
        """)
        
        button_layout.addWidget(save_button)
        button_layout.addWidget(close_button)
        
        layout.addWidget(title)
        layout.addLayout(target_layout)
        layout.addWidget(scroll, 1)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
    
    def on_target_changed(self, index):
        """対象変更時 セリフ 入力欄 アップデート"""
        # 以前 対象の セリフ 保存
        old_target = self.current_target
        dialogues = []
        for input_widget in self.dialogue_inputs.get(old_target, []):
            text = input_widget.text().strip()
            dialogues.append(text if text else '（任意）')
        if dialogues:
            self.dialogues[old_target] = dialogues
        
        # 新しい 対象 設定
        if index == 0:
            self.current_target = '基本'
        else:
            target_data = self.target_combo.currentData()
            if target_data is not None:
                self.current_target = f'char_{target_data}'
            else:
                # currentDataが Noneなら インデックスで 計算
                self.current_target = '基本'
        
        # 新しい 対象の セリフ 読み込み
        self.load_dialogue_inputs(self.current_target)
    
    def save_current_dialogues(self):
        """現在 入力された セリフ 保存"""
        current_index = self.target_combo.currentIndex()
        if current_index == 0:
            target_key = '基本'
        else:
            target_data = self.target_combo.currentData()
            if target_data is not None:
                target_key = f'char_{target_data}'
            else:
                target_key = '基本'
        
        dialogues = []
        for input_widget in self.dialogue_inputs.get(target_key, []):
            text = input_widget.text().strip()
            # 空の 欄なら （任意）として 保存
            dialogues.append(text if text else '（任意）')
        
        self.dialogues[target_key] = dialogues
    
    def load_dialogue_inputs(self, target_key):
        """セリフ 入力欄 読み込み"""
        # 既存 ウィジェット 削除
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # セリフ 取得
        dialogues = self.dialogues.get(target_key, ['（任意）', '（任意）', '（任意）'])
        
        self.dialogue_inputs[target_key] = []
        
        for i, dialogue in enumerate(dialogues):
            row = QHBoxLayout()
            
            label = QLabel(f"セリフ {i+1}:")
            label.setMinimumWidth(60)
            label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700;")
            
            input_field = QLineEdit()
            
            # （任意）なら 空の 欄として, でなければ 内容 表示
            if dialogue == '（任意）':
                input_field.setText('')
                input_field.setPlaceholderText('（任意）')
            else:
                input_field.setText(dialogue)
            
            # テキスト 変更 時 色 アップデート
            def update_color(text, field=input_field):
                if text.strip():
                    field.setStyleSheet("""
                        QLineEdit {
                            background-color: white;
                            border: 1px solid #C5E8D8;
                            border-radius: 12px;
                            padding: 6px;
                            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                            color: #5A9C85;
                        }
                        QLineEdit:focus {
                            border: 2px solid #8ECFB5;
                        }
                    """)
                else:
                    field.setStyleSheet("""
                        QLineEdit {
                            background-color: white;
                            border: 1px solid #C5E8D8;
                            border-radius: 12px;
                            padding: 6px;
                            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                            color: #BDBDBD;
                        }
                        QLineEdit:focus {
                            border: 2px solid #8ECFB5;
                        }
                    """)
            
            input_field.textChanged.connect(update_color)
            
            # 秒 色 設定
            if dialogue and dialogue != '（任意）':
                input_field.setStyleSheet("""
                    QLineEdit {
                        background-color: white;
                        border: 1px solid #C5E8D8;
                        border-radius: 12px;
                        padding: 6px;
                        font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                        color: #5A9C85;
                    }
                    QLineEdit:focus {
                        border: 2px solid #8ECFB5;
                    }
                """)
            else:
                input_field.setStyleSheet("""
                    QLineEdit {
                        background-color: white;
                        border: 1px solid #C5E8D8;
                        border-radius: 12px;
                        padding: 6px;
                        font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                        color: #BDBDBD;
                    }
                    QLineEdit:focus {
                        border: 2px solid #8ECFB5;
                    }
                """)
            
            row.addWidget(label)
            row.addWidget(input_field, 1)
            
            # 削除 ボタン (基本 3個 以上の 時のみ)
            if i >= 3:
                delete_btn = QPushButton("✕")
                delete_btn.setFixedSize(30, 30)
                delete_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #FFB5BA;
                        font-size: 15px;
                        padding: 0px;
                        border-radius: 12px;
                    }
                    QPushButton:hover {
                        background-color: #FFA5AB;
                    }
                """)
                delete_btn.clicked.connect(lambda checked, idx=i: self.delete_dialogue(target_key, idx))
                row.addWidget(delete_btn)
            
            self.dialogue_inputs[target_key].append(input_field)
            self.scroll_layout.addLayout(row)
        
        # スペーサー 追加
        self.scroll_layout.addStretch()
        
        # 追加 ボタン (一番 下部)
        add_btn = QPushButton("セリフ追加")  # 絵文字 削除
        add_btn.clicked.connect(lambda: self.add_dialogue(target_key))
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                font-weight: 700;
                border-radius: 12px;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        self.scroll_layout.addWidget(add_btn)
    
    def add_dialogue(self, target_key):
        """セリフ追加"""
        self.save_current_dialogues()
        if target_key not in self.dialogues:
            self.dialogues[target_key] = []
        self.dialogues[target_key].append('（任意）')
        self.load_dialogue_inputs(target_key)
    
    def delete_dialogue(self, target_key, index):
        """セリフ 削除"""
        self.save_current_dialogues()
        if target_key in self.dialogues and len(self.dialogues[target_key]) > index:
            self.dialogues[target_key].pop(index)
        self.load_dialogue_inputs(target_key)
    
    def save_and_stay(self):
        """保存して ウィンドウを維持"""
        # 現在 対象の セリフ 保存
        dialogues = []
        for input_widget in self.dialogue_inputs.get(self.current_target, []):
            text = input_widget.text().strip()
            dialogues.append(text if text else '（任意）')
        if dialogues:
            self.dialogues[self.current_target] = dialogues
        
        # 全体 セリフ 辞書 アップデート
        self.all_dialogues[self.char_id] = self.dialogues
        
        print(f"[セリフ 保存] キャラクター {self.char_id}, 対象 {self.current_target}: {len(dialogues)}個")
        

        # 手動 セリフを AI キャッシュに 同期
        sync_dialogues_to_ai_cache(self.char_id, self.dialogues)

        # キャラクター ウィジェット アップデート および ファイル 保存 (親が MainWindowである 場合)
        if self.parent() and hasattr(self.parent(), 'update_character_dialogues'):
            self.parent().update_character_dialogues()
            self.parent().save_characters()
        # 保存 ポップアップ - 位置 調整
        msg = QMessageBox(self)
        msg.setWindowTitle("保存完了")
        msg.setText("セリフが 保存されました！")
        msg.setIcon(QMessageBox.Information)
        
        # ポップアップ サイズ 調整 (右 余裕 追加)
        msg.setStyleSheet("""
            QMessageBox {
                min-width: 280px;
            }
            QLabel {
                min-width: 220px;
                padding-right: 20px;
            }
        """)
        
        msg.exec_()
    
    def get_dialogues(self):
        """設定された セリフ 返す"""
        # 現在 見ていた 対象の セリフ 保存
        dialogues = []
        for input_widget in self.dialogue_inputs.get(self.current_target, []):
            text = input_widget.text().strip()
            dialogues.append(text if text else '（任意）')
        if dialogues:
            self.dialogues[self.current_target] = dialogues
        
        # 全体 セリフ 辞書 アップデート
        self.all_dialogues[self.char_id] = self.dialogues
        
        return self.dialogues


class RelationshipDialog(QDialog):
    """感情ベース 関係 設定 ダイアログ"""
    
    # 感情 リスト (10個)
    FEELINGS = ["愛情", "友情", "憧れ", "信頼", "いたずら", "イライラ", "嫉妬", "嫌悪", "気まずい", "無関心"]
    
    # 感情別 絵文字
    FEELING_EMOJIS = {
        "愛情": "💕", "友情": "🤝", "憧れ": "✨", "信頼": "🤗",
        "いたずら": "😜", "イライラ": "😤", "嫉妬": "🔥", "嫌悪": "💢",
        "気まずい": "😶", "無関心": "😐"
    }
    
    def __init__(self, char_id, char_name, all_characters, current_relationships, parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.all_characters = all_characters  # {char_id: name}
        
        print(f"[RelationshipDialog] 初期化 - char_id: {char_id}, char_name: {char_name}")
        print(f"[RelationshipDialog] current_relationships: {current_relationships}")
        
        # 現在 感情 設定 コピー (新形式: {other_id: {"my_feeling": "感情", "their_feeling": "感情"}})
        self.feelings = {}
        for key, value in current_relationships.items():
            if char_id in key:
                other_id = key[0] if key[1] == char_id else key[1]
                print(f"[RelationshipDialog] key={key}, other_id={other_id}, value={value}")
                if isinstance(value, dict):
                    # 新形式
                    my_feeling = value.get(char_id, "無関心")
                    their_feeling = value.get(other_id, "無関心")
                    print(f"[RelationshipDialog] char_id={char_id} 感情: {my_feeling}, other_id={other_id} 感情: {their_feeling}")
                    self.feelings[other_id] = {
                        "my_feeling": my_feeling,
                        "their_feeling": their_feeling
                    }
                else:
                    # 旧形式 互換 - 変換
                    my_f, their_f = self._convert_old_relationship(value, key, char_id)
                    self.feelings[other_id] = {"my_feeling": my_f, "their_feeling": their_f}
        
        print(f"[RelationshipDialog] self.feelings: {self.feelings}")
        
        self.combo_boxes = {}  # {other_id: combo}
        self.init_ui()
    
    def _convert_old_relationship(self, old_rel, key, char_id):
        """旧形式 関係を 新しい 感情 形式として 変換"""
        other_id = key[0] if key[1] == char_id else key[1]
        
        # 非対称関係 処理 (例: "愛情/嫌悪:me")
        if ":" in str(old_rel):
            base_rel, who = old_rel.rsplit(":", 1)
            parts = base_rel.split("/")
            if len(parts) == 2:
                if who == 'me':
                    return self._map_old_feeling(parts[0]), self._map_old_feeling(parts[1])
                else:
                    return self._map_old_feeling(parts[1]), self._map_old_feeling(parts[0])
        
        # な般 関係 マッピング
        rel_to_feelings = {
            "友達": ("友情", "友情"),
            "パートナー": ("信頼", "信頼"),
            "恋人": ("愛情", "愛情"),
            "ライバル": ("嫉妬", "嫉妬"),
            "敵": ("嫌悪", "嫌悪"),
            "見知らぬ人": ("無関心", "無関心"),
        }
        return rel_to_feelings.get(old_rel, ("無関心", "無関心"))
    
    def _map_old_feeling(self, old_feeling):
        """旧感情を 新しい 感情として マッピング"""
        mapping = {
            "愛情": "愛情", "嫌悪": "嫌悪", "無関心": "無関心",
            "いたずら": "いたずら", "イライラ": "イライラ", "尊敬": "憧れ",
            "嫉妬": "嫉妬", "執着": "愛情", "恐怖": "気まずい",
            "親近": "友情", "警戒": "気まずい", "信頼": "信頼", "不信": "気まずい"
        }
        return mapping.get(old_feeling, "無関心")
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}の 関係")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setMinimumSize(500, 500)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # メイン コンテナ (白色 背景, ボーダー)
        container = QWidget(self)
        container.setObjectName("relationContainer")
        container.setStyleSheet("""
            #relationContainer {
                background-color: white;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                border: none;
                background: transparent;
            }
            QComboBox {
                background-color: white;
                border: 1px solid #9DD4BA;
                border-radius: 10px;
                padding: 8px 12px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                color: #5A9C85;
                min-height: 20px;
            }
            QComboBox:hover {
                border: 2px solid #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 6px solid #9DD4BA;
                margin-right: 8px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #9DD4BA;
                selection-background-color: #E8F5EE;
                selection-color: #5A9C85;
                color: #5A9C85;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                padding: 14px;
                font-size: 15px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QScrollBar:vertical {
                background: transparent;
                width: 8px;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 4px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0;
            }
        """)
        
        main_layout = QVBoxLayout(container)
        main_layout.setContentsMargins(20, 16, 20, 20)
        main_layout.setSpacing(20)
        
        # ヘッダー (Xボタン)
        header = QHBoxLayout()
        header.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        header.addWidget(close_btn)
        main_layout.addLayout(header)
        
        # タイトル
        title = QLabel(f"{self.char_name}の 関係")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 20px;
            font-weight: 700;
            color: #317C75;
        """)
        main_layout.addWidget(title)
        
        # スクロール 領域
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        
        scroll_content = QWidget()
        scroll_content.setStyleSheet("background: transparent;")
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setSpacing(32)
        scroll_layout.setContentsMargins(0, 0, 10, 0)
        
        # 他の キャラクターたちに に対する 感情 設定
        for other_id, other_name in self.all_characters.items():
            if other_id == self.char_id:
                continue
            
            char_section = QWidget()
            char_section.setStyleSheet("background: transparent;")
            section_layout = QVBoxLayout(char_section)
            section_layout.setSpacing(8)
            section_layout.setContentsMargins(0, 0, 0, 0)
            
            # "to" タグ + キャラクター 名前
            name_row = QHBoxLayout()
            name_row.setSpacing(8)
            
            to_label = QLabel("to")
            to_label.setFixedSize(24, 20)
            to_label.setAlignment(Qt.AlignCenter)
            to_label.setStyleSheet("""
                background-color: #8ECFB5;
                color: white;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 700;
            """)
            name_row.addWidget(to_label)
            
            char_name_label = QLabel(other_name)
            char_name_label.setStyleSheet("""
                font-size: 15px;
                font-weight: 700;
                color: #317C75;
            """)
            name_row.addWidget(char_name_label)
            name_row.addStretch()
            section_layout.addLayout(name_row)
            
            # 関係 コンボボックス
            combo = QComboBox()
            combo.view().setStyleSheet("""
                QAbstractItemView {
                    background-color: white;
                    border: 1px solid #9DD4BA;
                    selection-background-color: #E8F5EE;
                    selection-color: #5A9C85;
                    color: #5A9C85;
                    outline: none;
                }
                QAbstractItemView::item {
                    padding: 8px;
                    background-color: white;
                    color: #5A9C85;
                }
                QAbstractItemView::item:hover {
                    background-color: #E8F5EE;
                }
            """)
            for feeling in self.FEELINGS:
                emoji = self.FEELING_EMOJIS.get(feeling, "")
                combo.addItem(f"{feeling}", feeling)
            
            # 現在 感情 設定
            current_feeling = self.feelings.get(other_id, {}).get("my_feeling", "無関心")
            index = self.FEELINGS.index(current_feeling) if current_feeling in self.FEELINGS else 9
            combo.setCurrentIndex(index)
            self.combo_boxes[other_id] = combo
            section_layout.addWidget(combo)
            
            scroll_layout.addWidget(char_section)
        
        scroll_layout.addStretch()
        scroll.setWidget(scroll_content)
        main_layout.addWidget(scroll, 1)
        
        # 保存 ボタン
        save_btn = QPushButton("保存")
        save_btn.setMinimumHeight(45)
        save_btn.clicked.connect(self.accept)
        main_layout.addWidget(save_btn)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
    
    def get_relationships(self):
        """設定された 感情 返す (新形式: my_feelingのみ)"""
        result = {}
        for other_id, combo in self.combo_boxes.items():
            my_feeling = combo.currentData()
            # currentDataが Noneなら currentText 使用
            if my_feeling is None:
                my_feeling = combo.currentText().strip()
            # 依然として 空の 値なら デフォルト
            if not my_feeling:
                my_feeling = "無関心"
            result[other_id] = my_feeling
            print(f"[get_relationships] other_id={other_id}, feeling={my_feeling}")
        return result


class BubbleColorDialog(QDialog):
    """吹き出しの色 および サイズ 選択ダイアログ"""
    # リアルタイム 変更 シグナル
    preview_changed = pyqtSignal(str, int)  # color, size
    
    def __init__(self, current_color='#81C784', current_size=100, parent=None):
        super().__init__(parent)
        self.selected_color = current_color
        self.selected_size = current_size
        self.color_buttons = []
        self.custom_btn = None
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle("吹き出し 設定")
        self.setFixedSize(420, 450)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton {
                border: none;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(30, 25, 30, 25)
        
        # ===== 色 セクション =====
        color_label = QLabel("吹き出しの色")
        color_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700; color: #3D7A5F;")
        layout.addWidget(color_label)
        
        # 色パレット (白色 背景)
        color_container = QWidget()
        color_container.setStyleSheet("""
            background-color: white;
            border-radius: 15px;
            border: 1px solid #C5E8D8;
        """)
        
        color_layout = QVBoxLayout()
        color_layout.setSpacing(8)
        color_layout.setContentsMargins(15, 15, 15, 15)
        
        colors = [
            "#FFB5BA", "#FFCDD2", "#F8BBD9", "#E1BEE7", "#D1C4E9",
            "#BBDEFB", "#B2EBF2", "#B2DFDB", "#C8E6C9", "#8ECFB5",
            "#FFF9C4", "#FFE0B2", "#FFCCBC", "#CFD8DC",
        ]
        
        for row in range(3):
            row_layout = QHBoxLayout()
            row_layout.setSpacing(6)
            row_layout.addStretch()
            
            for col in range(5):
                idx = row * 5 + col
                
                if row == 2 and col == 4:
                    self.custom_btn = QPushButton("+")
                    self.custom_btn.setFixedSize(42, 42)
                    self.custom_btn.setStyleSheet("""
                        QPushButton {
                            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                stop:0 #FFB5BA, stop:0.2 #FFE0B2, 
                                stop:0.4 #FFF9C4, stop:0.6 #C8E6C9, 
                                stop:0.8 #BBDEFB, stop:1 #E1BEE7);
                            border-radius: 21px;
                            border: 3px solid transparent;
                            font-size: 20px;
                            font-weight: 700; font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                            color: #666;
                        }
                        QPushButton:hover {
                            border: 3px solid #5A9C85;
                        }
                    """)
                    self.custom_btn.clicked.connect(self.open_color_picker)
                    row_layout.addWidget(self.custom_btn)
                elif idx < len(colors):
                    color_hex = colors[idx]
                    
                    btn = QPushButton()
                    btn.setFixedSize(42, 42)
                    btn.color_value = color_hex
                    
                    if color_hex.upper() == self.selected_color.upper():
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background-color: {color_hex};
                                border-radius: 21px;
                                border: 4px solid #5A9C85;
                            }}
                        """)
                    else:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background-color: {color_hex};
                                border-radius: 21px;
                                border: 3px solid transparent;
                            }}
                            QPushButton:hover {{
                                border: 3px solid #5A9C85;
                            }}
                        """)
                    
                    btn.clicked.connect(lambda checked, c=color_hex, b=btn: self.select_color(c, b))
                    self.color_buttons.append(btn)
                    row_layout.addWidget(btn)
            
            row_layout.addStretch()
            color_layout.addLayout(row_layout)
        
        color_container.setLayout(color_layout)
        layout.addWidget(color_container)
        
        # ===== サイズ セクション =====
        size_label = QLabel("吹き出しサイズ")
        size_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700; color: #3D7A5F;")
        layout.addWidget(size_label)
        
        # サイズ コンテナ
        size_container = QWidget()
        size_container.setStyleSheet("""
            background-color: white;
            border-radius: 15px;
            border: 1px solid #C5E8D8;
        """)
        
        size_layout = QVBoxLayout()
        size_layout.setSpacing(10)
        size_layout.setContentsMargins(20, 15, 20, 15)
        
        # スライダー + 値 表示
        slider_row = QHBoxLayout()
        slider_row.setSpacing(15)
        
        self.size_slider = QSlider(Qt.Horizontal)
        self.size_slider.setMinimum(50)
        self.size_slider.setMaximum(200)
        self.size_slider.setValue(self.selected_size)
        self.size_slider.setStyleSheet("""
            QSlider {
                background: transparent;
                border: none;
            }
            QSlider::groove:horizontal {
                background: #E0E0E0;
                height: 8px;
                border-radius: 4px;
                border: none;
            }
            QSlider::handle:horizontal {
                background: #8ECFB5;
                border: 2px solid #5A9C85;
                width: 20px;
                height: 20px;
                margin: -6px 0;
                border-radius: 10px;
            }
            QSlider::handle:horizontal:hover {
                background: #7BC4A8;
            }
            QSlider::sub-page:horizontal {
                background: #8ECFB5;
                border-radius: 4px;
                border: none;
            }
        """)
        self.size_slider.valueChanged.connect(self.on_size_changed)
        
        self.size_value_label = QLabel(f"{self.selected_size}%")
        self.size_value_label.setFixedWidth(65)
        self.size_value_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.size_value_label.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #5A9C85;
            background: transparent;
            border: none;
            padding-right: 5px;
        """)
        
        slider_row.addWidget(self.size_slider)
        slider_row.addWidget(self.size_value_label)
        
        size_layout.addLayout(slider_row)
        
        # プリセットボタン
        preset_row = QHBoxLayout()
        preset_row.setSpacing(8)
        preset_row.addStretch()
        
        for size in [75, 100, 125, 150]:
            preset_btn = QPushButton(f"{size}%")
            preset_btn.setFixedSize(58, 36)
            preset_btn.setCursor(Qt.PointingHandCursor)
            preset_btn.setStyleSheet("""
                QPushButton {
                    background-color: #F0FAF5;
                    color: #5A9C85;
                    border: 1px solid #C5E8D8;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 700;
                    font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #D4EDE1;
                }
            """)
            preset_btn.clicked.connect(lambda checked, s=size: self.set_size_preset(s))
            preset_row.addWidget(preset_btn)
        
        preset_row.addStretch()
        size_layout.addLayout(preset_row)
        
        size_container.setLayout(size_layout)
        layout.addWidget(size_container)
        
        # 確認 ボタン
        ok_button = QPushButton("適用")
        ok_button.clicked.connect(self.accept)
        ok_button.setMinimumHeight(45)
        ok_button.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                padding: 12px;
                border-radius: 12px;
                font-size: 15px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout.addWidget(ok_button)
        self.setLayout(layout)
    
    def on_size_changed(self, value):
        self.selected_size = value
        self.size_value_label.setText(f"{value}%")
        self.preview_changed.emit(self.selected_color, self.selected_size)
    
    def set_size_preset(self, size):
        self.size_slider.setValue(size)
    
    def select_color(self, color, clicked_btn):
        self.selected_color = color
        
        for btn in self.color_buttons:
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {btn.color_value};
                    border-radius: 21px;
                    border: 3px solid transparent;
                }}
                QPushButton:hover {{
                    border: 3px solid #5A9C85;
                }}
            """)
        
        if self.custom_btn:
            self.custom_btn.setStyleSheet("""
                QPushButton {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                        stop:0 #FFB5BA, stop:0.2 #FFE0B2, 
                        stop:0.4 #FFF9C4, stop:0.6 #C8E6C9, 
                        stop:0.8 #BBDEFB, stop:1 #E1BEE7);
                    border-radius: 21px;
                    border: 3px solid transparent;
                    font-size: 18px;
                }
                QPushButton:hover {
                    border: 3px solid #5A9C85;
                }
            """)
        
        clicked_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {color};
                border-radius: 21px;
                border: 4px solid #5A9C85;
            }}
        """)
        self.preview_changed.emit(self.selected_color, self.selected_size)
    
    def open_color_picker(self):
        color = QColorDialog.getColor(QColor(self.selected_color), self, "色選択")
        if color.isValid():
            self.selected_color = color.name()
            
            for btn in self.color_buttons:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {btn.color_value};
                        border-radius: 21px;
                        border: 3px solid transparent;
                    }}
                    QPushButton:hover {{
                        border: 3px solid #5A9C85;
                    }}
                """)
            
            self.custom_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {self.selected_color};
                    border-radius: 21px;
                    border: 4px solid #5A9C85;
                    font-size: 18px;
                }}
            """)
            self.preview_changed.emit(self.selected_color, self.selected_size)
    
    def get_color(self):
        return self.selected_color
    
    def get_size(self):
        return self.selected_size


class ScaleDialog(QDialog):
    """キャラクターサイズ 調整 ダイアログ (プレビュー サポート)"""
    def __init__(self, current_scale=100, parent=None, character=None):
        super().__init__(parent)
        self.selected_scale = current_scale
        self.original_scale = current_scale  # キャンセル 時 復元用
        self.character = character  # プレビュー用 キャラクター
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle("サイズ 調整")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(360, 260)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        # メイン コンテナ
        container = QWidget(self)
        container.setGeometry(0, 0, 360, 260)
        container.setObjectName("scaleContainer")
        container.setStyleSheet("""
            #scaleContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X ボタン (クレジット ダイアログと 同一)
        from PyQt5.QtSvg import QSvgRenderer
        self.close_btn = QPushButton(container)
        self.close_btn.setGeometry(320, 10, 28, 28)
        self.close_btn.setCursor(Qt.PointingHandCursor)
        self.close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            self.close_btn.setIcon(QIcon(pixmap))
            self.close_btn.setIconSize(QSize(20, 20))
        self.close_btn.clicked.connect(self.on_cancel)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(12)
        
        # タイトル
        title = QLabel("キャラクターサイズ")
        title.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #3D7A5F;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # サイズ コンテナ
        size_container = QWidget()
        size_container.setStyleSheet("""
            background-color: #E8F5EE;
            border-radius: 15px;
            border: none;
        """)
        
        size_layout = QVBoxLayout()
        size_layout.setSpacing(10)
        size_layout.setContentsMargins(15, 12, 15, 12)
        
        # スライダー + 値 表示
        slider_row = QHBoxLayout()
        slider_row.setSpacing(12)
        
        self.scale_slider = QSlider(Qt.Horizontal)
        self.scale_slider.setMinimum(50)
        self.scale_slider.setMaximum(1000)
        self.scale_slider.setValue(self.selected_scale)
        self.scale_slider.setStyleSheet("""
            QSlider {
                background: transparent;
                border: none;
            }
            QSlider::groove:horizontal {
                background: #D0D0D0;
                height: 8px;
                border-radius: 4px;
                border: none;
            }
            QSlider::handle:horizontal {
                background: #8ECFB5;
                border: 2px solid #5A9C85;
                width: 20px;
                height: 20px;
                margin: -6px 0;
                border-radius: 10px;
            }
            QSlider::handle:horizontal:hover {
                background: #7BC4A8;
            }
            QSlider::sub-page:horizontal {
                background: #8ECFB5;
                border-radius: 4px;
                border: none;
            }
        """)
        self.scale_slider.valueChanged.connect(self.on_scale_changed)
        
        self.scale_value_label = QLabel(f"{self.selected_scale}%")
        self.scale_value_label.setFixedWidth(60)
        self.scale_value_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.scale_value_label.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #5A9C85;
            background: transparent;
            border: none;
        """)
        
        slider_row.addWidget(self.scale_slider)
        slider_row.addWidget(self.scale_value_label)
        
        size_layout.addLayout(slider_row)
        
        # ボタン行 間 間隔
        size_layout.addSpacing(5)
        
        # プリセットボタン - 1番目 行
        preset_row1 = QHBoxLayout()
        preset_row1.setSpacing(10)
        preset_row1.addStretch()
        
        for scale in [100, 150, 200]:
            preset_btn = QPushButton(f"{scale}%")
            preset_btn.setFixedSize(90, 38)
            preset_btn.setCursor(Qt.PointingHandCursor)
            preset_btn.setStyleSheet("""
                QPushButton {
                    background-color: #F0FAF5;
                    color: #5A9C85;
                    border: 1px solid #C5E8D8;
                    border-radius: 10px;
                    font-size: 12px;
                    font-weight: 700;
                    font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                }
                QPushButton:hover {
                    background-color: #D4F4DD;
                    border-color: #8ECFB5;
                }
            """)
            preset_btn.clicked.connect(lambda checked, s=scale: self.set_scale_preset(s))
            preset_row1.addWidget(preset_btn)
        
        preset_row1.addStretch()
        size_layout.addLayout(preset_row1)
        
        # プリセットボタン - 2番目 行
        preset_row2 = QHBoxLayout()
        preset_row2.setSpacing(10)
        preset_row2.addStretch()
        
        for scale in [300, 500, 1000]:
            preset_btn = QPushButton(f"{scale}%")
            preset_btn.setFixedSize(90, 38)
            preset_btn.setCursor(Qt.PointingHandCursor)
            preset_btn.setStyleSheet("""
                QPushButton {
                    background-color: #F0FAF5;
                    color: #5A9C85;
                    border: 1px solid #C5E8D8;
                    border-radius: 10px;
                    font-size: 12px;
                    font-weight: 700;
                    font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                }
                QPushButton:hover {
                    background-color: #D4F4DD;
                    border-color: #8ECFB5;
                }
            """)
            preset_btn.clicked.connect(lambda checked, s=scale: self.set_scale_preset(s))
            preset_row2.addWidget(preset_btn)
        
        preset_row2.addStretch()
        size_layout.addLayout(preset_row2)
        
        size_container.setLayout(size_layout)
        layout.addWidget(size_container)
        
        # 適用 ボタン
        apply_btn = QPushButton("適用")
        apply_btn.setMinimumHeight(42)
        apply_btn.setCursor(Qt.PointingHandCursor)
        apply_btn.setStyleSheet("""
            QPushButton {
                background: #8ECFB5;
                border-radius: 12px;
                color: white;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #7BC4A8;
            }
        """)
        apply_btn.clicked.connect(self.accept)
        layout.addWidget(apply_btn)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        # X ボタンを 一番上で 上げる
        self.close_btn.raise_()
    
    def on_scale_changed(self, value):
        """スライダー 値変更時 - プレビュー"""
        self.selected_scale = value
        self.scale_value_label.setText(f"{value}%")
        
        # プレビュー: リアルタイムとして キャラクターサイズ 変更
        if self.character:
            self.character.update_scale(value)
    
    def set_scale_preset(self, scale):
        """プリセット ボタン クリック時"""
        self.selected_scale = scale
        self.scale_slider.setValue(scale)
        self.scale_value_label.setText(f"{scale}%")
        
        # プレビュー
        if self.character:
            self.character.update_scale(scale)
    
    def on_cancel(self):
        """キャンセル 時 元の サイズで 復元"""
        if self.character:
            self.character.update_scale(self.original_scale)
        self.reject()
    
    def get_scale(self):
        """選択された サイズ 返す"""
        return self.selected_scale


class NameEditDialog(QDialog):
    """名前編集 カスタム ダイアログ"""
    def __init__(self, current_name="", parent=None):
        super().__init__(parent)
        self.current_name = current_name
        self.new_name = current_name
        self.init_ui()
    
    def init_ui(self):
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(320, 170)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # メイン コンテナ (ラウンド 角)
        container = QWidget(self)
        container.setGeometry(0, 0, 320, 170)
        container.setStyleSheet("""
            QWidget {
                background-color: #E8F5EE;
                border-radius: 16px;
            }
        """)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(15)
        
        # ヘッダー (タイトル + Xボタン)
        header = QHBoxLayout()
        title = QLabel("名前編集")
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
        """)
        header.addWidget(title)
        header.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        header.addWidget(close_btn)
        layout.addLayout(header)
        
        # 入力 フィールド
        self.name_edit = QLineEdit()
        self.name_edit.setText(self.current_name)
        self.name_edit.setMinimumHeight(40)
        self.name_edit.returnPressed.connect(self.accept)  # Enter キーで 入力 完了
        self.name_edit.setStyleSheet("""
            QLineEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 10px 15px;
                font-size: 14px;
                font-weight: 700;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLineEdit:focus {
                border: 2px solid #8ECFB5;
            }
        """)
        layout.addWidget(self.name_edit)
        
        # 入力する ボタン
        ok_btn = QPushButton("入力する")
        ok_btn.setMinimumHeight(42)
        ok_btn.setCursor(Qt.PointingHandCursor)
        ok_btn.clicked.connect(self.accept)
        ok_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        layout.addWidget(ok_btn)
    
    def get_name(self):
        return self.name_edit.text()


class DeleteConfirmDialog(QDialog):
    """キャラクター削除 確認 カスタム ダイアログ"""
    def __init__(self, char_name, parent=None):
        super().__init__(parent)
        self.char_name = char_name
        self.result = False
        self.init_ui()
    
    def init_ui(self):
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(320, 180)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # メイン コンテナ (白色 背景, ボーダー)
        container = QWidget(self)
        container.setGeometry(0, 0, 320, 180)
        container.setObjectName("deleteContainer")
        container.setStyleSheet("""
            QWidget#deleteContainer {
                background-color: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(15)
        
        # ヘッダー (タイトル + Xボタン)
        header = QHBoxLayout()
        title = QLabel("キャラクター削除")
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            border: none;
            background: transparent;
        """)
        header.addWidget(title)
        header.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        header.addWidget(close_btn)
        layout.addLayout(header)
        
        # メッセージ
        msg = QLabel(f'"{self.char_name}"を本当に削除しますか？\n関連するすべてのデータが削除されます。')
        msg.setAlignment(Qt.AlignCenter)
        msg.setWordWrap(True)
        msg.setStyleSheet("""
            font-size: 14px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            line-height: 1.5;
            border: none;
            background: transparent;
        """)
        layout.addWidget(msg)
        
        # ボタン
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        yes_btn = QPushButton("Yes")
        yes_btn.setMinimumHeight(38)
        yes_btn.setCursor(Qt.PointingHandCursor)
        yes_btn.clicked.connect(self.on_yes)
        yes_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 30px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        no_btn = QPushButton("No")
        no_btn.setMinimumHeight(38)
        no_btn.setCursor(Qt.PointingHandCursor)
        no_btn.clicked.connect(self.reject)
        no_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #8ECFB5;
                border: 1px solid #8ECFB5;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 30px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #FFE5E8;
                border-color: #E57373;
                color: #E57373;
            }
        """)
        
        btn_layout.addWidget(yes_btn)
        btn_layout.addWidget(no_btn)
        layout.addLayout(btn_layout)
    
    def on_yes(self):
        self.result = True
        self.accept()


class DirectionDialog(QDialog):
    """キャラクター 方向選択ダイアログ"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.selected_direction = 'front'
        self.init_ui()
    
    def init_ui(self):
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(340, 400)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # メイン コンテナ (ラウンド 角, ターコイズ色 ボーダー)
        container = QWidget(self)
        container.setGeometry(0, 0, 340, 400)
        container.setStyleSheet("""
            QWidget {
                background-color: #E8F5EE;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        layout = QVBoxLayout(container)
        layout.setSpacing(10)
        layout.setContentsMargins(25, 15, 25, 20)
        
        # X ボタン (右 上部)
        close_layout = QHBoxLayout()
        close_layout.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        close_layout.addWidget(close_btn)
        layout.addLayout(close_layout)
        
        # タイトル
        title = QLabel("キャラクターはどちらを\n向いていますか？")
        title.setAlignment(Qt.AlignCenter)
        title.setMinimumHeight(60)
        title.setStyleSheet("""
            font-size: 20px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            line-height: 1.5;
            border: none;
            background: transparent;
            padding: 8px 0px;
        """)
        layout.addWidget(title)
        
        # 説明
        desc = QLabel("（見る人基準）")
        desc.setAlignment(Qt.AlignCenter)
        desc.setStyleSheet("""
            font-size: 13px; 
            font-weight: 700;
            color: #8ECFB5;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(desc)
        
        layout.addSpacing(5)
        
        # ラジオ ボタン グループ (白色 背景, ボーダー なし)
        self.button_group = QButtonGroup()
        
        radio_container = QWidget()
        radio_container.setStyleSheet("""
            QWidget {
                background-color: white;
                border-radius: 12px;
                border: none;
            }
        """)
        radio_layout = QVBoxLayout(radio_container)
        radio_layout.setSpacing(8)
        radio_layout.setContentsMargins(15, 15, 15, 15)
        
        radio_style = """
            QRadioButton {
                font-size: 14px;
                font-weight: 700;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                padding: 10px 8px;
                border: none;
                background: transparent;
                min-height: 28px;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
            QRadioButton::indicator:unchecked {
                border: 1px solid #C5E8D8;
                border-radius: 9px;
                background: white;
            }
            QRadioButton::indicator:checked {
                border: 2px solid #8ECFB5;
                border-radius: 9px;
                background-color: #8ECFB5;
            }
        """
        
        self.left_radio = QRadioButton("左を向いています")
        self.right_radio = QRadioButton("右を向いています")
        self.front_radio = QRadioButton("正面を向いています")
        
        self.left_radio.setStyleSheet(radio_style)
        self.right_radio.setStyleSheet(radio_style)
        self.front_radio.setStyleSheet(radio_style)
        
        self.left_radio.setMinimumHeight(44)
        self.right_radio.setMinimumHeight(44)
        self.front_radio.setMinimumHeight(44)
        
        self.front_radio.setChecked(True)
        
        self.button_group.addButton(self.left_radio, 0)
        self.button_group.addButton(self.right_radio, 1)
        self.button_group.addButton(self.front_radio, 2)
        
        radio_layout.addWidget(self.left_radio)
        radio_layout.addWidget(self.right_radio)
        radio_layout.addWidget(self.front_radio)
        
        layout.addWidget(radio_container)
        
        layout.addSpacing(5)
        
        # 確認 ボタン
        ok_button = QPushButton("確認")
        ok_button.setMinimumHeight(45)
        ok_button.setCursor(Qt.PointingHandCursor)
        ok_button.clicked.connect(self.accept)
        ok_button.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 15px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        layout.addWidget(ok_button)
    
    def get_direction(self):
        """選択された 方向を返す"""
        if self.left_radio.isChecked():
            return 'left'
        elif self.right_radio.isChecked():
            return 'right'
        else:
            return 'front'


class MainWindow(QMainWindow):
    """メインウィンドウ"""
    def __init__(self):
        super().__init__()
        self.characters = []
        self.char_id_counter = 0
        self.character_data = {}  # {char_id: {'name': '', 'scale': 100, 'bubble_color': '#81C784'}}
        self.relationships = {}  # {(char_id1, char_id2): 'relationship_type'}
        self.dialogues = {}  # {char_id: {'基本': [...], 'char_0': [...], ...}}
        self.gemini_api_key = ""  # Gemini API キー
        self.gemini_model = "gemini-2.5-flash-lite"  # Gemini モデル
        self.ai_enabled = False  # AI 有効化 状態

        # 自動バックアップ 設定
        self.auto_backup_enabled = True  # 基本: オン
        self.max_backups = 12  # 基本: 12個 維持

        # AI セリフ生成 完了 キュー (スレッド 安全)
        self._ai_complete_queue = []
        self._current_ai_mode = None  # 'generate_now', 'uncached', 'cache', 'single', 'add'
        
        # 設定ファイルパス (exe 横に 保存)
        if getattr(sys, 'frozen', False):
            # PyInstallerで ビルドされた 場合 - exe 横
            self.app_dir = os.path.dirname(sys.executable)
        else:
            # Python スクリプトで 実行される場合 - pyの横
            self.app_dir = os.path.dirname(os.path.abspath(__file__))
        
        self.config_file = os.path.join(self.app_dir, 'kiwipet_config.json')
        print(f"[初期化] 設定ファイルパス: {self.config_file}")
        
        self.is_minimized = False  # 最小化 状態
        self.normal_size = (550, 700)  # 基本 サイズ
        
        # ドラッグ アンド ドロップ 有効化
        self.setAcceptDrops(True)
        
        self.init_ui()
        
        # 保存された キャラクター 読み込み
        self.load_characters()
        
        # API キー/モデル 有効化
        if self.gemini_api_key:
            set_gemini_api_key(self.gemini_api_key)
        if self.gemini_model:
            set_gemini_model(self.gemini_model)
        if self.ai_enabled:
            set_ai_enabled(True)
            # AI セリフ キャッシュ生成 - 5秒 後 開始
            QTimer.singleShot(5000, self.generate_ai_cache)
            print("[AI] セリフ生成 5秒後開始予定")
        
        # 衝突 検出 タイマー
        self.collision_timer = QTimer()
        self.collision_timer.timeout.connect(self.check_collisions)
        self.collision_timer.start(100)
        
        # AI 完了 キュー 処理 タイマー (100msごとに チェック)
        self.ai_queue_timer = QTimer()
        self.ai_queue_timer.timeout.connect(self._process_ai_complete_queue)
        self.ai_queue_timer.start(100)
        
        # AI キャッシュ タイマー (キャッシュ 有無に 合わせて 10分/2時間)
        self.ai_cache_timer = QTimer()
        self.ai_cache_timer.timeout.connect(self.regenerate_ai_cache)
        self.update_ai_timer_interval()  # 秒 間隔設定
        
        # な時セリフ整理 タイマー (1分ごとに チェック)
        self.temp_cleanup_timer = QTimer()
        self.temp_cleanup_timer.timeout.connect(self.cleanup_temp_dialogues)
        self.temp_cleanup_timer.start(60 * 1000)  # 1分

        # 自動バックアップ タイマー (1時間ごとに)
        self.auto_backup_timer = QTimer()
        self.auto_backup_timer.timeout.connect(self.create_auto_backup)
        if self.auto_backup_enabled:
            self.auto_backup_timer.start(60 * 60 * 1000)  # 1時間

    def update_ai_timer_interval(self):
        """タイマー 間隔設定 (1時間ごとに)"""
        interval = 1 * 60 * 60 * 1000  # 1時間
        print("[AI タイマー] 1時間 間隔")
        self.ai_cache_timer.start(interval)
    
    def cleanup_temp_dialogues(self):
        """な時セリフ整理"""
        cleanup_temp_dialogues()
    
    def init_ui(self):
        self.setWindowTitle("Kiwipet")
        self.setGeometry(100, 100, 650, 750)
        
        # ウィンドウ アイコン 設定
        self.set_window_icon()
        
        # かわいい パステル ミント テーマ 🍀
        self.setStyleSheet("""
            QMainWindow {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QWidget {
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
            QPushButton:pressed {
                background-color: #6BB89B;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLineEdit {
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
        """)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(25, 8, 25, 25)
        main_layout.setSpacing(12)
        
        # 上部 ヘッダー (i ボタン, ロゴ, ? ボタン)
        header_layout = QVBoxLayout()
        header_layout.setSpacing(15)
        
        # ===== 1行: i ボタン（左） - ロゴ （中央） - ? ボタン （右） =====
        top_row = QHBoxLayout()
        top_row.setContentsMargins(0, 0, 0, 0)
        top_row.setAlignment(Qt.AlignTop)
        
        # iボタン（クレジット） - 28x28, 円形, 白色 背景, 絵文字
        info_btn = QPushButton()
        info_btn.setFixedSize(28, 28)
        info_btn.setCursor(Qt.PointingHandCursor)
        info_btn.clicked.connect(self.show_credit_dialog)
        info_btn.setStyleSheet("""
            QPushButton {
                background-color: #FFFFFF;
                border: none;
                border-radius: 14px;
                padding: 1px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
        """)
        # 絵文字 効果
        info_shadow = QGraphicsDropShadowEffect()
        info_shadow.setBlurRadius(4)
        info_shadow.setOffset(0, 1)
        info_shadow.setColor(QColor("#BFC8C4"))
        info_btn.setGraphicsEffect(info_shadow)
        self._set_svg_icon(info_btn, SVG_INFO, 20)
        
        top_row.addWidget(info_btn)
        top_row.addStretch()
        
        # Kiwipet ロゴ （中央） - SVG 使用 (150x75px)
        title_label = QLabel()
        title_label.setAlignment(Qt.AlignCenter)
        
        # SVGで タイトル 画像 生成
        from PyQt5.QtSvg import QSvgRenderer
        svg_renderer = QSvgRenderer(SVG_KIWIPET_TITLE.encode('utf-8'))
        if svg_renderer.isValid():
            # 150x75px サイズ
            target_width = 150
            target_height = 75
            
            title_pixmap = QPixmap(target_width, target_height)
            title_pixmap.fill(Qt.transparent)
            painter = QPainter(title_pixmap)
            svg_renderer.render(painter)
            painter.end()
            
            title_label.setPixmap(title_pixmap)
        else:
            title_label.setText("Kiwipet")
            title_label.setStyleSheet("""
                font-size: 28px;
                font-weight: 700; font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-style: italic;
                color: #4FB98F;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            """)
        
        top_row.addWidget(title_label)
        
        top_row.addStretch()
        
        # ?ボタン（チュートリアル） - 28x28, 円形, 白色 背景, 絵文字
        # ?ボタン（チュートリアル） - 28x28, 円形, 白色 背景, 絵文字
        help_btn = QPushButton()
        help_btn.setFixedSize(28, 28)
        help_btn.setCursor(Qt.PointingHandCursor)
        help_btn.clicked.connect(self.show_tutorial)
        help_btn.setStyleSheet("""
            QPushButton {
                background-color: #FFFFFF;
                border: none;
                border-radius: 14px;
                padding: 1px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
        """)
        # 絵文字 効果
        help_shadow = QGraphicsDropShadowEffect()
        help_shadow.setBlurRadius(4)
        help_shadow.setOffset(0, 1)
        help_shadow.setColor(QColor("#BFC8C4"))
        help_btn.setGraphicsEffect(help_shadow)
        self._set_svg_icon(help_btn, SVG_QUESTION, 14)
        
        top_row.addWidget(help_btn)
        header_layout.addLayout(top_row)
        
        # ===== 2行: 説明 テキストボックス =====
        desc_box = QLabel(
            "1. キャラクターを追加し、性格を入力した後、APIを有効にしてください。\n"
            "2. 1時間ごとに自動で新しいセリフを生成します。\n"
            "3. キャラクター間の関係に応じて様々な相互作用が発生します。\n"
            "4. 生成されたセリフは性格欄で閲覧/削除できます。\n"
            "5. 定期的にデータをバックアップすることをお勧めします。"
        )
        desc_box.setAlignment(Qt.AlignCenter)
        desc_box.setWordWrap(True)
        desc_box.setStyleSheet(f"""
            QLabel {{
                background-color: white;
                color: #317C75;
                font-size: 14px;
                font-weight: 700;
                padding: 15px 20px;
                border: 1px solid #C5E8D8;
                border-radius: 16px;
                font-family: {KOREAN_FONT};
                line-height: 19px;
                letter-spacing: -0.39px;
            }}
        """)
        header_layout.addWidget(desc_box)
        
        # ===== 3行: 上部 ボタン (モニター, API KEY, バックアップ) =====
        btn_row = QHBoxLayout()
        btn_row.setSpacing(10)
        
        # 環境設定 ボタン
        monitor_btn = QPushButton(" 環境設定")
        monitor_btn.setFixedHeight(36)
        monitor_btn.setCursor(Qt.PointingHandCursor)
        monitor_btn.clicked.connect(self.show_settings)
        monitor_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #317C75;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 10px;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        self._set_button_icon(monitor_btn, SVG_MONITOR, 16)
        
        # API KEY ボタン
        self.api_btn = QPushButton("API KEY")
        self.api_btn.setFixedHeight(36)
        self.api_btn.setCursor(Qt.PointingHandCursor)
        self.api_btn.clicked.connect(self.show_api_settings)
        self.api_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #317C75;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 10px;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        self._set_button_icon(self.api_btn, SVG_KEY, 16)
        
        # キャラクターバックアップ ボタン
        backup_btn = QPushButton(" キャラクターバックアップ")
        backup_btn.setFixedHeight(36)
        backup_btn.setCursor(Qt.PointingHandCursor)
        backup_btn.clicked.connect(self.backup_all_characters)
        backup_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #317C75;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 10px;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        self._set_button_icon(backup_btn, SVG_BACKUP, 16)
        
        btn_row.addWidget(monitor_btn)
        btn_row.addWidget(self.api_btn)
        btn_row.addWidget(backup_btn)
        header_layout.addLayout(btn_row)
        
        # キャラクター 追加 ボタン
        add_btn = QPushButton("キャラクターを追加")
        add_btn.clicked.connect(self.add_character)
        add_btn.setMinimumHeight(50)
        
        # キャラクター リストスクロール 領域 - きれいな 白色 背景, より 丸く
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 20px;
                background-color: white;
            }
            QScrollBar:vertical {
                background-color: #F0FAF5;
                width: 8px;
                border-radius: 4px;
                margin: 8px 4px;
            }
            QScrollBar::handle:vertical {
                background-color: #B8E6D0;
                border-radius: 4px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #8ECFB5;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        scroll.viewport().setStyleSheet("background-color: white; border-radius: 18px;")
        
        self.scroll_content = QWidget()
        self.scroll_content.setStyleSheet("background-color: white; border-radius: 18px;")
        self.scroll_layout = QVBoxLayout()
        self.scroll_layout.setSpacing(12)
        self.scroll_layout.setContentsMargins(18, 18, 18, 18)
        self.scroll_layout.addStretch()
        self.scroll_content.setLayout(self.scroll_layout)
        scroll.setWidget(self.scroll_content)
        
        # レイアウト 構成
        main_layout.addLayout(header_layout)
        main_layout.addWidget(add_btn)
        main_layout.addWidget(scroll, 1)
        
        central_widget.setLayout(main_layout)
        
        # 後で最小化する時に使用する ウィジェット保存
        self.add_btn = add_btn
        self.scroll = scroll
        self.header_layout_widget = header_layout
    
    def add_character(self):
        """キャラクター 追加 - 選択ダイアログ"""
        # 選択ダイアログ 生成
        dialog = QDialog(self)
        dialog.setWindowTitle("キャラクター 追加")
        dialog.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        dialog.setFixedSize(280, 175)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        
        # メイン コンテナ
        container = QWidget(dialog)
        container.setGeometry(0, 0, 280, 175)
        container.setObjectName("addCharContainer")
        container.setStyleSheet("""
            #addCharContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X ボタン (右 上部)
        from PyQt5.QtSvg import QSvgRenderer
        close_btn = QPushButton(container)
        close_btn.setGeometry(242, 10, 28, 28)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        # X アイコン SVG
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.clicked.connect(dialog.reject)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(10)
        
        # タイトル
        title = QLabel("キャラクター 追加")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # 新規キャラクター作成 ボタン
        new_btn = QPushButton("新規キャラクター作成")
        new_btn.setMinimumHeight(42)
        new_btn.setCursor(Qt.PointingHandCursor)
        new_btn.setStyleSheet("""
            QPushButton {
                background: #C5E8D8;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #B5DEC8;
            }
        """)
        new_btn.clicked.connect(lambda: self._on_add_choice(dialog, 'new'))
        layout.addWidget(new_btn)
        
        # 既存キャラクター読み込み ボタン
        load_btn = QPushButton("既存キャラクター読み込み")
        load_btn.setMinimumHeight(42)
        load_btn.setCursor(Qt.PointingHandCursor)
        load_btn.setStyleSheet("""
            QPushButton {
                background: #A8D5BA;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #98C5AA;
            }
        """)
        load_btn.clicked.connect(lambda: self._on_add_choice(dialog, 'load'))
        layout.addWidget(load_btn)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        # X ボタンを 一番上で
        close_btn.raise_()
        
        dialog.exec_()
    
    def _show_app_backup_dialog(self, parent_dialog):
        """アプリ全体バックアップ/読み込み 選択ダイアログ"""
        parent_dialog.accept()
        
        dialog = QDialog(self)
        dialog.setWindowTitle("アプリ全体バックアップ")
        dialog.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        dialog.setFixedSize(280, 180)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        
        # メイン コンテナ
        container = QWidget(dialog)
        container.setGeometry(0, 0, 280, 180)
        container.setObjectName("backupContainer")
        container.setStyleSheet("""
            #backupContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X ボタン
        close_btn = QPushButton(container)
        close_btn.setGeometry(245, 10, 24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: #F0F0F0;
                border-radius: 12px;
            }
        """)
        close_svg = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="#888888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        close_icon = QIcon(QPixmap.fromImage(QImage.fromData(close_svg.encode())))
        close_btn.setIcon(close_icon)
        close_btn.setIconSize(QSize(20, 20))
        close_btn.clicked.connect(dialog.reject)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(10)
        
        # タイトル
        title = QLabel("アプリ全体バックアップ/読み込み")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # バックアップする ボタン
        export_btn = QPushButton("バックアップする")
        export_btn.setMinimumHeight(42)
        export_btn.setCursor(Qt.PointingHandCursor)
        export_btn.setStyleSheet("""
            QPushButton {
                background: #C5E8D8;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #B5DEC8;
            }
        """)
        export_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'export'))
        layout.addWidget(export_btn)
        
        # 読み込む ボタン
        import_btn = QPushButton("読み込む")
        import_btn.setMinimumHeight(42)
        import_btn.setCursor(Qt.PointingHandCursor)
        import_btn.setStyleSheet("""
            QPushButton {
                background: #A8D5BA;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #98C5AA;
            }
        """)
        import_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'import'))
        layout.addWidget(import_btn)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()
    
    def _on_add_choice(self, dialog, choice):
        """キャラクター 追加 選択 処理"""
        dialog.accept()
        if choice == 'new':
            self._add_new_character()
        else:
            self._load_character_from_json()
    
    def _on_backup_choice(self, dialog, choice):
        """バックアップ 選択 処理"""
        dialog.accept()
        if choice == 'export':
            self._export_all_characters()
        else:
            self._import_all_characters()
    
    def _show_app_backup_dialog_from_batch(self, parent_dialog):
        """な括 バックアップ ダイアログから アプリ全体バックアップ/読み込み 呼び出し"""
        parent_dialog.accept()
        self._show_app_backup_dialog_standalone()
    
    def _show_app_backup_dialog_standalone(self):
        """アプリ全体バックアップ/読み込み 選択ダイアログ (独立型)"""
        dialog = QDialog(self)
        dialog.setWindowTitle("アプリ全体バックアップ")
        dialog.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        dialog.setFixedSize(280, 180)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        
        # メイン コンテナ
        container = QWidget(dialog)
        container.setGeometry(0, 0, 280, 180)
        container.setObjectName("backupContainer")
        container.setStyleSheet("""
            #backupContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X ボタン
        close_btn = QPushButton(container)
        close_btn.setGeometry(245, 10, 24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: #F0F0F0;
                border-radius: 12px;
            }
        """)
        close_svg = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="#888888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        close_icon = QIcon(QPixmap.fromImage(QImage.fromData(close_svg.encode())))
        close_btn.setIcon(close_icon)
        close_btn.setIconSize(QSize(20, 20))
        close_btn.clicked.connect(dialog.reject)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(10)
        
        # タイトル
        title = QLabel("アプリ全体バックアップ/読み込み")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # バックアップする ボタン
        export_btn = QPushButton("バックアップする")
        export_btn.setMinimumHeight(42)
        export_btn.setCursor(Qt.PointingHandCursor)
        export_btn.setStyleSheet("""
            QPushButton {
                background: #C5E8D8;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #B5DEC8;
            }
        """)
        export_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'export'))
        layout.addWidget(export_btn)
        
        # 読み込む ボタン
        import_btn = QPushButton("読み込む")
        import_btn.setMinimumHeight(42)
        import_btn.setCursor(Qt.PointingHandCursor)
        import_btn.setStyleSheet("""
            QPushButton {
                background: #A8D5BA;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #98C5AA;
            }
        """)
        import_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'import'))
        layout.addWidget(import_btn)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()

    def _load_character_from_json(self):
        """キャラクター 読み込む (フォルダ または JSONファイル)"""
        import shutil
        import base64
        
        # 選択 方式 ポップアップ
        msg = QMessageBox(self)
        msg.setWindowTitle("キャラクター 読み込む")
        msg.setText("バックアップフォルダまたはJSONファイルを選択してください。")
        folder_btn = msg.addButton("フォルダ選択", QMessageBox.ActionRole)
        file_btn = msg.addButton("JSON ファイル選択", QMessageBox.ActionRole)
        msg.addButton("キャンセル", QMessageBox.RejectRole)
        msg.exec_()
        
        clicked = msg.clickedButton()
        
        if clicked == folder_btn:
            # フォルダ選択
            folder_path = QFileDialog.getExistingDirectory(
                self,
                "キャラクターバックアップ フォルダ選択"
            )
            
            if not folder_path:
                return
            
            # フォルダから JSON 探す (_で 始まる メタ ファイル 除外)
            json_files = [f for f in os.listdir(folder_path) if f.endswith('.json') and not f.startswith('_')]
            if not json_files:
                QMessageBox.warning(self, "読み込む 失敗", "選択したフォルダにJSONファイルがありません。")
                return
            
            # 複数の JSONファイルが いれば 全体 読み込む
            if len(json_files) > 1:
                self._load_multiple_characters_from_folder(folder_path, json_files)
                return
            
            # 1個のみ いれば 既存 方式として 個別 読み込む
            json_path = os.path.join(folder_path, json_files[0])
            
        elif clicked == file_btn:
            # JSON ファイル選択
            json_path, _ = QFileDialog.getOpenFileName(
                self,
                "キャラクター JSON ファイル選択",
                "",
                "JSONファイル (*.json);;すべての ファイル (*.*)"
            )
            
            if not json_path:
                return
        else:
            return
        
        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            char_name = backup_data.get('char_name', '読み込んだ キャラクター')
            json_folder = os.path.dirname(json_path)
            
            # 画像 探す
            image_path = ""
            
            # 1. base64画像があるか 確認 (旧バージョン バックアップ)
            if backup_data.get('image_data'):
                temp_dir = os.path.join(self.app_dir, 'temp_images')
                os.makedirs(temp_dir, exist_ok=True)
                
                import uuid
                image_ext = backup_data.get('image_ext', '.png')
                unique_filename = f"img_{uuid.uuid4().hex[:8]}{image_ext}"
                image_path = os.path.join(temp_dir, unique_filename)
                
                image_bytes = base64.b64decode(backup_data['image_data'])
                with open(image_path, 'wb') as f:
                    f.write(image_bytes)
            
            # 2. image_file フィールドで 探す
            if not image_path:
                image_file = backup_data.get('image_file', '')
                if image_file:
                    possible_path = os.path.join(json_folder, image_file)
                    if os.path.exists(possible_path):
                        image_path = possible_path
            
            # 3. 同じ フォルダから 画像 ファイル 自動 検索
            if not image_path:
                for f in os.listdir(json_folder):
                    if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                        image_path = os.path.join(json_folder, f)
                        break
            
            # 4. 画像が なければ 直接 選択 要求
            if not image_path:
                QMessageBox.information(self, "画像 必要", "画像を選択してください。")
                image_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "キャラクター 画像選択",
                    json_folder,
                    "画像 ファイル (*.png *.jpg *.jpeg *.gif *.bmp);;すべての ファイル (*.*)"
                )
                if not image_path:
                    return
            
            # キャラクター 読み込み 完了
            self._finish_load_character(backup_data, image_path)
            
        except json.JSONDecodeError:
            QMessageBox.critical(self, "読み込む 失敗", "正しいJSONファイルではありません。")
        except Exception as e:
            import traceback
            print(f"[読み込む エラー] {e}")
            print(traceback.format_exc())
            QMessageBox.critical(self, "読み込む 失敗", f"読み込み中にエラーが発生しました。\n\n{str(e)}")
    
    def _load_multiple_characters_from_folder(self, folder_path, json_files):
        """バックアップ フォルダから 複数の キャラクター 読み込む"""
        import shutil
        
        # 確認 ポップアップ
        reply = QMessageBox.question(
            self,
            "キャラクター 読み込む",
            f"が フォルダに {len(json_files)}個のキャラクターがあります.\n\nすべて 読み込みますか?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply != QMessageBox.Yes:
            return
        
        # temp_imagesフォルダ 準備
        temp_dir = os.path.join(self.app_dir, 'temp_images')
        os.makedirs(temp_dir, exist_ok=True)
        
        loaded_count = 0
        global _ai_dialogues_cache
        
        for json_file in json_files:
            try:
                json_path = os.path.join(folder_path, json_file)
                with open(json_path, 'r', encoding='utf-8') as f:
                    char_backup = json.load(f)
                
                char_name = char_backup.get('char_name', 'キャラクター')
                
                # 新しい char_id 割り当て
                new_char_id = self.char_id_counter
                self.char_id_counter += 1
                
                # 画像 ファイル 探す
                image_file = char_backup.get('image_file', '')
                image_path = ""
                
                if image_file:
                    possible_path = os.path.join(folder_path, image_file)
                    if os.path.exists(possible_path):
                        image_path = possible_path
                
                # 画像 できなかったら 見つけたら ファイル体 ベースとして 検索
                if not image_path:
                    base_name = os.path.splitext(json_file)[0]
                    for ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.PNG', '.JPG']:
                        test_path = os.path.join(folder_path, f"{base_name}_image{ext}")
                        if os.path.exists(test_path):
                            image_path = test_path
                            break
                        # JSONと 同じ 名前の 画像も 検索
                        test_path = os.path.join(folder_path, f"{base_name}{ext}")
                        if os.path.exists(test_path):
                            image_path = test_path
                            break
                
                # それでもなければ フォルダ内 1番目 画像 使用
                if not image_path:
                    for f in os.listdir(folder_path):
                        if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                            image_path = os.path.join(folder_path, f)
                            break
                
                # それでもなければ placeholder 使用
                if not image_path or not os.path.exists(image_path):
                    from PyQt5.QtSvg import QSvgRenderer
                    from PyQt5.QtGui import QImage, QPainter
                    from PyQt5.QtCore import Qt
                    import uuid
                    
                    unique_filename = f"placeholder_{uuid.uuid4().hex[:8]}.png"
                    image_path = os.path.join(temp_dir, unique_filename)
                    
                    renderer = QSvgRenderer(PLACEHOLDER_SVG.encode('utf-8'))
                    img = QImage(100, 100, QImage.Format_ARGB32)
                    img.fill(Qt.transparent)
                    painter = QPainter(img)
                    renderer.render(painter)
                    painter.end()
                    img.save(image_path)
                
                # 画像 コピー
                import uuid
                ext = os.path.splitext(image_path)[1]
                unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                copied_path = os.path.join(temp_dir, unique_filename)
                shutil.copy2(image_path, copied_path)
                
                # キャラクター 生成
                direction = char_backup.get('facing_direction', 'right')
                scale = char_backup.get('scale', 100)
                bubble_color = char_backup.get('bubble_color', '#A8D5BA')
                bubble_size = char_backup.get('bubble_size', 100)
                is_active = char_backup.get('is_active', True)
                catchphrase = char_backup.get('catchphrase', '')
                
                char_widget = CharacterWidget(copied_path, new_char_id, direction, scale, bubble_color, bubble_size)
                char_widget.char_name = char_name
                char_widget.personality = char_backup.get('personality', '')
                char_widget.background_story = char_backup.get('background_story', '')
                char_widget.ai_auto_generate = char_backup.get('ai_auto_generate', True)
                char_widget.nicknames = char_backup.get('nicknames', {})
                char_widget.stories = char_backup.get('stories', {})
                
                if not is_active:
                    char_widget.hide()
                    char_widget.timer.stop()
                
                self.characters.append(char_widget)
                
                # キャラクター データ 保存
                self.character_data[new_char_id] = {
                    'name': char_name,
                    'scale': scale,
                    'bubble_color': bubble_color,
                    'bubble_size': bubble_size,
                    'facing_direction': direction,
                    'image_path': copied_path,
                    'is_active': is_active,
                    'catchphrase': catchphrase,
                    'personality': char_backup.get('personality', ''),
                    'background_story': char_backup.get('background_story', ''),
                    'sample_dialogues': char_backup.get('sample_dialogues', []),
                    'ai_auto_generate': char_backup.get('ai_auto_generate', True),
                    'nicknames': char_backup.get('nicknames', {}),
                    'stories': char_backup.get('stories', {})
                }
                
                # セリフ データ (キー 形式 統一)
                dialogues_data = char_backup.get('dialogues', [])
                if isinstance(dialogues_data, dict):
                    # キー 形式 変換: int → 'char_X'
                    converted = {}
                    for key, values in dialogues_data.items():
                        if key == '基本':
                            converted['基本'] = values
                        elif isinstance(key, int):
                            converted[f'char_{key}'] = values
                        elif isinstance(key, str) and key.isdigit():
                            converted[f'char_{key}'] = values
                        else:
                            converted[key] = values
                    self.dialogues[new_char_id] = converted
                else:
                    self.dialogues[new_char_id] = {'基本': dialogues_data}
                char_widget.dialogues = self.dialogues.get(new_char_id, {'基本': []})
                
                # AI キャッシュ 復元
                # AI キャッシュ 復元 (interaction キーを intで 変換)
                if char_backup.get('ai_cache'):
                    raw_interaction = char_backup['ai_cache'].get('interaction', {})
                    converted_interaction = {}
                    for k, v in raw_interaction.items():
                        try:
                            converted_interaction[int(k)] = v
                        except (ValueError, TypeError):
                            converted_interaction[k] = v
                    
                    _ai_dialogues_cache[new_char_id] = {
                        'solo': char_backup['ai_cache'].get('solo', []),
                        'interaction': converted_interaction,
                        'fallback': char_backup['ai_cache'].get('fallback', []),
                        'generated_at': time.time()
                    }
                
                # 手動 セリフを AI キャッシュに 同期
                sync_dialogues_to_ai_cache(new_char_id, self.dialogues[new_char_id])
                
                # カード 生成
                card = CharacterCard(new_char_id, copied_path, char_name, is_active, catchphrase)
                card.remove_clicked.connect(self.remove_character)
                card.change_image_clicked.connect(self.change_character_image)
                card.change_scale_clicked.connect(self.change_character_scale)
                card.change_bubble_color_clicked.connect(self.change_bubble_color)
                card.change_relationships_clicked.connect(self.change_relationships)
                card.change_dialogues_clicked.connect(self.change_dialogues)
                card.change_personality_clicked.connect(self.change_personality)
                card.name_changed.connect(self.update_character_name)
                card.catchphrase_changed.connect(self.update_character_catchphrase)
                card.toggle_active.connect(self.toggle_character_active)
                card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                card.update_scale_display(scale)
                
                self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                
                loaded_count += 1
                
            except Exception as e:
                print(f"[フォルダ 読み込む] キャラクター 読み込み エラー: {json_file} - {e}")
                import traceback
                print(traceback.format_exc())
        
        # 保存
        self.save_characters()
        
        # 関係/セリフ 情報 伝達
        self.update_character_relationships()
        self.update_character_dialogues()
        self.update_character_personalities()
        
        QMessageBox.information(self, "読み込み完了", f"{loaded_count}体のキャラクターを読み込みました。")
    
    def _finish_load_character(self, backup_data, image_path):
        """キャラクター 読み込み完了 処理"""
        import shutil
        
        char_name = backup_data.get('char_name', '読み込んだ キャラクター')
        
        # 画像を temp_imagesに コピー
        temp_dir = os.path.join(self.app_dir, 'temp_images')
        os.makedirs(temp_dir, exist_ok=True)
        
        import uuid
        ext = os.path.splitext(image_path)[1]
        unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
        copied_path = os.path.join(temp_dir, unique_filename)
        shutil.copy2(image_path, copied_path)
        image_path = copied_path
        
        # 方向
        direction = backup_data.get('facing_direction', 'right')
        
        # 空の キャラクター 番号 探す
        used_ids = set(self.character_data.keys())
        new_char_id = self.char_id_counter
        for i in range(self.char_id_counter):
            if i not in used_ids:
                new_char_id = i
                break
        
        # キャラクター 設定
        scale = backup_data.get('scale', 100)
        bubble_color = backup_data.get('bubble_color', '#A8D5BA')
        bubble_size = backup_data.get('bubble_size', 100)
        catchphrase = backup_data.get('catchphrase', '')
        is_active = backup_data.get('is_active', True)
        
        char_widget = CharacterWidget(image_path, new_char_id, direction, scale, bubble_color, bubble_size)
        if not is_active:
            char_widget.hide()
        self.characters.append(char_widget)
        
        # キャラクター データ 保存 (nicknames/storiesは 以下から 変換 後 設定)
        self.character_data[new_char_id] = {
            'name': char_name,
            'scale': scale,
            'bubble_color': bubble_color,
            'bubble_size': bubble_size,
            'facing_direction': direction,
            'image_path': image_path,
            'is_active': is_active,
            'catchphrase': catchphrase,
            'personality': backup_data.get('personality', ''),
            'background_story': backup_data.get('background_story', ''),
            'nicknames': {},  # 以下から 名前->ID 変換 後 設定
            'stories': {},  # 以下から 名前->ID 変換 後 設定
            'sample_dialogues': backup_data.get('sample_dialogues', [])
        }
        
        # セリフ データ (dialoguesが dict 形態かどうか list 形態かどうか 確認, キー 形式 統一)
        dialogues_data = backup_data.get('dialogues', [])
        if isinstance(dialogues_data, dict):
            # キー 形式 変換: int → 'char_X'
            converted = {}
            for key, values in dialogues_data.items():
                if key == '基本':
                    converted['基本'] = values
                elif isinstance(key, int):
                    converted[f'char_{key}'] = values
                elif isinstance(key, str) and key.isdigit():
                    converted[f'char_{key}'] = values
                else:
                    converted[key] = values
            self.dialogues[new_char_id] = converted
        else:
            # 旧形式: [...]
            self.dialogues[new_char_id] = {'基本': dialogues_data}
        
        # キャラクター ウィジェットに データ 伝達
        char_widget.dialogues = self.dialogues.get(new_char_id, {'基本': []})
        char_widget.personality = backup_data.get('personality', '')
        char_widget.background_story = backup_data.get('background_story', '')
        char_widget.char_name = char_name
        char_widget.catchphrase = catchphrase
        char_widget.sample_dialogues = backup_data.get('sample_dialogues', [])
        
        # nicknamesと storiesを 名前から IDで 変換
        raw_nicknames = backup_data.get('nicknames', {})
        raw_stories = backup_data.get('stories', {})
        
        # 現在 アプリの キャラクター 名前->ID マッピング
        name_to_id = {}
        for cid, cdata in self.character_data.items():
            cname = cdata.get('name', '')
            if cname:
                name_to_id[cname] = cid
        
        # 呼び方 変換
        new_nicknames = {}
        for key, nickname in raw_nicknames.items():
            # 数字(ID)である 場合 そのまま 使用 (同一 アプリ 内バックアップ/復元）
            try:
                key_int = int(key)
                if key_int in self.character_data:
                    new_nicknames[key_int] = nickname
                continue
            except ValueError:
                pass
            # 名前である 場合 IDで 変換
            if key in name_to_id:
                new_nicknames[name_to_id[key]] = nickname
        
        # ストーリー 変換
        new_stories = {}
        for key, story in raw_stories.items():
            try:
                key_int = int(key)
                if key_int in self.character_data:
                    new_stories[key_int] = story
                continue
            except ValueError:
                pass
            if key in name_to_id:
                new_stories[name_to_id[key]] = story
        
        char_widget.nicknames = new_nicknames
        char_widget.stories = new_stories
        self.character_data[new_char_id]['nicknames'] = new_nicknames
        self.character_data[new_char_id]['stories'] = new_stories
        
        # AI キャッシュ 復元 (interaction キーを intで 変換)
        if 'ai_cache' in backup_data:
            global _ai_dialogues_cache
            raw_interaction = backup_data['ai_cache'].get('interaction', {})
            converted_interaction = {}
            for k, v in raw_interaction.items():
                try:
                    converted_interaction[int(k)] = v
                except (ValueError, TypeError):
                    converted_interaction[k] = v
            
            _ai_dialogues_cache[new_char_id] = {
                'solo': backup_data['ai_cache'].get('solo', []),
                'interaction': converted_interaction,
                'fallback': backup_data['ai_cache'].get('fallback', []),
                'generated_at': time.time()
            }
        
        # 手動 セリフを AI キャッシュに 同期
        sync_dialogues_to_ai_cache(new_char_id, self.dialogues[new_char_id])
        
        # カード 生成
        card = CharacterCard(new_char_id, image_path, char_name, is_active=is_active, catchphrase=catchphrase)
        card.remove_clicked.connect(self.remove_character)
        card.change_image_clicked.connect(self.change_character_image)
        card.change_scale_clicked.connect(self.change_character_scale)
        card.change_bubble_color_clicked.connect(self.change_bubble_color)
        card.change_relationships_clicked.connect(self.change_relationships)
        card.change_dialogues_clicked.connect(self.change_dialogues)
        card.change_personality_clicked.connect(self.change_personality)
        card.name_changed.connect(self.update_character_name)
        card.catchphrase_changed.connect(self.update_character_catchphrase)
        card.toggle_active.connect(self.toggle_character_active)
        card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
        card.update_scale_display(scale)
        
        self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
        
        if new_char_id >= self.char_id_counter:
            self.char_id_counter = new_char_id + 1
        
        self.save_characters()
        
        # 詳細 完了 メッセージ
        has_ai = "✅" if backup_data.get('ai_cache') else "❌"
        has_personality = "✅" if backup_data.get('personality') else "❌"
        
        QMessageBox.information(self, "読み込み完了", 
            f"'{char_name}' キャラクターを 読み込みました。")
    
    def _add_new_character(self):
        """新規 キャラクター 追加"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "キャラクター 画像選択",
            "",
            "画像 ファイル (*.png *.jpg *.jpeg *.gif *.bmp)"
        )
        
        if file_path:
            # 方向選択ダイアログ
            direction_dialog = DirectionDialog(self)
            if direction_dialog.exec_() == QDialog.Accepted:
                direction = direction_dialog.get_direction()
                
                try:
                    # 画像を temp_imagesに 固有 ファイル体としてコピー
                    import uuid
                    import shutil
                    temp_dir = os.path.join(self.app_dir, 'temp_images')
                    os.makedirs(temp_dir, exist_ok=True)
                    
                    ext = os.path.splitext(file_path)[1]
                    unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                    copied_path = os.path.join(temp_dir, unique_filename)
                    shutil.copy2(file_path, copied_path)
                    
                    # 空の キャラクター 番号 探す
                    used_ids = set(self.character_data.keys())
                    new_char_id = self.char_id_counter
                    
                    # 空の 場所が いればその 番号 使用
                    for i in range(self.char_id_counter):
                        if i not in used_ids:
                            new_char_id = i
                            break
                    
                    char_widget = CharacterWidget(copied_path, new_char_id, direction, 100, '#A8D5BA', 100)
                    self.characters.append(char_widget)
                    
                    # キャラクター データ 保存 (コピーされた パス 使用)
                    self.character_data[new_char_id] = {
                        'name': f'キャラクター {new_char_id + 1}',
                        'scale': 100,
                        'bubble_color': '#A8D5BA',  # ミント グリーン
                        'bubble_size': 100,
                        'facing_direction': direction,
                        'image_path': copied_path,
                        'is_active': True,
                        'personality': '',
                        'nicknames': {},
                        'stories': {},
                        'background_story': '',
                        'sample_dialogues': [],
                        'catchphrase': '',
                        'ai_auto_generate': True  # AI 自動生成 デフォルト
                    }
                    
                    # セリフリセット (重要!)
                    if new_char_id not in self.dialogues:
                        self.dialogues[new_char_id] = {'基本': []}
                    
                    # キャラクター ウィジェットに セリフ 伝達
                    char_widget.dialogues = self.dialogues.get(new_char_id, {'基本': []})
                    
                    print(f"[キャラクター 追加] ID: {new_char_id}, 名前: キャラクター {new_char_id + 1}, セリフ: {char_widget.dialogues}")
                    
                    card = CharacterCard(new_char_id, copied_path, is_active=True)
                    card.remove_clicked.connect(self.remove_character)
                    card.change_image_clicked.connect(self.change_character_image)
                    card.change_scale_clicked.connect(self.change_character_scale)
                    card.change_bubble_color_clicked.connect(self.change_bubble_color)
                    card.change_relationships_clicked.connect(self.change_relationships)
                    card.change_dialogues_clicked.connect(self.change_dialogues)
                    card.change_personality_clicked.connect(self.change_personality)
                    card.name_changed.connect(self.update_character_name)
                    card.catchphrase_changed.connect(self.update_character_catchphrase)
                    card.toggle_active.connect(self.toggle_character_active)
                    card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                    
                    self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                    
                    # char_id_counterは 最大値のみ 追跡
                    if new_char_id >= self.char_id_counter:
                        self.char_id_counter = new_char_id + 1
                    
                    # 保存
                    print("[add_character] 保存 呼び出し!")
                    self.save_characters()
                    
                    QMessageBox.information(self, "成功", "キャラクターが追加されました！")
                except Exception as e:
                    import traceback
                    print(f"[add_character エラー] {e}")
                    print(traceback.format_exc())
                    QMessageBox.warning(self, "エラー", f"画像を読み込めません:\n{str(e)}")
    
    def remove_character(self, char_id):
        """キャラクター 削除 - 確認後 関連 ファイル すべて 削除"""
        # 確認 ポップアップ - カスタム ダイアログ
        char_name = self.character_data.get(char_id, {}).get('name', f'キャラクター {char_id + 1}')
        
        dialog = DeleteConfirmDialog(char_name, self)
        dialog.exec_()
        
        if not dialog.result:
            return
        
        # 元の画像ファイルは削除しない (ユーザー ファイル保存）
        
        # AI セリフ キャッシュ 削除
        global _ai_dialogues_cache
        if char_id in _ai_dialogues_cache:
            del _ai_dialogues_cache[char_id]
            print(f"[削除] AI セリフ キャッシュ 削除")
        
        # な時 セリフ キャッシュ 削除
        global _temp_dialogues_cache
        if char_id in _temp_dialogues_cache:
            del _temp_dialogues_cache[char_id]
            print(f"[削除] な時 セリフ キャッシュ 削除")
        
        # セリフ データ 削除
        if char_id in self.dialogues:
            del self.dialogues[char_id]
            print(f"[削除] キャラクター {char_id}の セリフ 削除")
        
        # 他の キャラクターたちの セリフから が キャラクター 関連 セリフも 削除
        for other_id in list(self.dialogues.keys()):
            target_key = f'char_{char_id}'
            if target_key in self.dialogues.get(other_id, {}):
                del self.dialogues[other_id][target_key]
                print(f"[削除] キャラクター {other_id}の {target_key} セリフ 削除")
        
        # 他の キャラクターたちの AI キャッシュから が キャラクター 関連 相互作用 セリフも 削除
        for other_id in list(_ai_dialogues_cache.keys()):
            if 'interaction' in _ai_dialogues_cache[other_id]:
                interaction = _ai_dialogues_cache[other_id]['interaction']
                if isinstance(interaction, dict) and char_id in interaction:
                    del interaction[char_id]
                    print(f"[削除] キャラクター {other_id}の AI 相互作用 セリフから {char_id} 削除")
        
        # 他の キャラクターたちの nicknames, storiesから が キャラクター 関連 データも 削除
        for other_id, other_data in self.character_data.items():
            if other_id == char_id:
                continue
            # nicknamesから 削除
            if 'nicknames' in other_data and char_id in other_data['nicknames']:
                del other_data['nicknames'][char_id]
                print(f"[削除] キャラクター {other_id}の nicknamesから {char_id} 削除")
            # storiesから 削除
            if 'stories' in other_data and char_id in other_data['stories']:
                del other_data['stories'][char_id]
                print(f"[削除] キャラクター {other_id}の storiesから {char_id} 削除")
        
        # CharacterWidgetの nicknames, storiesも 整理
        for char in self.characters:
            if char.char_id != char_id:
                if hasattr(char, 'nicknames') and char_id in char.nicknames:
                    del char.nicknames[char_id]
                if hasattr(char, 'stories') and char_id in char.stories:
                    del char.stories[char_id]
        
        # キャラクター ウィジェット 閉じる
        for char in self.characters:
            if char.char_id == char_id:
                char.close()
                self.characters.remove(char)
                break
        
        # キャラクター データ 削除
        if char_id in self.character_data:
            del self.character_data[char_id]
        
        # カードウィジェット 削除
        for i in range(self.scroll_layout.count()):
            item = self.scroll_layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                if isinstance(widget, CharacterCard) and widget.char_id == char_id:
                    widget.deleteLater()
                    break
        
        # 保存
        self.save_characters()
    
    def toggle_character_active(self, char_id, is_active):
        """キャラクター 有効化/無効化 (位置 維持)"""
        if char_id in self.character_data:
            self.character_data[char_id]['is_active'] = is_active
        
        for char in self.characters:
            if char.char_id == char_id:
                if is_active:
                    # 保存された 位置で 復元
                    saved_x = self.character_data.get(char_id, {}).get('x', None)
                    saved_y = self.character_data.get(char_id, {}).get('y', None)
                    if saved_x is not None and saved_y is not None:
                        char.move(saved_x, saved_y)
                    char.show()
                    char.timer.start(30)
                else:
                    # 現在 位置 保存
                    self.character_data[char_id]['x'] = char.x()
                    self.character_data[char_id]['y'] = char.y()
                    char.hide()
                    char.timer.stop()
                break
        
        # 保存
        self.save_characters()
    
    def show_batch_active_dialog(self):
        """複数 キャラクター 有効化/無効化 管理 ダイアログ"""
        if not self.character_data:
            QMessageBox.information(self, "有効化 管理", "管理するキャラクターがいません。")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("キャラクター 有効化 管理")
        dialog.setFixedWidth(320)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
            }
        """)
        
        main_layout = QVBoxLayout(dialog)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(12)
        
        # 説明 ボックス
        desc_box = QWidget()
        desc_box.setStyleSheet("""
            background-color: white;
            border-radius: 12px;
            border: 1px solid #9DD4BA;
        """)
        desc_layout = QVBoxLayout(desc_box)
        desc_layout.setContentsMargins(15, 12, 15, 12)
        
        desc_text = QLabel("有効化するキャラクターを選択してください。\nチェックを外したキャラクターは画面から非表示になります。")
        desc_text.setAlignment(Qt.AlignCenter)
        desc_text.setStyleSheet("""
            font-size: 12px;
            color: #5A9C85;
            background: transparent;
            border: none;
        """)
        desc_layout.addWidget(desc_text)
        main_layout.addWidget(desc_box)
        
        # すべて選択 / すべて解除 ボタン
        top_btn_layout = QHBoxLayout()
        
        select_all_btn = QPushButton("すべて選択")
        select_all_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #317C75;
                border: 1px solid #9DD4BA;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        top_btn_layout.addWidget(select_all_btn)
        
        deselect_all_btn = QPushButton("すべて解除")
        deselect_all_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #317C75;
                border: 1px solid #9DD4BA;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        top_btn_layout.addWidget(deselect_all_btn)
        top_btn_layout.addStretch()
        main_layout.addLayout(top_btn_layout)
        
        # キャラクター チェックボックス リスト (スクロール 領域)
        scroll_frame = QFrame()
        scroll_frame.setMaximumHeight(300)
        scroll_frame.setStyleSheet("""
            QFrame {
                background-color: white;
                border-radius: 12px;
                border: 1px solid #9DD4BA;
            }
        """)
        scroll_frame_layout = QVBoxLayout(scroll_frame)
        scroll_frame_layout.setContentsMargins(2, 2, 2, 2)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)
        scroll_area.setStyleSheet("""
            QScrollArea {
                background-color: transparent;
                border: none;
            }
            QWidget#checkboxContainer {
                background-color: white;
                border-radius: 10px;
            }
            QScrollBar:vertical {
                background: #F0F0F0;
                width: 8px;
                border-radius: 4px;
                margin: 4px 2px 4px 0px;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 4px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background: #9DD4BA;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        
        checkbox_container = QWidget()
        checkbox_container.setObjectName("checkboxContainer")
        checkbox_layout = QVBoxLayout(checkbox_container)
        checkbox_layout.setContentsMargins(13, 10, 13, 10)
        checkbox_layout.setSpacing(8)
        
        checkboxes = {}
        for char_id, data in self.character_data.items():
            char_name = data.get('name', f'キャラクター {char_id + 1}')
            is_active = data.get('is_active', True)
            
            cb = QCheckBox(char_name)
            cb.setChecked(is_active)
            cb.setStyleSheet("""
                QCheckBox {
                    font-size: 13px;
                    color: #317C75;
                    spacing: 8px;
                    border: none;
                    background: transparent;
                }
                QCheckBox::indicator {
                    width: 16px;
                    height: 16px;
                    border-radius: 4px;
                    border: 2px solid #C5E8D8;
                }
                QCheckBox::indicator:checked {
                    background-color: #8ECFB5;
                    border: 2px solid #8ECFB5;
                }
            """)
            checkboxes[char_id] = cb
            checkbox_layout.addWidget(cb)
        
        checkbox_layout.addStretch()
        scroll_area.setWidget(checkbox_container)
        scroll_frame_layout.addWidget(scroll_area)
        main_layout.addWidget(scroll_frame)
        
        # すべて選択 / すべて解除 接続
        def select_all():
            for cb in checkboxes.values():
                cb.setChecked(True)
        
        def deselect_all():
            for cb in checkboxes.values():
                cb.setChecked(False)
        
        select_all_btn.clicked.connect(select_all)
        deselect_all_btn.clicked.connect(deselect_all)
        
        # 適用 ボタン
        apply_btn = QPushButton("適用")
        apply_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 10px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #7EC9A9;
            }
        """)
        
        def apply_changes():
            for char_id, cb in checkboxes.items():
                new_active = cb.isChecked()
                old_active = self.character_data.get(char_id, {}).get('is_active', True)
                
                if new_active != old_active:
                    # トグル 状態 変更
                    self.toggle_character_active(char_id, new_active)
                    
                    # カード UI アップデート
                    for i in range(self.scroll_layout.count()):
                        widget = self.scroll_layout.itemAt(i).widget()
                        if isinstance(widget, CharacterCard) and widget.char_id == char_id:
                            widget.set_active(new_active)
                            break
            
            dialog.accept()
        
        apply_btn.clicked.connect(apply_changes)
        main_layout.addWidget(apply_btn)
        
        dialog.exec_()
    
    def update_character_name(self, char_id, name):
        """キャラクター 名前 アップデート"""
        if char_id in self.character_data:
            self.character_data[char_id]['name'] = name
            # 保存
            self.save_characters()
    
    def update_character_catchphrase(self, char_id, catchphrase):
        """キャラクター キャッチフレーズ アップデート"""
        if char_id in self.character_data:
            self.character_data[char_id]['catchphrase'] = catchphrase
            # 保存
            self.save_characters()
    
    def change_character_scale(self, char_id):
        """キャラクターサイズ 変更"""
        current_scale = self.character_data.get(char_id, {}).get('scale', 100)
        
        # プレビューを ために キャラクターオブジェクトを探す
        target_char = None
        for char in self.characters:
            if char.char_id == char_id:
                target_char = char
                break
        
        scale_dialog = ScaleDialog(current_scale, self, character=target_char)
        if scale_dialog.exec_() == QDialog.Accepted:
            new_scale = scale_dialog.get_scale()
            print(f"[サイズ] char_id={char_id}, 新しい サイズ={new_scale}%")
            
            # 既に プレビューで 適用されて あるので データのみ保存
            self.character_data[char_id]['scale'] = new_scale
            
            # カードの ボタン テキストも アップデート
            card_found = False
            for i in range(self.scroll_layout.count()):
                item = self.scroll_layout.itemAt(i)
                if item:
                    widget = item.widget()
                    if widget and isinstance(widget, CharacterCard):
                        print(f"[サイズ] カード発見: char_id={widget.char_id}")
                        if widget.char_id == char_id:
                            widget.update_scale_display(new_scale)
                            print(f"[サイズ] カード UI アップデート 完了: {new_scale}%")
                            card_found = True
                            break
            
            if not card_found:
                print(f"[サイズ] 警告: char_id={char_id}に 該当する カードを 見つけられませんでした")
            
            # 保存
            self.save_characters()
    
    def change_bubble_color(self, char_id):
        """吹き出しの色およびサイズ変更 (リアルタイム プレビュー)"""
        current_color = self.character_data.get(char_id, {}).get('bubble_color', '#81C784')
        current_size = self.character_data.get(char_id, {}).get('bubble_size', 100)
        
        # キャラクター 探す
        target_char = None
        for char in self.characters:
            if char.char_id == char_id:
                target_char = char
                break
        
        # キャラクターを 止まって 吹き出し表示
        if target_char:
            target_char.timer.stop()  # 動き 停止
            target_char.is_previewing_bubble = True
            target_char.show_dialogue("プレビュー", duration=999999)  # 長い 時間 維持
        
        color_dialog = BubbleColorDialog(current_color, current_size, self)
        
        # リアルタイム プレビューコールバック
        def on_preview_changed(color, size):
            if target_char:
                target_char.bubble_color = QColor(color)
                target_char.bubble_size = size
                target_char.update()  # 画面 更新
        
        color_dialog.preview_changed.connect(on_preview_changed)
        
        if color_dialog.exec_() == QDialog.Accepted:
            new_color = color_dialog.get_color()
            new_size = color_dialog.get_size()
            
            if target_char:
                target_char.bubble_color = QColor(new_color)
                target_char.bubble_size = new_size
                self.character_data[char_id]['bubble_color'] = new_color
                self.character_data[char_id]['bubble_size'] = new_size
            
            # 保存
            self.save_characters()
        else:
            # キャンセル 時 元の 値 復元
            if target_char:
                target_char.bubble_color = QColor(current_color)
                target_char.bubble_size = current_size
        
        # 吹き出し 隠して キャラクター再度動き
        if target_char:
            target_char.is_previewing_bubble = False
            target_char.hide_dialogue()
            target_char.timer.start(30)
    
    def change_relationships(self, char_id):
        """関係 設定"""
        # すべての キャラクター 名前 収集
        all_characters = {}
        for cid, data in self.character_data.items():
            all_characters[cid] = data.get('name', f'キャラクター {cid + 1}')
        
        if len(all_characters) < 2:
            QMessageBox.information(self, "お知らせ", "関係を設定するにはキャラクターが2体以上必要です！")
            return
        
        # 現在 キャラクター 名前
        char_name = self.character_data.get(char_id, {}).get('name', f'キャラクター {char_id + 1}')
        
        print(f"[関係 設定] キャラクター {char_id} ({char_name}) 関係 ダイアログ 開く")
        print(f"[関係 設定] 現在 self.relationships: {self.relationships}")
        
        try:
            dialog = RelationshipDialog(char_id, char_name, all_characters, self.relationships, self)
            if dialog.exec_() == QDialog.Accepted:
                new_feelings = dialog.get_relationships()  # {other_id: "感情"}
                
                print(f"[関係 設定] 新しい 感情: {new_feelings}")
                
                # 感情 アップデート (新形式: {(min_id, max_id): {char1_id: "感情1", char2_id: "感情2"}})
                for other_id, my_feeling in new_feelings.items():
                    # None チェック
                    if my_feeling is None:
                        my_feeling = "無関心"
                    
                    key = tuple(sorted([char_id, other_id]))
                    
                    print(f"[関係 設定] キー: {key}, キャラクター {char_id} -> {other_id}: {my_feeling}")
                    
                    # 既存データがあれば 維持しながら アップデート
                    if key in self.relationships and isinstance(self.relationships[key], dict):
                        self.relationships[key][char_id] = my_feeling
                        print(f"[関係 設定] 既存 データ アップデート: {self.relationships[key]}")
                    else:
                        # 新しく生成 (相手の感情は デフォルト "無関心")
                        self.relationships[key] = {
                            char_id: my_feeling,
                            other_id: "無関心"
                        }
                        print(f"[関係 設定] 新しく生成: {self.relationships[key]}")
                
                print(f"[関係 設定] アップデート 後 self.relationships: {self.relationships}")
                
                # キャラクター ウィジェットに 感情 情報 伝達
                self.update_character_relationships()
                
                # 保存
                self.save_characters()
                print(f"[関係 設定] 保存完了")
        except Exception as e:
            import traceback
            print(f"[関係 設定 エラー] {e}")
            print(traceback.format_exc())
            QMessageBox.warning(self, "エラー", f"感情設定中にエラー発生:\n{str(e)}")
    
    def change_dialogues(self, char_id):
        """セリフ 設定"""
        # すべての キャラクター 名前 収集
        all_characters = {}
        for cid, data in self.character_data.items():
            all_characters[cid] = data.get('name', f'キャラクター {cid + 1}')
        
        # 現在 キャラクター 名前
        char_name = self.character_data.get(char_id, {}).get('name', f'キャラクター {char_id + 1}')
        
        try:
            dialog = DialogueDialog(char_id, char_name, all_characters, self.dialogues, self)
            if dialog.exec_() == QDialog.Accepted:
                new_dialogues = dialog.get_dialogues()
                self.dialogues[char_id] = new_dialogues
                
                print(f"[セリフ 変更] キャラクター {char_id}の セリフ: {new_dialogues}")
                
                # 手動 セリフを AI キャッシュに 同期
                sync_dialogues_to_ai_cache(char_id, new_dialogues)
                
                # キャラクター ウィジェットに セリフ 情報 伝達
                self.update_character_dialogues()
                
                # キャラクター ウィジェットの セリフ 確認
                for char in self.characters:
                    if char.char_id == char_id:
                        print(f"[ウィジェット セリフ] キャラクター {char_id}: {char.dialogues}")
                
                # 保存
                self.save_characters()
        except Exception as e:
            import traceback
            print(f"[セリフ 設定 エラー] {e}")
            print(traceback.format_exc())
            QMessageBox.warning(self, "エラー", f"セリフ設定中にエラー発生:\n{str(e)}")
    
    def change_personality(self, char_id):
        """性格 設定 (セリフ + AI 性格 統合)"""
        # すべての キャラクター 名前 収集
        all_characters = {}
        for cid, data in self.character_data.items():
            all_characters[cid] = data.get('name', f'キャラクター {cid + 1}')
        
        # 現在 キャラクター 名前
        char_name = self.character_data.get(char_id, {}).get('name', f'キャラクター {char_id + 1}')
        
        # 現在 性格, 呼び方, セリフ 取得
        current_personality = ""
        current_nicknames = {}
        for char in self.characters:
            if char.char_id == char_id:
                current_personality = char.personality
                current_nicknames = char.nicknames
                break
        
        # 現在 セリフ
        current_dialogues = self.dialogues.get(char_id, {}).get('基本', ['', '', ''])
        
        # 現在 ストーリー
        current_stories = self.character_data.get(char_id, {}).get('stories', {})
        
        # 現在 背景 ストーリー
        current_background_story = self.character_data.get(char_id, {}).get('background_story', '')
        
        try:
            dialog = PersonalityDialog(char_id, char_name, all_characters, 
                                       current_personality, current_nicknames, 
                                       current_dialogues, current_stories, 
                                       current_background_story, self)
            if dialog.exec_() == QDialog.Accepted:
                new_personality = dialog.get_personality()
                new_background_story = dialog.get_background_story()
                new_nicknames = dialog.get_nicknames()
                new_dialogues = dialog.get_dialogues()
                new_stories = dialog.get_stories()
                
                # 性格が 新しく 追加されたか 確認
                personality_added = new_personality and not current_personality
                
                # キャラクター ウィジェットに 性格 情報 アップデート
                for char in self.characters:
                    if char.char_id == char_id:
                        char.personality = new_personality
                        char.background_story = new_background_story
                        char.nicknames = new_nicknames
                        char.char_name = char_name
                        char.dialogues = {'基本': new_dialogues}
                        char.stories = new_stories
                        break
                
                # character_dataにも 保存
                if char_id not in self.character_data:
                    self.character_data[char_id] = {}
                self.character_data[char_id]['personality'] = new_personality
                self.character_data[char_id]['background_story'] = new_background_story
                self.character_data[char_id]['nicknames'] = new_nicknames
                self.character_data[char_id]['stories'] = new_stories
                
                # セリフ 保存
                if char_id not in self.dialogues:
                    self.dialogues[char_id] = {}
                self.dialogues[char_id]['基本'] = new_dialogues
                
                # 手動 セリフを AI キャッシュに 同期
                sync_dialogues_to_ai_cache(char_id, self.dialogues[char_id])
                
                print(f"[性格] キャラクター {char_id}: 性格={new_personality}, 呼び方={new_nicknames}, セリフ={new_dialogues}, ストーリー={new_stories}")
                
                # 保存
                self.save_characters()
                
                # 性格が 新しく 追加されると 該当 キャラクターのみ すぐ セリフ生成
                if personality_added and self.ai_enabled and self.gemini_api_key:
                    print(f"[AI] 新しい 性格 追加される - {char_name} セリフ すぐ 生成")
                    self.generate_single_character_cache(char_id)
                    
        except Exception as e:
            import traceback
            print(f"[性格 設定 エラー] {e}")
            print(traceback.format_exc())
            QMessageBox.warning(self, "エラー", f"性格設定中にエラー発生:\n{str(e)}")
    
    def update_character_relationships(self):
        """すべての キャラクターに 感情 情報 アップデート (新しい システム)"""
        print(f"[関係 アップデート] 開始 - self.relationships: {self.relationships}")
        
        for char in self.characters:
            char.relationships = {}
            
            # 新形式: relationships = {(min_id, max_id): {char1_id: "感情1", char2_id: "感情2"}}
            for key, rel_data in self.relationships.items():
                try:
                    # keyがタプルでchar_idが 含まれて あるか 確認
                    if not isinstance(key, tuple) or len(key) != 2:
                        print(f"[関係 アップデート] よくできなかったらされた キー 形式 無視: {key}")
                        continue
                    
                    if char.char_id not in key:
                        continue
                    
                    other_id = key[0] if key[1] == char.char_id else key[1]
                    
                    # other_idが 整数かどうか 確認
                    if not isinstance(other_id, int):
                        print(f"[関係 アップデート] other_idが 整数が ではない: {other_id} (type: {type(other_id)})")
                        continue
                    
                    if isinstance(rel_data, dict):
                        # 新形式 - 各 キャラクターの 感情 取得
                        my_feeling = rel_data.get(char.char_id, "無関心")
                        # my_feelingが 文字列かどうか 確認
                        if isinstance(my_feeling, str):
                            char.relationships[other_id] = my_feeling
                            print(f"[関係 アップデート] キャラクター {char.char_id} -> {other_id}: {my_feeling}")
                    else:
                        # 旧形式 互換 - デフォルトとして 変換
                        char.relationships[other_id] = self._convert_old_to_feeling(rel_data)
                except Exception as e:
                    print(f"[関係 アップデート エラー] key={key}, rel_data={rel_data}, error={e}")
            
            print(f"[関係 アップデート] キャラクター {char.char_id} 最終 relationships: {char.relationships}")
    
    def _convert_old_to_feeling(self, old_rel):
        """旧形式 関係を 新しい 感情として 変換"""
        # 非対称関係 処理
        if ":" in str(old_rel):
            base_rel, _ = old_rel.rsplit(":", 1)
            old_rel = base_rel
        
        # 関係 タイプを 感情として マッピング
        rel_to_feeling = {
            "友達": "友情", "パートナー": "信頼", "恋人": "愛情",
            "ライバル": "嫉妬", "敵": "嫌悪", "見知らぬ人": "無関心"
        }
        
        if "/" in str(old_rel):
            # 非対称関係 - 1番目 感情 使用
            parts = old_rel.split("/")
            mapping = {
                "愛情": "愛情", "嫌悪": "嫌悪", "無関心": "無関心",
                "いたずら": "いたずら", "イライラ": "イライラ", "尊敬": "憧れ",
                "嫉妬": "嫉妬", "執着": "愛情", "恐怖": "気まずい",
                "親近": "友情", "警戒": "気まずい", "信頼": "信頼", "不信": "気まずい"
            }
            return mapping.get(parts[0], "無関心")
        
        return rel_to_feeling.get(old_rel, "無関心")
    
    def update_character_dialogues(self):
        """すべての キャラクターに セリフ 情報 アップデート"""
        for char in self.characters:
            char.dialogues = self.dialogues.get(char.char_id, {'基本': []})
    
    def update_character_personalities(self):
        """すべての キャラクターに 性格 および 呼び方, ストーリー 情報 アップデート"""
        for char in self.characters:
            char_data = self.character_data.get(char.char_id, {})
            char.personality = char_data.get('personality', '')
            char.background_story = char_data.get('background_story', '')
            char.sample_dialogues = char_data.get('sample_dialogues', [])
            char.nicknames = char_data.get('nicknames', {})
            char.stories = char_data.get('stories', {})
            char.char_name = char_data.get('name', f'キャラクター {char.char_id + 1}')
            char.ai_auto_generate = char_data.get('ai_auto_generate', True)
    
    def change_character_image(self, char_id):
        """キャラクター 画像変更"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "新しい 画像選択",
            "",
            "画像 ファイル (*.png *.jpg *.jpeg *.gif *.bmp)"
        )
        
        if file_path:
            # 方向選択ダイアログ
            direction_dialog = DirectionDialog(self)
            if direction_dialog.exec_() == QDialog.Accepted:
                direction = direction_dialog.get_direction()
                
                # 画像を temp_imagesに 固有 ファイル体としてコピー
                import uuid
                import shutil
                temp_dir = os.path.join(self.app_dir, 'temp_images')
                os.makedirs(temp_dir, exist_ok=True)
                
                ext = os.path.splitext(file_path)[1]
                unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                copied_path = os.path.join(temp_dir, unique_filename)
                shutil.copy2(file_path, copied_path)
                
                for char in self.characters:
                    if char.char_id == char_id:
                        # 既存 データ 保存
                        pos = char.pos()
                        velocity_x = char.velocity_x
                        current_scale = self.character_data.get(char_id, {}).get('scale', 100)
                        current_name = self.character_data.get(char_id, {}).get('name', f'キャラクター {char_id + 1}')
                        current_color = self.character_data.get(char_id, {}).get('bubble_color', '#81C784')
                        
                        # セリフ 関連 データ 保存
                        saved_personality = char.personality
                        saved_dialogues = char.dialogues.copy() if char.dialogues else {}
                        saved_sample_dialogues = char.sample_dialogues.copy() if hasattr(char, 'sample_dialogues') and char.sample_dialogues else []
                        saved_background_story = char.background_story
                        saved_char_name = char.char_name
                        saved_nicknames = char.nicknames.copy() if hasattr(char, 'nicknames') and char.nicknames else {}
                        saved_stories = char.stories.copy() if hasattr(char, 'stories') and char.stories else {}
                        saved_relationships = char.relationships.copy() if hasattr(char, 'relationships') and char.relationships else {}
                        saved_bubble_size = char.bubble_size if hasattr(char, 'bubble_size') else 100
                        
                        char.close()
                        self.characters.remove(char)
                        
                        new_char = CharacterWidget(copied_path, char_id, direction, current_scale, current_color, saved_bubble_size)
                        new_char.move(pos)
                        new_char.velocity_x = velocity_x
                        
                        # セリフ 関連 データ 復元
                        new_char.personality = saved_personality
                        new_char.dialogues = saved_dialogues
                        new_char.sample_dialogues = saved_sample_dialogues
                        new_char.background_story = saved_background_story
                        new_char.char_name = saved_char_name
                        new_char.nicknames = saved_nicknames
                        new_char.stories = saved_stories
                        new_char.relationships = saved_relationships
                        
                        self.characters.append(new_char)
                        
                        # データ アップデート (コピーされた パス 使用)
                        self.character_data[char_id]['facing_direction'] = direction
                        self.character_data[char_id]['image_path'] = copied_path
                        
                        for i in range(self.scroll_layout.count()):
                            item = self.scroll_layout.itemAt(i)
                            if item and item.widget():
                                widget = item.widget()
                                if isinstance(widget, CharacterCard) and widget.char_id == char_id:
                                    is_active = self.character_data[char_id].get('is_active', True)
                                    catchphrase = self.character_data[char_id].get('catchphrase', '')
                                    new_card = CharacterCard(char_id, copied_path, current_name, is_active, catchphrase)
                                    new_card.remove_clicked.connect(self.remove_character)
                                    new_card.change_image_clicked.connect(self.change_character_image)
                                    new_card.change_scale_clicked.connect(self.change_character_scale)
                                    new_card.change_bubble_color_clicked.connect(self.change_bubble_color)
                                    new_card.change_relationships_clicked.connect(self.change_relationships)
                                    new_card.change_dialogues_clicked.connect(self.change_dialogues)
                                    new_card.change_personality_clicked.connect(self.change_personality)
                                    new_card.name_changed.connect(self.update_character_name)
                                    new_card.catchphrase_changed.connect(self.update_character_catchphrase)
                                    new_card.toggle_active.connect(self.toggle_character_active)
                                    new_card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                                    # サイズ 表示 アップデート
                                    scale = self.character_data[char_id].get('scale', 100)
                                    new_card.update_scale_display(scale)
                                    self.scroll_layout.replaceWidget(widget, new_card)
                                    widget.deleteLater()
                                    break
                        break
                
                # 保存
                self.save_characters()
    
    def generate_ai_cache(self):
        """すべての キャラクターの セリフ キャッシュ生成 (順次)"""
        global _ai_dialogues_cache
        
        if not self.gemini_api_key or not self.ai_enabled:
            return
        
        print("[AI] セリフ キャッシュ生成 開始...")
        
        # 性格が設定された キャラクター リスト 収集
        chars_to_generate = []
        
        try:
            for char in self.characters:
                char_data = self.character_data.get(char.char_id, {})
                personality = char_data.get('personality', '')
                
                # ai_auto_generateが Falseならスキップ
                ai_auto = char_data.get('ai_auto_generate', True)
                if not ai_auto:
                    print(f"[AI] {char_data.get('name', '?')} - 自動生成 無効化, スキップ")
                    continue
                
                if personality:  # 性格が設定された キャラクターのみ
                    # 既に キャッシュが いれば スキップ
                    existing_cache = _ai_dialogues_cache.get(char.char_id, {})
                    if existing_cache.get('solo'):
                        print(f"[AI] {char_data.get('name', '?')} - 既存 キャッシュ 使用")
                        continue
                    
                    # 他の キャラクター 情報 収集
                    other_chars_info = []
                    for other in self.characters:
                        if other.char_id != char.char_id:
                            other_name = self.character_data.get(other.char_id, {}).get('name', f'キャラクター {other.char_id + 1}')
                            nicknames_str = char_data.get('nicknames', {}).get(other.char_id, other_name)
                            # ストーリー 情報
                            story = char_data.get('stories', {}).get(other.char_id, '')
                            # 関係 情報 - 辞書 形態から 現在 キャラクターの 感情 抽出
                            rel_key = (min(char.char_id, other.char_id), max(char.char_id, other.char_id))
                            rel_data = self.relationships.get(rel_key, {})
                            if isinstance(rel_data, dict):
                                relationship = rel_data.get(char.char_id, "友達")
                            else:
                                relationship = rel_data if rel_data else "友達"
                            other_chars_info.append((other_name, nicknames_str, relationship, story))
                    
                    print(f"[AI] {char_data.get('name', '?')} - 相互作用対象: {[info[0] for info in other_chars_info]}")
                    
                    # 重複 名前 処理
                    other_chars_info = make_unique_names(other_chars_info)
                    
                    print(f"[AI] {char_data.get('name', '?')} - 重複処理 後: {[info[0] for info in other_chars_info]}")
                    
                    # サンプル セリフ
                    sample_dialogues = self.dialogues.get(char.char_id, {}).get('基本', [])
                    
                    # 背景 ストーリー
                    background_story = char_data.get('background_story', '')
                    
                    # 現在 セリフ こと 計算 (ソート用)
                    cache = _ai_dialogues_cache.get(char.char_id, {})
                    current_count = len(cache.get('solo', [])) + sum(len(v) for v in cache.get('interaction', {}).values())
                    
                    chars_to_generate.append({
                        'char_id': char.char_id,
                        'name': char_data.get('name', f'キャラクター {char.char_id + 1}'),
                        'personality': personality,
                        'sample_dialogues': sample_dialogues,
                        'other_chars_info': other_chars_info,
                        'background_story': background_story,
                        'current_dialogue_count': current_count  # ソート用
                    })
            
            # セリフが 少ない キャラクター 優先 ソート
            chars_to_generate.sort(key=lambda x: x['current_dialogue_count'])
            
            # 順次 キャッシュ生成 (5秒 間隔)
            if chars_to_generate:
                print(f"[AI] {len(chars_to_generate)}個 キャラクター キャッシュ生成 必要 (セリフ 少ない 順)")
                for i, c in enumerate(chars_to_generate):
                    print(f"  {i+1}. {c['name']} (現在 {c['current_dialogue_count']}個)")
                self._ai_cache_queue = chars_to_generate
                self._ai_cache_index = 0
                self._process_next_ai_cache()
            else:
                print("[AI] すべての キャラクター キャッシュ 既に 存在")
                
        except Exception as e:
            print(f"[AI] キャッシュ生成中 エラー: {e}")
    
    def _process_next_ai_cache(self):
        """AI キャッシュ キューから 次 キャラクター 処理"""
        if not hasattr(self, '_ai_cache_queue') or self._ai_cache_index >= len(self._ai_cache_queue):
            print("[AI] すべての キャラクター キャッシュ生成 要求 完了")
            self._current_ai_mode = None
            # すべての キャラクターの 生成 状態 クリア
            for char in self.characters:
                char.generating_status = ""
                char.update()
            return
        
        char_info = self._ai_cache_queue[self._ai_cache_index]
        char_id = char_info['char_id']
        print(f"[AI] {char_info['name']} セリフ 生成中... ({self._ai_cache_index + 1}/{len(self._ai_cache_queue)})")
        
        # 現在 モード 設定 および 次 インデックス 事前に 保存
        self._current_ai_mode = 'cache'
        self._ai_cache_index += 1
        has_more = self._ai_cache_index < len(self._ai_cache_queue)
        self._cache_has_more = has_more  # インスタンス 変数で 保存
        
        # 該当 キャラクターに 生成中 表示
        for char in self.characters:
            if char.char_id == char_id:
                char.generating_status = "セリフ 生成中..."
                char.update()
                break
        
        # キューを 使用して メイン スレッドから 処理
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error,  # エラー フラグ
                '_has_more_cache': has_more  # 次 処理 可否 伝達
            })

        # 既存 セリフ 取得 (重複 防止用)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_info['name'],
            char_info['personality'],
            char_info['sample_dialogues'],
            char_info['other_chars_info'],
            on_complete,
            char_info.get('background_story', ''),
            0,
            existing
        )
    
    def generate_dialogues_now(self, btn=None):
        """今すぐセリフ生成 (ボタン クリック時) - キャラクター選択 ポップアップ"""
        if not self.gemini_api_key:
            QMessageBox.warning(None, "APIキー必要", "まずGemini APIキーを入力してください。")
            return
        
        # 既に 生成中かどうか 確認
        if getattr(self, '_is_generating_now', False):
            QMessageBox.information(None, "生成中", "すでにセリフを生成しています。\nしばらくお待ちください。")
            return
        
        # 性格が設定された キャラクターが あるか 確認
        chars_with_personality = [c for c in self.characters if c.personality]
        if not chars_with_personality:
            QMessageBox.warning(None, "キャラクターなし", "性格が設定されているキャラクターがいません。\nキャラクターの性格を先に設定してください。")
            return
        
        # キャラクター選択ダイアログ 表示
        dialog = QDialog(self)
        dialog.setWindowTitle("今すぐセリフ生成")
        dialog.setMinimumSize(350, 450)  # 最小 サイズ (内容に 合わせて 伸びる)
        dialog.setMaximumHeight(600)  # 最大 高く 制限
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                color: #5A9C85;
            }
            QCheckBox {
                color: #5A9C85;
                font-size: 15px;
                spacing: 10px;
                padding: 8px;
            }
            QCheckBox::indicator {
                width: 20px;
                height: 20px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # タイトル
        title = QLabel("セリフを生成するキャラクター選択")
        title.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 18px; font-weight: 700; color: #5A9C85;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # スクロール 領域
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setMinimumHeight(280)  # スクロール 領域 最小 高く 増加
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                background-color: white;
            }
            QScrollBar:vertical {
                background: #F0F0F0;
                width: 12px;
                border-radius: 6px;
                margin: 6px 2px;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 5px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background: #8ECFB5;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        scroll.viewport().setStyleSheet("background-color: white; border-radius: 10px;")
        
        scroll_content = QWidget()
        scroll_content.setStyleSheet("background-color: white; border-radius: 10px;")
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setSpacing(5)
        scroll_layout.setContentsMargins(15, 15, 15, 15)
        scroll_layout.setAlignment(Qt.AlignTop)  # 上記側 ソート
        
        # キャラクター別 チェックボックス
        checkboxes = {}
        for char in chars_with_personality:
            char_name = self.character_data.get(char.char_id, {}).get('name', f'キャラクター {char.char_id + 1}')
            cb = QCheckBox(char_name)
            cb.setChecked(True)  # 基本敵として 選択される
            cb.setMinimumHeight(35)  # チェックボックス 最小 高く
            checkboxes[char.char_id] = cb
            scroll_layout.addWidget(cb)
        
        scroll.setWidget(scroll_content)
        layout.addWidget(scroll, 1)  # stretch factor 1で スクロール 領域が 空間 占める
        
        # 全選択/解除 ボタン
        select_layout = QHBoxLayout()
        select_all_btn = QPushButton("全選択")
        select_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border-radius: 12px;
                padding: 8px 15px;
                font-weight: 700;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        select_all_btn.clicked.connect(lambda: [cb.setChecked(True) for cb in checkboxes.values()])
        
        deselect_all_btn = QPushButton("全解除")
        deselect_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #B0BEC5;
                color: white;
                border-radius: 12px;
                padding: 8px 15px;
                font-weight: 700;
            }
            QPushButton:hover { background-color: #90A4AE; }
        """)
        deselect_all_btn.clicked.connect(lambda: [cb.setChecked(False) for cb in checkboxes.values()])
        
        select_layout.addWidget(select_all_btn)
        select_layout.addWidget(deselect_all_btn)
        layout.addLayout(select_layout)
        
        # 生成 ボタン
        generate_btn = QPushButton("セリフ生成")
        generate_btn.setMinimumHeight(45)
        generate_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border-radius: 12px;
                font-size: 17px;
                font-weight: 700;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        
        def start_generation():
            # 選択された キャラクター ID 収集
            selected_ids = [cid for cid, cb in checkboxes.items() if cb.isChecked()]
            if not selected_ids:
                QMessageBox.warning(dialog, "選択 必要", "少なくとも1体のキャラクターを選択してください。")
                return
            dialog.accept()
            self._generate_for_selected_characters(selected_ids, btn)
        
        generate_btn.clicked.connect(start_generation)
        layout.addWidget(generate_btn)
        
        dialog.exec_()
    
    def _generate_for_selected_characters(self, selected_ids, btn=None):
        """選択された キャラクターたちに について 今すぐセリフ生成"""
        # 生成中 状態 設定
        self._is_generating_now = True
        
        # ボタン 無効化
        if btn:
            btn.setEnabled(False)
            btn.setText(f"生成中... 0/{len(selected_ids)}")
        
        print(f"[AI] 今すぐセリフ生成 開始 - 選択された {len(selected_ids)}個 キャラクター")
        
        # 選択された キャラクターのみ セリフ追加
        self._generate_now_queue = []
        
        for char in self.characters:
            if char.char_id not in selected_ids:
                continue
            if not char.personality:
                continue
            
            char_data = self.character_data.get(char.char_id, {})
            
            # 他の キャラクター 情報 収集
            other_chars_info = []
            for other in self.characters:
                if other.char_id != char.char_id:
                    other_name = self.character_data.get(other.char_id, {}).get('name', f'キャラクター {other.char_id + 1}')
                    nicknames = char.nicknames.get(other.char_id, other_name)
                    rel_key = tuple(sorted([char.char_id, other.char_id]))
                    # 関係 情報 - 辞書 形態から 現在 キャラクターの 感情 抽出
                    rel_data = self.relationships.get(rel_key, {})
                    if isinstance(rel_data, dict):
                        relationship = rel_data.get(char.char_id, "友達")
                    else:
                        relationship = rel_data if rel_data else "友達"
                    story = char.stories.get(other.char_id, "") if hasattr(char, 'stories') else ""
                    other_chars_info.append((other_name, nicknames, relationship, story))
            
            # 重複 名前 処理
            other_chars_info = make_unique_names(other_chars_info)
            
            sample_dialogues = char.dialogues.get('基本', [])
            sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '（任意）']
            
            background_story = char_data.get('background_story', '') or getattr(char, 'background_story', '')
            
            self._generate_now_queue.append({
                'char_id': char.char_id,
                'name': char.char_name,
                'personality': char.personality,
                'sample_dialogues': sample_dialogues,
                'other_chars_info': other_chars_info,
                'background_story': background_story
            })
        
        if self._generate_now_queue:
            self._generate_now_index = 0
            self._generate_now_btn = btn
            self._process_next_generate_now()
        else:
            self._is_generating_now = False
            if btn:
                btn.setEnabled(True)
                btn.setText("今すぐセリフ生成")
    
    def _process_next_generate_now(self):
        """今すぐセリフ生成 キュー 処理"""
        try:
            if self._generate_now_index >= len(self._generate_now_queue):
                print("[AI] 今すぐセリフ生成 完了")
                self._is_generating_now = False
                self._current_ai_mode = None
                if self._generate_now_btn:
                    self._generate_now_btn.setEnabled(True)
                    self._generate_now_btn.setText("今すぐセリフ生成")
                return
            
            char_info = self._generate_now_queue[self._generate_now_index]
            char_id = char_info.get('char_id')
            total = len(self._generate_now_queue)
            current = self._generate_now_index + 1
            print(f"[AI] {char_info.get('name', 'キャラクター')} セリフ 生成中... ({current}/{total})")
            
            # 現在 モード 設定
            self._current_ai_mode = 'generate_now'
            
            # ボタン テキスト アップデート
            if self._generate_now_btn:
                self._generate_now_btn.setText(f"生成中... {current}/{total}")
            
            # 生成中 表示
            for char in self.characters:
                if char.char_id == char_id:
                    char.generating_status = "セリフ 生成中..."
                    char.update()
                    break
            
            # キューを 使用して メイン スレッドから 処理
            def on_complete(solo, interaction, fallback, is_error=False):
                try:
                    self._ai_complete_queue.append({
                        'char_id': char_id,
                        'solo': solo if solo else [],
                        'interaction': interaction if interaction else {},
                        'fallback': fallback if fallback else [],
                        'is_error': is_error  # エラー フラグ
                    })
                except Exception as e:
                    print(f"[AI] コールバック 処理 エラー: {e}")
            
            # 既存 セリフ 取得 (重複 防止用)
            existing = _ai_dialogues_cache.get(char_id, None)

            generate_dialogues_batch(
                char_info.get('name', ''),
                char_info.get('personality', ''),
                char_info.get('sample_dialogues', []),
                char_info.get('other_chars_info', []),
                on_complete,
                char_info.get('background_story', ''),
                0,
                existing
            )
        except Exception as e:
            print(f"[AI] セリフ生成 処理 中 エラー: {type(e).__name__}: {e}")
            self._is_generating_now = False
            self._current_ai_mode = None
            if hasattr(self, '_generate_now_btn') and self._generate_now_btn:
                try:
                    self._generate_now_btn.setEnabled(True)
                    self._generate_now_btn.setText("今すぐセリフ生成")
                except:
                    pass
    
    def _process_ai_complete_queue(self):
        """AI 完了 キュー 処理 (メイン スレッドから 実行)"""
        if not self._ai_complete_queue:
            return
        
        try:
            # キューから 一つ 取り出す
            item = self._ai_complete_queue.pop(0)
            char_id = item.get('char_id')
            solo = item.get('solo', []) or []
            interaction = item.get('interaction', {}) or {}
            fallback = item.get('fallback', []) or []
            is_error = item.get('is_error', False)  # エラー フラグ 確認
            
            # キャラクター 名前 → ID マッピング 生成
            name_to_id = {}
            for cid, cdata in self.character_data.items():
                cname = cdata.get('name', '')
                if cname:
                    name_to_id[cname] = cid
            
            # (N) パターン 削除 関数
            import re
            def strip_number_suffix(name):
                """名前から (2), (3) 等の 接尾辞 削除"""
                return re.sub(r'\(\d+\)$', '', name).strip()
            
            # interaction キーを 名前から IDで 変換
            interaction_by_id = {}
            if isinstance(interaction, dict):
                print(f"[AI] 相互作用 セリフ キーたち: {list(interaction.keys())}")
                print(f"[AI] 名前→ID マッピング: {name_to_id}")
                
                for key, dialogues in interaction.items():
                    if key == 'default':
                        # defaultは そのまま維持
                        interaction_by_id['default'] = dialogues
                    elif key in name_to_id:
                        # 正確に 一致する 名前
                        target_id = name_to_id[key]
                        if target_id not in interaction_by_id:
                            interaction_by_id[target_id] = []
                        interaction_by_id[target_id].extend(dialogues if dialogues else [])
                        print(f"[AI] 名前 '{key}' → ID {target_id} マッチ 成功")
                    else:
                        # (N) パターン 削除 後 再度 試行
                        base_name = strip_number_suffix(key)
                        if base_name in name_to_id:
                            target_id = name_to_id[base_name]
                            if target_id not in interaction_by_id:
                                interaction_by_id[target_id] = []
                            interaction_by_id[target_id].extend(dialogues if dialogues else [])
                            print(f"[AI] 名前 '{key}' → '{base_name}' → ID {target_id} マッチ 成功")
                        elif isinstance(key, int):
                            # 既に IDである 場合
                            if key not in interaction_by_id:
                                interaction_by_id[key] = []
                            interaction_by_id[key].extend(dialogues if dialogues else [])
                        else:
                            # 部分マッチ試行
                            matched = False
                            for name, cid in name_to_id.items():
                                if name in key or key in name:
                                    if cid not in interaction_by_id:
                                        interaction_by_id[cid] = []
                                    interaction_by_id[cid].extend(dialogues if dialogues else [])
                                    print(f"[AI] 名前 '{key}' 部分マッチ → '{name}' → ID {cid}")
                                    matched = True
                                    break
                            if not matched:
                                print(f"[AI] 相互作用 セリフ キー マッチ 失敗: '{key}'")
            
            global _ai_dialogues_cache
            
            # エラーが 発生な 場合 既存 キャッシュ 完全 保存 (何も しな ない)
            if is_error:
                print(f"[AI] char_id={char_id} エラー 発生 - 既存 キャッシュ 維持 (変更 なし)")
            # 空の データが 返すされた 場合も 既存 キャッシュ 保存
            elif not solo and not interaction_by_id and not fallback:
                print(f"[AI] char_id={char_id} 空の データ 返す - 既存 キャッシュ 維持")
            # 既存 キャッシュが いれば 追加 (重複 削除)
            elif char_id in _ai_dialogues_cache:
                cache = _ai_dialogues_cache[char_id]
                if 'solo' not in cache:
                    cache['solo'] = []
                if 'fallback' not in cache:
                    cache['fallback'] = []

                # solo セリフ 重複/類似 削除 後 追加
                added_solo = 0
                skipped_similar = 0
                for d in solo:
                    if not d or not d.strip():
                        continue
                    if is_similar_dialogue(d, cache['solo']):
                        skipped_similar += 1
                        continue
                    cache['solo'].append(d)
                    added_solo += 1

                # fallback セリフ 重複/類似 削除 後 追加
                added_fallback = 0
                for d in fallback:
                    if not d or not d.strip():
                        continue
                    if is_similar_dialogue(d, cache['fallback']):
                        continue
                    cache['fallback'].append(d)
                    added_fallback += 1

                if 'interaction' not in cache:
                    cache['interaction'] = {}

                # interaction セリフ 重複/類似 削除 後 追加
                added_interaction = {}
                skipped_interaction = 0
                for key, dialogues in interaction_by_id.items():
                    if key not in cache['interaction']:
                        cache['interaction'][key] = []
                    added_count = 0
                    for d in (dialogues if dialogues else []):
                        if not d or not d.strip():
                            continue
                        if is_similar_dialogue(d, cache['interaction'][key]):
                            skipped_interaction += 1
                            continue
                        cache['interaction'][key].append(d)
                        added_count += 1
                    if added_count > 0:
                        added_interaction[key] = added_count
                cache['generated_at'] = time.time()

                # 相互作用 セリフ 統計 出力 (実際 追加された 個数)
                interaction_stats = ", ".join([f"{k}:+{v}" for k, v in added_interaction.items()])
                total_skipped = skipped_similar + skipped_interaction
                print(f"[AI] char_id={char_id} キャッシュ 追加 (solo +{added_solo}, 類似 スキップ {total_skipped}, interaction: {interaction_stats})")
                # 成功 時 即時 保存
                self.save_characters()
            else:
                # 新しい キャッシュ生成
                _ai_dialogues_cache[char_id] = {
                    'solo': solo,
                    'interaction': interaction_by_id,
                    'fallback': fallback,
                    'reference': {},  # 参考用手動セリフ
                    'generated_at': time.time()
                }
                # 相互作用 セリフ 統計 出力
                interaction_stats = ", ".join([f"{k}:{len(v)}個" for k, v in interaction_by_id.items()])
                print(f"[AI] char_id={char_id} 新しい キャッシュ生成 (solo {len(solo)}個, interaction: {interaction_stats})")
                # 成功 時 即時 保存
                self.save_characters()
            
            # 生成 状態 クリア
            for c in self.characters:
                if c.char_id == char_id:
                    c.generating_status = ""
                    c.update()
                    break
            
            # モードに 合わせて 次 処理 (エラーでも 次 キャラクターで 進行)
            if self._current_ai_mode == 'generate_now':
                self._generate_now_index += 1
                if self._generate_now_index < len(self._generate_now_queue):
                    total = len(self._generate_now_queue)
                    next_idx = self._generate_now_index + 1
                    if self._generate_now_btn:
                        self._generate_now_btn.setText(f"待機 中... {next_idx}/{total}")
                    QTimer.singleShot(60000, self._process_next_generate_now)
                else:
                    print("[AI] 今すぐセリフ生成 完了")
                    self._is_generating_now = False
                    self._current_ai_mode = None
                    if self._generate_now_btn:
                        self._generate_now_btn.setEnabled(True)
                        self._generate_now_btn.setText("今すぐセリフ生成")
            
            elif self._current_ai_mode == 'uncached':
                self._uncached_index += 1
                if self._uncached_index < len(self._uncached_queue):
                    QTimer.singleShot(60000, self._process_next_uncached)
                else:
                    self._current_ai_mode = None
            
            elif self._current_ai_mode == 'cache':
                # _has_more_cache 確認して 次 キャラクター 処理
                if item.get('_has_more_cache', False):
                    QTimer.singleShot(60000, self._process_next_ai_cache)
            
            elif self._current_ai_mode == 'single':
                self._current_ai_mode = None
                self.update_ai_timer_interval()
            
            elif self._current_ai_mode == 'add':
                # _has_more_add 確認して 次 キャラクター 処理
                if item.get('_has_more_add', False):
                    QTimer.singleShot(60000, self._process_next_ai_add)
                    
        except Exception as e:
            print(f"[AI] キュー 処理 中 エラー: {type(e).__name__}: {e}")
            # エラーが 発生しても 続ける 進行
            self._is_generating_now = False
            self._current_ai_mode = None
            if hasattr(self, '_generate_now_btn') and self._generate_now_btn:
                try:
                    self._generate_now_btn.setEnabled(True)
                    self._generate_now_btn.setText("今すぐセリフ生成")
                except:
                    pass
    
    def regenerate_ai_cache(self):
        """AI セリフ キャッシュ 再生成/追加
        - キャッシュ なければ: キャッシュ ない すべての キャラクター 順次 生成
        - キャッシュ いれば: 既存 セリフに 追加 (1時間ごとに)
        """
        if not self.ai_enabled:
            return
        
        global _ai_dialogues_cache
        
        # キャッシュが ない キャラクター 探す (ai_auto_generate チェック)
        uncached_chars = []
        for char in self.characters:
            char_data = self.character_data.get(char.char_id, {})
            ai_auto = char_data.get('ai_auto_generate', True)
            
            if not ai_auto:
                continue  # 自動生成 無効化
            
            if char.personality and char.char_id not in _ai_dialogues_cache:
                # セリフ こと 計算 (ソート用)
                cache = _ai_dialogues_cache.get(char.char_id, {})
                current_count = len(cache.get('solo', [])) + sum(len(v) for v in cache.get('interaction', {}).values())
                uncached_chars.append((char, current_count))
        
        if uncached_chars:
            # セリフ 少ない 順 ソート
            uncached_chars.sort(key=lambda x: x[1])
            
            # キャッシュ ない キャラクターたち すべて 順次 生成
            print(f"[AI] キャッシュ ない キャラクター {len(uncached_chars)}体 発見 - 順次 生成 (セリフ 少ない 順)")
            self._uncached_queue = []
            
            for char, _ in uncached_chars:
                char_data = self.character_data.get(char.char_id, {})
                
                # 他の キャラクター 情報 収集
                other_chars_info = []
                for other in self.characters:
                    if other.char_id != char.char_id:
                        other_name = self.character_data.get(other.char_id, {}).get('name', f'キャラクター {other.char_id + 1}')
                        nicknames = char.nicknames.get(other.char_id, other_name)
                        rel_key = tuple(sorted([char.char_id, other.char_id]))
                        # 関係 情報 - 辞書 形態から 現在 キャラクターの 感情 抽出
                        rel_data = self.relationships.get(rel_key, {})
                        if isinstance(rel_data, dict):
                            relationship = rel_data.get(char.char_id, "友達")
                        else:
                            relationship = rel_data if rel_data else "友達"
                        story = char.stories.get(other.char_id, "") if hasattr(char, 'stories') else ""
                        other_chars_info.append((other_name, nicknames, relationship, story))
                
                # 重複 名前 処理
                other_chars_info = make_unique_names(other_chars_info)
                
                sample_dialogues = char.dialogues.get('基本', [])
                sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '（任意）']
                
                background_story = char_data.get('background_story', '') or getattr(char, 'background_story', '')
                
                self._uncached_queue.append({
                    'char_id': char.char_id,
                    'name': char.char_name,
                    'personality': char.personality,
                    'sample_dialogues': sample_dialogues,
                    'other_chars_info': other_chars_info,
                    'background_story': background_story
                })
            
            self._uncached_index = 0
            self._process_next_uncached()
        else:
            # すべての キャラクターに セリフ追加
            print("[AI] 既存 キャッシュに セリフ追加")
            self.add_dialogues_to_cache()
        
        # タイマー 間隔 再調整
        self.update_ai_timer_interval()
    
    def _process_next_uncached(self):
        """キャッシュ ない キャラクター 順次 生成"""
        if self._uncached_index >= len(self._uncached_queue):
            print("[AI] キャッシュ ない キャラクター 生成 完了")
            self._current_ai_mode = None
            return
        
        char_info = self._uncached_queue[self._uncached_index]
        char_id = char_info['char_id']
        print(f"[AI] {char_info['name']} キャッシュ生成中... ({self._uncached_index + 1}/{len(self._uncached_queue)})")
        
        # 現在 モード 設定
        self._current_ai_mode = 'uncached'
        
        # 生成中 表示
        for char in self.characters:
            if char.char_id == char_id:
                char.generating_status = "セリフ 生成中..."
                char.update()
                break
        
        # キューを 使用して メイン スレッドから 処理
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error  # エラー フラグ
            })

        # 既存 セリフ 取得 (重複 防止用)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_info['name'],
            char_info['personality'],
            char_info['sample_dialogues'],
            char_info['other_chars_info'],
            on_complete,
            char_info.get('background_story', ''),
            0,
            existing
        )

    def generate_single_character_cache(self, char_id):
        """単独 キャラクターの 生成された セリフ生成"""
        if not self.ai_enabled or not self.gemini_api_key:
            return
        
        # キャラクター 探す
        target_char = None
        for char in self.characters:
            if char.char_id == char_id:
                target_char = char
                break
        
        if not target_char or not target_char.personality:
            return
        
        char_data = self.character_data.get(char_id, {})
        char_name = char_data.get('name', f'キャラクター {char_id + 1}')
        
        # 他の キャラクター 情報 収集
        other_chars_info = []
        for other in self.characters:
            if other.char_id != char_id:
                other_data = self.character_data.get(other.char_id, {})
                other_name = other_data.get('name', f'キャラクター {other.char_id + 1}')
                nicknames = target_char.nicknames.get(other.char_id, other_name)
                rel_key = tuple(sorted([char_id, other.char_id]))
                # 関係 情報 - 辞書 形態から 現在 キャラクターの 感情 抽出
                rel_data = self.relationships.get(rel_key, {})
                if isinstance(rel_data, dict):
                    relationship = rel_data.get(char_id, "友達")
                else:
                    relationship = rel_data if rel_data else "友達"
                story = target_char.stories.get(other.char_id, "") if hasattr(target_char, 'stories') else ""
                other_chars_info.append((other_name, nicknames, relationship, story))
        
        # 重複 名前 処理
        other_chars_info = make_unique_names(other_chars_info)
        
        sample_dialogues = target_char.dialogues.get('基本', [])
        sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '（任意）']
        
        # 背景 ストーリー
        background_story = char_data.get('background_story', '') or getattr(target_char, 'background_story', '')
        
        # 現在 モード 設定
        self._current_ai_mode = 'single'
        
        # 生成中 表示
        target_char.generating_status = "セリフ 生成中..."
        target_char.update()
        
        print(f"[AI] {char_name} 単独 キャラクター セリフ生成 開始")
        
        # キューを 使用して メイン スレッドから 処理
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error  # エラー フラグ
            })

        # 既存 セリフ 取得 (重複 防止用)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_name,
            target_char.personality,
            sample_dialogues,
            other_chars_info,
            on_complete,
            background_story,
            0,
            existing
        )

    def add_dialogues_to_cache(self):
        """既存 キャッシュに セリフ追加"""
        # セリフ追加する キャラクター キュー 生成
        chars_to_add = []
        
        for char in self.characters:
            if not char.personality:
                continue
            if char.char_id not in _ai_dialogues_cache:
                continue  # キャッシュ なければ スキップ (generate_ai_cacheから 処理)
            
            # ai_auto_generate チェック
            char_data = self.character_data.get(char.char_id, {})
            ai_auto = char_data.get('ai_auto_generate', True)
            if not ai_auto:
                continue  # 自動生成 無効化
            
            # 現在 セリフ こと 計算 (ソート用)
            cache = _ai_dialogues_cache.get(char.char_id, {})
            current_count = len(cache.get('solo', [])) + sum(len(v) for v in cache.get('interaction', {}).values())
            
            # 他の キャラクター 情報 収集
            other_chars_info = []
            for other in self.characters:
                if other.char_id != char.char_id:
                    nicknames = char.nicknames.get(other.char_id, other.char_name)
                    rel_key = tuple(sorted([char.char_id, other.char_id]))
                    # 関係 情報 - 辞書 形態から 現在 キャラクターの 感情 抽出
                    rel_data = self.relationships.get(rel_key, {})
                    if isinstance(rel_data, dict):
                        relationship = rel_data.get(char.char_id, "友達")
                    else:
                        relationship = rel_data if rel_data else "友達"
                    story = char.stories.get(other.char_id, "")
                    other_chars_info.append((other.char_name, nicknames, relationship, story))
            
            # 重複 名前 処理
            other_chars_info = make_unique_names(other_chars_info)
            
            sample_dialogues = char.dialogues.get('基本', [])
            sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '（任意）']
            
            # 背景 ストーリー
            background_story = char_data.get('background_story', '') or getattr(char, 'background_story', '')
            
            chars_to_add.append({
                'char_id': char.char_id,
                'name': char.char_name,
                'personality': char.personality,
                'sample_dialogues': sample_dialogues,
                'other_chars_info': other_chars_info,
                'background_story': background_story,
                'current_dialogue_count': current_count
            })
        
        # セリフ 少ない キャラクター 優先 ソート
        chars_to_add.sort(key=lambda x: x['current_dialogue_count'])
        
        self._ai_add_queue = chars_to_add
        
        if self._ai_add_queue:
            print(f"[AI] {len(self._ai_add_queue)}個 キャラクターに セリフ追加 (セリフ 少ない 順)")
            self._ai_add_index = 0
            self._process_next_ai_add()
    
    def _process_next_ai_add(self):
        """セリフ追加 処理 (キューから 一つずつ)"""
        if self._ai_add_index >= len(self._ai_add_queue):
            print("[AI] セリフ追加 完了")
            self._current_ai_mode = None
            return
        
        char_info = self._ai_add_queue[self._ai_add_index]
        char_id = char_info['char_id']
        print(f"[AI] {char_info['name']} セリフ追加 中... ({self._ai_add_index + 1}/{len(self._ai_add_queue)})")
        
        # 現在 モード 設定 および 次 インデックス 事前に 保存
        self._current_ai_mode = 'add'
        self._ai_add_index += 1
        has_more = self._ai_add_index < len(self._ai_add_queue)
        
        # キューを 使用して メイン スレッドから 処理
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error,  # エラー フラグ
                '_has_more_add': has_more  # 次 処理 可否 伝達
            })

        # 既存 セリフ 取得 (重複 防止用)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_info['name'],
            char_info['personality'],
            char_info['sample_dialogues'],
            char_info['other_chars_info'],
            on_complete,
            char_info.get('background_story', ''),
            0,
            existing
        )

    def check_collisions(self):
        """キャラクター 間 衝突 チェック"""
        try:
            for i, char1 in enumerate(self.characters):
                for char2 in self.characters[i+1:]:
                    if char1.check_collision_with(char2):
                        char1.interact_with(char2)
        except Exception as e:
            # 強制 終了 防止
            print(f"[エラー] check_collisions エラー: {e}")
    
    def save_characters(self):
        """キャラクター 設定 保存"""
        # 復元 後には 保存しな ない (復元された ファイル 保護)
        if getattr(self, '_skip_save_on_close', False):
            print("[保存 スキップ] 復元 モード - 保存しな ない")
            return

        import json

        print(f"[保存 開始] キャラクター こと: {len(self.character_data)}")
        
        # AI キャッシュ 保存用 (generated_atは 保存 しない)
        global _ai_dialogues_cache
        ai_cache_to_save = {}
        total_dialogues = 0
        for char_id, cache_data in _ai_dialogues_cache.items():
            solo_count = len(cache_data.get('solo', []))
            interaction_count = sum(len(v) for v in cache_data.get('interaction', {}).values())
            fallback_count = len(cache_data.get('fallback', []))
            total_dialogues += solo_count + interaction_count + fallback_count
            
            ai_cache_to_save[str(char_id)] = {
                'solo': cache_data.get('solo', []),
                'interaction': cache_data.get('interaction', {}),
                'fallback': cache_data.get('fallback', []),
                'reference': cache_data.get('reference', {})  # 参考用手動セリフ
            }
            print(f"[保存] AI キャッシュ キャラクター {char_id}: solo={solo_count}, interaction={interaction_count}, fallback={fallback_count}")
        
        print(f"[保存] AI キャッシュ 合計 {len(ai_cache_to_save)}個 キャラクター, {total_dialogues}個 セリフ")

        # 現在 キャッシュが 空であれば 既存 保存された キャッシュ 維持 (セリフ 損失 防止)
        if not ai_cache_to_save and os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    existing_config = json.load(f)
                    existing_cache = existing_config.get('ai_dialogues_cache', {})
                    if existing_cache:
                        ai_cache_to_save = existing_cache
                        print(f"[保存] 現在 キャッシュ 空で - 既存 キャッシュ {len(existing_cache)}個 維持")
            except Exception as e:
                print(f"[保存] 既存 キャッシュ 読み込み 失敗: {e}")

        config = {
            'char_id_counter': self.char_id_counter,
            'characters': [],
            'relationships': {},
            'dialogues': {},
            'gemini_api_key': self.gemini_api_key,  # API キー 保存
            'gemini_model': self.gemini_model,  # AI モデル 保存
            'ai_enabled': self.ai_enabled,  # AI 有効化 状態 保存
            'ai_dialogues_cache': ai_cache_to_save,  # AI セリフ キャッシュ 保存
            'selected_monitor': getattr(self, '_selected_monitor', 0),  # モニター 設定 保存
            'auto_backup_enabled': getattr(self, 'auto_backup_enabled', True),  # 自動バックアップ 設定
            'max_backups': getattr(self, 'max_backups', 12)  # バックアップ保管こと
        }
        
        # 関係 情報 保存 (正規化された 形式: {"min_id,max_id": {id1: "感情", id2: "感情"}})
        print(f"[保存] self.relationships 保存 前: {self.relationships}")
        for key, value in self.relationships.items():
            # keyがタプルかどうか 確認
            if not isinstance(key, tuple) or len(key) != 2:
                print(f"[保存] よくできなかったらされた 関係 キー 無視: {key}")
                continue
            # キーを 常に ソートして 保存 (一貫性 維持)
            sorted_key = tuple(sorted(key))
            key_str = f"{sorted_key[0]},{sorted_key[1]}"

            # value 正規化: {char_id: "感情", other_id: "感情"} 形式として 統一
            if isinstance(value, dict):
                filtered_value = {}
                for k, v in value.items():
                    # キーを intで 変換 試行
                    try:
                        k_int = int(k)
                    except (ValueError, TypeError):
                        continue
                    # 値が 文字列なら そのまま, でなければ デフォルト
                    if isinstance(v, str):
                        filtered_value[k_int] = v
                    elif isinstance(v, dict) and 'my_feeling' in v:
                        # レガシー ネスト dict 形式 処理
                        filtered_value[k_int] = v.get('my_feeling', '無関心')
                    else:
                        filtered_value[k_int] = "無関心"
                config['relationships'][key_str] = filtered_value
            elif isinstance(value, str):
                # レガシー シンプル 文字列 形式 -> 現在 形式として 変換
                config['relationships'][key_str] = {
                    sorted_key[0]: value,
                    sorted_key[1]: "無関心"
                }
            else:
                continue
            print(f"[保存] 関係 保存: {key_str} -> {config['relationships'][key_str]}")
        
        print(f"[保存] 関係 こと: {len(config['relationships'])}")
        
        # セリフ 情報 保存
        for char_id, dialogues in self.dialogues.items():
            config['dialogues'][str(char_id)] = dialogues
        
        print(f"[保存] セリフ こと: {len(config['dialogues'])}")
        
        for char_id, data in self.character_data.items():
            # 画像を base64で エンコーディングして 保存
            import base64
            try:
                print(f"[保存] キャラクター {char_id}: {data.get('name', '名前なし')}")
                with open(data['image_path'], 'rb') as f:
                    image_data = base64.b64encode(f.read()).decode('utf-8')
                
                config['characters'].append({
                    'char_id': char_id,
                    'name': data['name'],
                    'scale': data['scale'],
                    'bubble_color': data['bubble_color'],
                    'bubble_size': data.get('bubble_size', 100),
                    'facing_direction': data['facing_direction'],
                    'image_data': image_data,
                    'image_ext': os.path.splitext(data['image_path'])[1],
                    'is_active': data.get('is_active', True),
                    'personality': data.get('personality', ''),
                    'nicknames': data.get('nicknames', {}),
                    'stories': data.get('stories', {}),
                    'background_story': data.get('background_story', ''),
                    'sample_dialogues': data.get('sample_dialogues', []),
                    'catchphrase': data.get('catchphrase', ''),
                    'ai_auto_generate': data.get('ai_auto_generate', True)  # AI 自動生成 可否
                })
            except Exception as e:
                print(f"[エラー] キャラクター {char_id} 保存 失敗: {e}")
        
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
                f.flush()  # 強制 フラッシュ
                os.fsync(f.fileno())  # ディスクに 強制 書き込み
            
            file_size = os.path.getsize(self.config_file)
            file_size_mb = file_size / (1024 * 1024)
            print(f"[保存完了] ファイル: {self.config_file}")
            print(f"[保存完了] ファイル サイズ: {file_size_mb:.2f} MB ({file_size} bytes)")
            
            if file_size_mb > 30:
                print(f"[警告] 設定 ファイルが 大きいです ({file_size_mb:.2f} MB). キャラクター 画像 サイズを 減らす ことを 推奨します.")
        except Exception as e:
            print(f"[エラー] 保存 失敗: {e}")
            import traceback
            print(traceback.format_exc())

    def create_auto_backup(self):
        """自動バックアップ 生成 (1時間ごとに 呼び出しされる)"""
        # 自動バックアップが オフに いれば スキップ
        if not getattr(self, 'auto_backup_enabled', True):
            return

        if not os.path.exists(self.config_file):
            return

        try:
            from datetime import datetime

            # バックアップ ディレクトリ 生成
            backup_dir = os.path.join(os.path.dirname(self.config_file), 'backups')
            os.makedirs(backup_dir, exist_ok=True)

            # バックアップ ファイル体 生成 (タイムスタンプ 含む)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_filename = f"kiwipet_backup_{timestamp}.json"
            backup_path = os.path.join(backup_dir, backup_filename)

            # 現在 設定 ファイル コピー
            import shutil
            shutil.copy2(self.config_file, backup_path)

            print(f"[バックアップ] 自動バックアップ 生成: {backup_filename}")

            # 古い バックアップ 整理
            self.cleanup_old_backups(backup_dir)

        except Exception as e:
            print(f"[バックアップ] 自動バックアップ 失敗: {e}")

    def cleanup_old_backups(self, backup_dir):
        """古い バックアップ ファイル 削除"""
        max_backups = getattr(self, 'max_backups', 12)
        try:
            backup_files = []
            for f in os.listdir(backup_dir):
                if f.startswith('kiwipet_backup_') and f.endswith('.json'):
                    full_path = os.path.join(backup_dir, f)
                    backup_files.append((full_path, os.path.getmtime(full_path)))

            # 編集 時間 基準 ソート (新しい順)
            backup_files.sort(key=lambda x: x[1], reverse=True)

            # 古い バックアップ 削除
            for backup_path, _ in backup_files[max_backups:]:
                os.remove(backup_path)
                print(f"[バックアップ] 古い バックアップ 削除: {os.path.basename(backup_path)}")

        except Exception as e:
            print(f"[バックアップ] バックアップ 整理 失敗: {e}")

    def get_backup_list(self):
        """バックアップ ファイル リスト 検索"""
        backup_dir = os.path.join(os.path.dirname(self.config_file), 'backups')
        if not os.path.exists(backup_dir):
            return []

        backup_files = []
        try:
            from datetime import datetime
            for f in os.listdir(backup_dir):
                if f.startswith('kiwipet_backup_') and f.endswith('.json'):
                    full_path = os.path.join(backup_dir, f)
                    # ファイルが実際に存在するかどうか確認
                    if not os.path.exists(full_path):
                        continue
                    try:
                        mtime = os.path.getmtime(full_path)
                        size = os.path.getsize(full_path)
                    except (OSError, FileNotFoundError):
                        continue

                    # ファイル体から 日付 抽出
                    try:
                        timestamp_str = f.replace('kiwipet_backup_', '').replace('.json', '')
                        dt = datetime.strptime(timestamp_str, '%Y%m%d_%H%M%S')
                        display_time = dt.strftime('%Y-%m-%d %H:%M:%S')
                    except:
                        display_time = datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M:%S')

                    backup_files.append({
                        'path': full_path,
                        'filename': f,
                        'display_time': display_time,
                        'timestamp_str': timestamp_str if 'timestamp_str' in dir() else '',
                        'mtime': mtime,
                        'size': size,
                        'size_mb': size / (1024 * 1024)
                    })

            # 新しい順 ソート (ファイル体 タイムスタンプ 基準)
            backup_files.sort(key=lambda x: x['filename'], reverse=True)

        except Exception as e:
            print(f"[バックアップ] バックアップ リスト 検索 失敗: {e}")

        return backup_files

    def show_backup_restore_dialog(self):
        """バックアップ 復元 ダイアログ 表示"""
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, QPushButton, QLabel, QMessageBox

        backup_list = self.get_backup_list()

        if not backup_list:
            QMessageBox.information(None, "バックアップなし", "保存されたバックアップファイルがありません。")
            return

        dialog = QDialog()
        dialog.setWindowTitle("バックアップから 復元")
        dialog.setMinimumSize(500, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
            }
            QLabel {
                color: white;
            }
            QListWidget {
                background-color: #3b3b3b;
                color: white;
                border: 1px solid #555;
                border-radius: 5px;
            }
            QListWidget::item {
                padding: 8px;
                border-bottom: 1px solid #444;
            }
            QListWidget::item:selected {
                background-color: #4a9eff;
            }
            QPushButton {
                background-color: #4a4a4a;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QPushButton#restoreBtn {
                background-color: #4a9eff;
            }
            QPushButton#restoreBtn:hover {
                background-color: #5ab0ff;
            }
        """)

        layout = QVBoxLayout(dialog)

        # 説明 ラベル
        desc_label = QLabel("予期せずセリフが消えた場合、以下のバックアップから復元できます。")
        desc_label.setWordWrap(True)
        layout.addWidget(desc_label)

        # バックアップ リスト
        list_widget = QListWidget()
        for backup in backup_list:
            item_text = f"{backup['display_time']} ({backup['size_mb']:.2f} MB)"
            item = QListWidgetItem(item_text)
            item.setData(256, backup['path'])  # Qt.UserRole = 256
            list_widget.addItem(item)
        layout.addWidget(list_widget)

        # ボタン
        btn_layout = QHBoxLayout()

        cancel_btn = QPushButton("キャンセル")
        cancel_btn.clicked.connect(dialog.reject)
        btn_layout.addWidget(cancel_btn)

        btn_layout.addStretch()

        restore_btn = QPushButton("選択した バックアップとして 復元")
        restore_btn.setObjectName("restoreBtn")

        def do_restore():
            current_item = list_widget.currentItem()
            if not current_item:
                QMessageBox.warning(dialog, "選択 必要", "復元する バックアップを 選択してください.")
                return

            backup_path = current_item.data(256)

            reply = QMessageBox.question(
                dialog,
                "復元 確認",
                "選択した バックアップとして 復元しますか?\n\n現在 データは 上書きされます.\n(現在 状態は 自動的に バックアップされます)",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                try:
                    # 現在 状態 まず バックアップ
                    self.create_auto_backup()

                    # バックアップ ファイルで 復元
                    import shutil
                    shutil.copy2(backup_path, self.config_file)

                    # 終了 時 保存 防止 フラグ 設定
                    self._skip_save_on_close = True

                    QMessageBox.information(dialog, "復元 完了", "バックアップから 復元されました.\n\n適用するには プログラムを 再起動してください.")
                    dialog.accept()

                except Exception as e:
                    QMessageBox.critical(dialog, "復元失敗", f"復元 中 エラーが 発生しました:\n{e}")

        restore_btn.clicked.connect(do_restore)
        btn_layout.addWidget(restore_btn)

        layout.addLayout(btn_layout)

        dialog.exec_()

    def set_window_icon(self):
        """ウィンドウ アイコン 設定"""
        # アプリ アイコンは QApplicationから 設定される
        # 追加で ウィンドウ別 アイコンが 必要な 場合 ここで 設定
        app_icon = load_app_icon()
        if app_icon:
            self.setWindowIcon(app_icon)
    
    def _create_default_icon(self):
        """基本 アイコン 直接 生成 (より 以上 使用 しない)"""
        pass
    
    def load_characters(self):
        """キャラクター 設定 読み込み"""
        print(f"[読み込み 開始] 設定 ファイル: {self.config_file}")
        
        if not os.path.exists(self.config_file):
            print("[読み込み] 設定 ファイルなし - 新しく 開始")
            return
        
        try:
            import json
            import base64
            
            # ファイル サイズ チェック
            file_size = os.path.getsize(self.config_file)
            file_size_mb = file_size / (1024 * 1024)
            print(f"[読み込み] 設定 ファイル サイズ: {file_size_mb:.2f} MB")
            
            if file_size_mb > 50:
                print(f"[警告] 設定 ファイルが とても 大きいです ({file_size_mb:.2f} MB). 読み込みに 時間が かかることができます.")
            
            # JSON 読み込み
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                print(f"[読み込み] 設定 ファイル 読み 成功")
            except json.JSONDecodeError as e:
                print(f"[読み込み エラー] JSON パース 失敗: {e}")
                return
            
            self.char_id_counter = config.get('char_id_counter', 0)
            print(f"[読み込み] char_id_counter: {self.char_id_counter}")
            
            # API キー 読み込み (制御文字削除)
            loaded_api_key = config.get('gemini_api_key', '')
            self.gemini_api_key = clean_api_key(loaded_api_key)
            if self.gemini_api_key:
                set_gemini_api_key(self.gemini_api_key)  # グローバル 変数にも 設定
                print(f"[読み込み] API キー 読み込みされる")

            # AI モデル 読み込み
            self.gemini_model = config.get('gemini_model', 'gemini-2.5-flash-lite')
            set_gemini_model(self.gemini_model)  # グローバル 変数にも 設定
            print(f"[読み込み] AI モデル: {self.gemini_model}")

            # AI 有効化 状態 読み込み
            self.ai_enabled = config.get('ai_enabled', False)
            print(f"[読み込み] AI 有効化: {self.ai_enabled}")

            # 自動バックアップ 設定 読み込み
            self.auto_backup_enabled = config.get('auto_backup_enabled', True)
            self.max_backups = config.get('max_backups', 12)
            print(f"[読み込み] 自動バックアップ: {self.auto_backup_enabled}, 保管 個数: {self.max_backups}")

            # タイマー 状態 アップデート
            if hasattr(self, 'auto_backup_timer'):
                if self.auto_backup_enabled:
                    if not self.auto_backup_timer.isActive():
                        self.auto_backup_timer.start(60 * 60 * 1000)  # 1時間
                else:
                    self.auto_backup_timer.stop()

            # AI セリフ キャッシュ 読み込み (個別 try-except)
            try:
                global _ai_dialogues_cache
                saved_cache = config.get('ai_dialogues_cache', {})
                loaded_count = 0
                for char_id_str, cache_data in saved_cache.items():
                    try:
                        char_id = int(char_id_str)
                        
                        # interaction キーを intで 変換 (JSONから 文字列で 保存される)
                        raw_interaction = cache_data.get('interaction', {})
                        converted_interaction = {}
                        for k, v in raw_interaction.items():
                            try:
                                converted_interaction[int(k)] = v
                            except (ValueError, TypeError):
                                # 'default' 同じ 文字列 キーは そのまま維持
                                converted_interaction[k] = v
                        
                        solo_count = len(cache_data.get('solo', []))
                        interaction_count = sum(len(v) for v in converted_interaction.values())
                        fallback_count = len(cache_data.get('fallback', []))

                        _ai_dialogues_cache[char_id] = {
                            'solo': cache_data.get('solo', []),
                            'interaction': converted_interaction,
                            'fallback': cache_data.get('fallback', []),
                            'reference': cache_data.get('reference', {}),  # 参考用手動セリフ
                            'generated_at': time.time()  # 読み込み 時間として 設定
                        }
                        loaded_count += 1
                        print(f"[読み込み] AI キャッシュ キャラクター {char_id}: solo={solo_count}, interaction={interaction_count}, fallback={fallback_count}")
                    except Exception as e:
                        print(f"[読み込み] AI キャッシュ キャラクター {char_id_str} 読み込み エラー: {e}")
                print(f"[読み込み] AI キャッシュ: {loaded_count}個 キャラクター 読み込み 完了")
            except Exception as e:
                print(f"[読み込み] AI キャッシュ 読み込み エラー (続ける 進行): {e}")
            
            # 関係 情報 読み込み (レガシー 形式 マイグレーション 含む)
            relationships_list = config.get('relationships', {})
            print(f"[読み込み] 関係 データ (JSON): {relationships_list}")
            for key_str, value in relationships_list.items():
                try:
                    # "0,1" -> (0, 1)
                    if ',' not in str(key_str):
                        print(f"[読み込み] よくできなかったらされた 関係 キー 形式 無視: {key_str}")
                        continue
                    raw_ids = list(map(int, str(key_str).split(',')))
                    # キーを 常に ソート (一貫性 維持)
                    ids = tuple(sorted(raw_ids))

                    # value 正規化: {char_id: "感情", other_id: "感情"} 形式として 統一
                    if isinstance(value, dict):
                        converted_value = {}
                        for k, v in value.items():
                            try:
                                k_int = int(k)
                            except (ValueError, TypeError):
                                print(f"[読み込み] 関係 内部 キー 変換 失敗: {k}")
                                continue
                            # 値が 文字列なら そのまま, ネストdictなら my_feeling 抽出
                            if isinstance(v, str):
                                converted_value[k_int] = v
                            elif isinstance(v, dict) and 'my_feeling' in v:
                                converted_value[k_int] = v.get('my_feeling', '無関心')
                            else:
                                converted_value[k_int] = "無関心"
                        value = converted_value
                    elif isinstance(value, str):
                        # レガシー シンプル 文字列 形式 -> 現在 形式として 変換
                        value = {ids[0]: value, ids[1]: "無関心"}
                    else:
                        continue

                    # 既存 データと マージ (同じ キーが いれば アップデート)
                    if ids in self.relationships:
                        self.relationships[ids].update(value)
                    else:
                        self.relationships[ids] = value
                    print(f"[読み込み] 関係 読み込み: {ids} -> {self.relationships[ids]}")
                except Exception as e:
                    print(f"[読み込み] 関係 読み込み エラー: key_str={key_str}, value={value}, error={e}")
            
            print(f"[読み込み] 関係 こと: {len(self.relationships)}")
            print(f"[読み込み] self.relationships 読み込み 後: {self.relationships}")
            
            # セリフ 情報 読み込み (個別 try-except)
            try:
                dialogues_data = config.get('dialogues', {})
                for char_id_str, dialogues in dialogues_data.items():
                    try:
                        char_id_int = int(char_id_str)
                        
                        # セリフ キー 形式 統一: int キー → 'char_X' 形式として 変換
                        if isinstance(dialogues, dict):
                            converted_dialogues = {}
                            for key, values in dialogues.items():
                                if key == '基本':
                                    converted_dialogues['基本'] = values
                                elif isinstance(key, int):
                                    # int → 'char_X'
                                    converted_dialogues[f'char_{key}'] = values
                                elif isinstance(key, str) and key.isdigit():
                                    # '0', '1' → 'char_0', 'char_1'
                                    converted_dialogues[f'char_{key}'] = values
                                else:
                                    # 既に 'char_X' 形式がか 他の 形式
                                    converted_dialogues[key] = values
                            dialogues = converted_dialogues
                        
                        self.dialogues[char_id_int] = dialogues
                        # 手動 セリフを AI キャッシュに 同期
                        sync_dialogues_to_ai_cache(char_id_int, dialogues)
                    except Exception as e:
                        print(f"[読み込み] セリフ キャラクター {char_id_str} 読み込み エラー: {e}")
                print(f"[読み込み] セリフ こと: {len(self.dialogues)}")
            except Exception as e:
                print(f"[読み込み] セリフ 読み込み エラー (続ける 進行): {e}")
            
            characters_count = len(config.get('characters', []))
            print(f"[読み込み] キャラクター こと: {characters_count}")
            
            for char_config in config.get('characters', []):
                try:
                    char_id = char_config['char_id']
                    is_active = char_config.get('is_active', True)
                    print(f"[読み込み] キャラクター {char_id}: {char_config.get('name', '名前なし')}, active: {is_active}")
                    
                    # な時 画像 ファイル 生成 - app_dir 内に 保存
                    temp_dir = os.path.join(self.app_dir, 'temp_images')
                    os.makedirs(temp_dir, exist_ok=True)
                    
                    image_path = os.path.join(temp_dir, f"char_{char_id}{char_config['image_ext']}")
                    
                    # base64 デコードして 画像 保存
                    image_data = base64.b64decode(char_config['image_data'])
                    with open(image_path, 'wb') as f:
                        f.write(image_data)
                    
                    # キャラクター ウィジェット 生成
                    char_widget = CharacterWidget(
                        image_path,
                        char_id,
                        char_config['facing_direction'],
                        char_config['scale'],
                        char_config['bubble_color'],
                        char_config.get('bubble_size', 100)
                    )
                    self.characters.append(char_widget)
                    
                    # 無効化 状態なら 非表示
                    if not is_active:
                        char_widget.hide()
                        char_widget.timer.stop()
                    
                    # キャラクター データ 保存 (nicknames, stories キーを intで 変換)
                    raw_nicknames = char_config.get('nicknames', {})
                    raw_stories = char_config.get('stories', {})
                    
                    # キーを intで 変換 (失敗すると 無視)
                    nicknames = {}
                    for k, v in raw_nicknames.items():
                        try:
                            nicknames[int(k)] = v
                        except (ValueError, TypeError):
                            pass
                    
                    stories = {}
                    for k, v in raw_stories.items():
                        try:
                            stories[int(k)] = v
                        except (ValueError, TypeError):
                            pass
                    
                    catchphrase = char_config.get('catchphrase', '')
                    bubble_size = char_config.get('bubble_size', 100)
                    
                    self.character_data[char_id] = {
                        'name': char_config['name'],
                        'scale': char_config['scale'],
                        'bubble_color': char_config['bubble_color'],
                        'bubble_size': bubble_size,
                        'facing_direction': char_config['facing_direction'],
                        'image_path': image_path,
                        'is_active': is_active,
                        'personality': char_config.get('personality', ''),
                        'nicknames': nicknames,
                        'stories': stories,
                        'background_story': char_config.get('background_story', ''),
                        'sample_dialogues': char_config.get('sample_dialogues', []),
                        'catchphrase': catchphrase,
                        'ai_auto_generate': char_config.get('ai_auto_generate', True)  # AI 自動生成 可否
                    }
                    
                    # カード 生成 (is_active, catchphrase 伝達)
                    card = CharacterCard(char_id, image_path, char_config['name'], is_active, catchphrase)
                    card.remove_clicked.connect(self.remove_character)
                    card.change_image_clicked.connect(self.change_character_image)
                    card.change_scale_clicked.connect(self.change_character_scale)
                    card.change_bubble_color_clicked.connect(self.change_bubble_color)
                    card.change_relationships_clicked.connect(self.change_relationships)
                    card.change_dialogues_clicked.connect(self.change_dialogues)
                    card.change_personality_clicked.connect(self.change_personality)
                    card.name_changed.connect(self.update_character_name)
                    card.catchphrase_changed.connect(self.update_character_catchphrase)
                    card.toggle_active.connect(self.toggle_character_active)
                    card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                    
                    # サイズ 表示 アップデート
                    scale = char_config.get('scale', 100)
                    card.update_scale_display(scale)
                    
                    self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                except Exception as e:
                    print(f"[読み込み] キャラクター 読み込み エラー (スキップ): {e}")
                    import traceback
                    print(traceback.format_exc())
            
            # 関係 情報を キャラクターに 伝達
            self.update_character_relationships()
            
            # セリフ 情報を キャラクターに 伝達
            self.update_character_dialogues()
            
            # 性格 情報を キャラクターに 伝達
            self.update_character_personalities()
            
            # モニター 設定 読み込み および 適用
            saved_monitor = config.get('selected_monitor', 0)
            self._selected_monitor = saved_monitor
            self._apply_monitor_to_characters(saved_monitor)
            
            # API ボタン スタイル アップデート
            self.update_api_button_style()
            
            print(f"[読み込み 完了] キャラクター {characters_count}個 読み込みされる")
                
        except Exception as e:
            import traceback
            print(f"[読み込み エラー] {e}")
            print(traceback.format_exc())
    
    def update_api_button_style(self):
        """API ボタン スタイル アップデート (有効化 状態 反映)"""
        if self.ai_enabled and self.gemini_api_key:
            # 有効化 状態: 緑色
            self.api_btn.setText(" API ✓")
            self.api_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: #81C784;
                    color: white;
                    font-weight: 700;
                    border-radius: 12px;
                    font-family: {KOREAN_FONT};
                }}
                QPushButton:hover {{
                    background-color: #66BB6A;
                }}
            """)
            self._set_button_icon(self.api_btn, SVG_KEY.replace('#317C75', '#FFFFFF'), 16)
        else:
            # 無効化 状態: ミント色
            self.api_btn.setText(" API KEY")
            self.api_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: #C5E8D8;
                    color: #317C75;
                    font-weight: 700;
                    border-radius: 12px;
                    font-family: {KOREAN_FONT};
                }}
                QPushButton:hover {{
                    background-color: #B0DBC8;
                }}
            """)
            self._set_button_icon(self.api_btn, SVG_KEY, 16)
    
    def show_settings(self):
        """環境設定 ダイアログ"""
        dialog = QDialog(self)
        dialog.setWindowTitle("環境設定")
        dialog.setMinimumSize(400, 300)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # タイトル
        title = QLabel("環境設定")
        title.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 22px; font-weight: 700; font-family: 'Pretendard JP', 'Meiryo', sans-serif; padding: 10px;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # 区切り線
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line)
        
        # モニター選択 セクション
        monitor_section = QWidget()
        monitor_layout = QVBoxLayout(monitor_section)
        monitor_layout.setSpacing(10)
        
        monitor_label = QLabel("モニター選択")
        monitor_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        monitor_layout.addWidget(monitor_label)
        
        # 使用可能な モニター リスト
        from PyQt5.QtWidgets import QApplication
        screens = QApplication.screens()
        
        self.monitor_combo = QComboBox()
        self.monitor_combo.setMinimumHeight(40)
        self.monitor_combo.setStyleSheet("""
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 8px 12px;
                font-size: 14px;
                font-weight: 700;
            }
            QComboBox:hover {
                border-color: #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #D4F4DD;
            }
        """)
        
        # 現在 選択された モニター 確認
        current_screen_idx = getattr(self, '_selected_monitor', 0)
        
        # "すべてのモニター" オプション 追加
        self.monitor_combo.addItem("🖥️ すべてのモニター (自由 移動)", -1)
        
        for i, screen in enumerate(screens):
            geo = screen.availableGeometry()
            name = screen.name() if screen.name() else f"モニター {i+1}"
            self.monitor_combo.addItem(f"{name} ({geo.width()}x{geo.height()})", i)
        
        # 現在 設定された 値 選択
        if current_screen_idx == -1:
            self.monitor_combo.setCurrentIndex(0)  # "すべてのモニター" 選択
        elif current_screen_idx < len(screens):
            self.monitor_combo.setCurrentIndex(current_screen_idx + 1)  # +1 because "すべてのモニター" is at index 0
        
        monitor_layout.addWidget(self.monitor_combo)
        
        # モニター 説明
        monitor_info = QLabel("キャラクターが活動するモニターを選択します。\n「すべてのモニター」を選択すると、キャラクターがすべての画面を自由に移動します。")
        monitor_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        monitor_layout.addWidget(monitor_info)
        
        layout.addWidget(monitor_section)
        
        # 区切り線
        line2 = QFrame()
        line2.setFrameShape(QFrame.HLine)
        line2.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line2)
        
        # スタートアップ セクション
        startup_section = QWidget()
        startup_layout = QVBoxLayout(startup_section)
        startup_layout.setSpacing(8)
        
        startup_label = QLabel("スタートアップ")
        startup_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        startup_layout.addWidget(startup_label)
        
        # トグル 行
        toggle_row = QHBoxLayout()
        toggle_row.setSpacing(10)
        
        startup_toggle = ToggleSwitch(checked=self.is_startup_enabled())
        toggle_row.addWidget(startup_toggle)
        
        toggle_text = QLabel("PC起動時にプログラムを自動起動")
        toggle_text.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
        toggle_row.addWidget(toggle_text)
        toggle_row.addStretch()
        
        startup_layout.addLayout(toggle_row)
        
        # 説明
        startup_info = QLabel("このボタンを有効にすると、PCを再起動してもプログラムが自動で起動します。")
        startup_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        startup_layout.addWidget(startup_info)
        
        layout.addWidget(startup_section)

        # トグル 参照 保存 (applyから 使用)
        dialog.startup_toggle = startup_toggle

        # 区切り線
        line3 = QFrame()
        line3.setFrameShape(QFrame.HLine)
        line3.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line3)

        # 自動バックアップ 設定 セクション
        auto_backup_section = QWidget()
        auto_backup_layout = QVBoxLayout(auto_backup_section)
        auto_backup_layout.setSpacing(8)

        auto_backup_label = QLabel("自動バックアップ")
        auto_backup_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        auto_backup_layout.addWidget(auto_backup_label)

        # 自動バックアップ トグル 行
        backup_toggle_row = QHBoxLayout()
        backup_toggle_row.setSpacing(10)

        auto_backup_toggle = ToggleSwitch(checked=getattr(self, 'auto_backup_enabled', True))
        backup_toggle_row.addWidget(auto_backup_toggle)

        backup_toggle_text = QLabel("1時間ごとに自動バックアップ")
        backup_toggle_text.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
        backup_toggle_row.addWidget(backup_toggle_text)
        backup_toggle_row.addStretch()

        auto_backup_layout.addLayout(backup_toggle_row)

        # バックアップ保管こと 設定
        backup_count_row = QHBoxLayout()
        backup_count_row.setSpacing(10)

        backup_count_label = QLabel("バックアップ保管こと:")
        backup_count_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
        backup_count_row.addWidget(backup_count_label)

        backup_count_combo = QComboBox()
        backup_count_combo.setMinimumHeight(32)
        backup_count_combo.setStyleSheet("""
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 8px;
                padding: 4px 10px;
                font-size: 13px;
                font-weight: 700;
                min-width: 80px;
            }
            QComboBox:hover {
                border-color: #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #D4F4DD;
            }
        """)
        backup_counts = [6, 12, 24, 48]
        current_max = getattr(self, 'max_backups', 12)
        for count in backup_counts:
            backup_count_combo.addItem(f"{count}個", count)
        # 現在 値 選択
        try:
            idx = backup_counts.index(current_max)
            backup_count_combo.setCurrentIndex(idx)
        except ValueError:
            backup_count_combo.setCurrentIndex(1)  # 基本 12個

        backup_count_row.addWidget(backup_count_combo)
        backup_count_row.addStretch()

        auto_backup_layout.addLayout(backup_count_row)

        # 説明
        auto_backup_info = QLabel("自動バックアップは1時間ごとに現在のデータを保存します。\nバックアップ保管ことを超えると古いバックアップが削除されます。")
        auto_backup_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        auto_backup_layout.addWidget(auto_backup_info)

        layout.addWidget(auto_backup_section)

        # トグル/コンボ 参照 保存 (applyから 使用)
        dialog.auto_backup_toggle = auto_backup_toggle
        dialog.backup_count_combo = backup_count_combo

        # 区切り線
        line4 = QFrame()
        line4.setFrameShape(QFrame.HLine)
        line4.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line4)

        # バックアップ 復元 セクション
        backup_section = QWidget()
        backup_layout = QVBoxLayout(backup_section)
        backup_layout.setSpacing(8)

        backup_label = QLabel("バックアップ 復元")
        backup_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        backup_layout.addWidget(backup_label)

        backup_info = QLabel("予期 できなかったらして セリフが 消えた 場合, この部分から バックアップされた データを 確認する ことができます.")
        backup_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        backup_info.setWordWrap(True)
        backup_layout.addWidget(backup_info)

        backup_btn = QPushButton("データ復元")
        backup_btn.setMinimumHeight(36)
        backup_btn.clicked.connect(self.show_backup_restore_dialog)
        backup_btn.setStyleSheet("""
            QPushButton {
                background-color: #A8D5A2;
                color: #2E5A2E;
                font-weight: 700;
                border-radius: 10px;
                padding: 8px 20px;
            }
            QPushButton:hover {
                background-color: #8FC789;
            }
        """)
        backup_layout.addWidget(backup_btn)

        layout.addWidget(backup_section)

        layout.addStretch()
        
        # ボタン
        btn_layout = QHBoxLayout()
        
        cancel_btn = QPushButton("キャンセル")
        cancel_btn.setMinimumHeight(40)
        cancel_btn.clicked.connect(dialog.reject)
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                font-weight: 700;
                border-radius: 12px;
                padding: 10px 25px;
            }
            QPushButton:hover {
                background-color: #D0D0D0;
            }
        """)
        
        apply_btn = QPushButton("適用")
        apply_btn.setMinimumHeight(40)
        apply_btn.clicked.connect(lambda: self.apply_monitor_setting(dialog))
        apply_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                font-weight: 700;
                border-radius: 12px;
                padding: 10px 25px;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
        """)
        
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(apply_btn)
        layout.addLayout(btn_layout)
        
        dialog.exec_()
    
    def apply_monitor_setting(self, dialog):
        """環境設定 適用"""
        # モニター 設定 適用
        selected_idx = self.monitor_combo.currentData()
        if selected_idx is None:
            selected_idx = 0  # デフォルト: 1番目 モニター
        self._selected_monitor = selected_idx
        
        # スタートアップ 設定 適用
        if hasattr(dialog, 'startup_toggle'):
            startup_enabled = dialog.startup_toggle.isChecked()
            self.set_startup_enabled(startup_enabled)

        # 自動バックアップ 設定 適用
        if hasattr(dialog, 'auto_backup_toggle'):
            self.auto_backup_enabled = dialog.auto_backup_toggle.isChecked()
            # タイマー 制御
            if self.auto_backup_enabled:
                if not self.auto_backup_timer.isActive():
                    self.auto_backup_timer.start(60 * 60 * 1000)  # 1時間
            else:
                self.auto_backup_timer.stop()

        if hasattr(dialog, 'backup_count_combo'):
            self.max_backups = dialog.backup_count_combo.currentData()

        from PyQt5.QtWidgets import QApplication
        screens = QApplication.screens()
        
        if selected_idx == -1:
            # すべての モニター選択 - 全体 以上 画面 使用
            print(f"[モニター 設定] すべての モニター選択 (自由 移動)")
            
            # 全体 画面 領域 計算
            min_x = min(s.geometry().x() for s in screens)
            min_y = min(s.geometry().y() for s in screens)
            max_x = max(s.geometry().x() + s.geometry().width() for s in screens)
            max_y = max(s.geometry().y() + s.geometry().height() for s in screens)
            
            total_width = max_x - min_x
            total_height = max_y - min_y
            
            for char in self.characters:
                char.screen_x = min_x
                char.screen_y = min_y
                char.screen_width = total_width
                char.screen_height = total_height
                char.use_all_monitors = True  # 全体 モニター モード フラグ
                
                # 各 キャラクターが ある モニターの ground_level 使用
                char_center_x = char.x() + char.width() // 2
                for screen in screens:
                    geo = screen.availableGeometry()
                    if geo.x() <= char_center_x <= geo.x() + geo.width():
                        foot_offset = getattr(char, 'foot_offset', 0)
                        max_foot_offset = char.pixmap.height() // 2
                        foot_offset = min(foot_offset, max_foot_offset)
                        char.ground_level = geo.y() + geo.height() - char.height()
                        break
                
                char.on_ground = True
                char.velocity_y = 0
                
                # 有効化された キャラクターのみ 表示
                is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
                if is_active:
                    char.raise_()
                    char.activateWindow()
                    char.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
                    char.show()
        
        elif selected_idx < len(screens):
            screen = screens[selected_idx]
            geo = screen.availableGeometry()
            
            print(f"[モニター 設定] モニター {selected_idx} 選択: {geo.x()}, {geo.y()}, {geo.width()}x{geo.height()}")
            
            for char in self.characters:
                # キャラクターの 画面 情報 全体 アップデート
                char.screen_geometry = geo
                char.screen_width = geo.width()
                char.screen_height = geo.height()
                char.screen_x = geo.x()  # モニター 開始 X 座標
                char.screen_y = geo.y()  # モニター 開始 Y 座標
                char.use_all_monitors = False  # 単独 モニター モード
                
                # foot_offset 制限 および ground_level 再計算
                foot_offset = getattr(char, 'foot_offset', 0)
                max_foot_offset = char.pixmap.height() // 2
                foot_offset = min(foot_offset, max_foot_offset)
                char.ground_level = geo.y() + geo.height() - char.height()
                
                # ground_levelが 画面 中に あるように 保証
                max_y = geo.y() + geo.height() - char.height()
                char.ground_level = min(char.ground_level, max_y)
                
                # 現在 位置が 選択した モニター 外なら 移動
                char_pos = char.pos()
                char_in_monitor = (geo.x() <= char_pos.x() <= geo.x() + geo.width() - char.width() and
                                   geo.y() <= char_pos.y() <= geo.y() + geo.height() - char.height())
                
                if not char_in_monitor:
                    # モニター 中央 付近 ランダム 位置で 移動
                    import random
                    new_x = geo.x() + random.randint(100, max(150, geo.width() - 200))
                    new_y = char.ground_level
                    char.move(new_x, new_y)
                    print(f"[モニター 設定] キャラクター {char.char_id} 移動: ({new_x}, {new_y})")
                
                # 床に 着地
                char.on_ground = True
                char.velocity_y = 0
                
                # 有効化された キャラクターのみ 表示
                is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
                if is_active:
                    # キャラクターを 最上位位置に再度上げ
                    char.raise_()
                    char.activateWindow()
                    char.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
                    char.show()
        
        dialog.accept()
    
    def is_startup_enabled(self):
        """スタートアップ 登録 可否 確認"""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0,
                winreg.KEY_READ
            )
            try:
                winreg.QueryValueEx(key, "Kiwipet")
                winreg.CloseKey(key)
                return True
            except FileNotFoundError:
                winreg.CloseKey(key)
                return False
            except Exception:
                winreg.CloseKey(key)
                return False
        except ImportError:
            # Windowsが でない 環境
            print("[スタートアップ] Windowsが ではない環パスす.")
            return False
        except Exception as e:
            print(f"[スタートアップ] 確認 エラー: {e}")
            return False
    
    def set_startup_enabled(self, enabled):
        """スタートアップ 登録/解除"""
        try:
            import winreg
            import sys
            
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0,
                winreg.KEY_SET_VALUE | winreg.KEY_READ
            )
            
            if enabled:
                # 現在 実行 中である exe パス
                if getattr(sys, 'frozen', False):
                    # PyInstallerで ビルドされた exe
                    exe_path = sys.executable
                else:
                    # 個足 モード (python スクリプト)
                    exe_path = f'"{sys.executable}" "{os.path.abspath(__file__)}"'
                
                winreg.SetValueEx(key, "Kiwipet", 0, winreg.REG_SZ, exe_path)
                print(f"[スタートアップ] 登録 完了: {exe_path}")
            else:
                try:
                    winreg.DeleteValue(key, "Kiwipet")
                    print("[スタートアップ] 解除 完了")
                except FileNotFoundError:
                    pass  # 既に なし
            
            winreg.CloseKey(key)
        except Exception as e:
            print(f"[スタートアップ] 設定 エラー: {e}")
            QMessageBox.warning(self, "エラー", f"スタートアップ 設定 中 エラーが 発生しました.\n{str(e)}")
    
    def _export_all_characters(self):
        """すべての キャラクター 全体 バックアップ (フォルダ + 画像 + JSON 方式)"""
        import shutil
        import re
        import datetime
        
        if not self.character_data:
            QMessageBox.information(self, "バックアップ", "バックアップする キャラクターが ありません.")
            return
        
        # 保存 位置 選択
        folder = QFileDialog.getExistingDirectory(self, "バックアップ 保存 位置 選択")
        if not folder:
            return
        
        try:
            # 日付_バックアップ フォルダ 生成
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_folder = os.path.join(folder, f"{timestamp}_バックアップ")
            os.makedirs(backup_folder, exist_ok=True)
            
            # 各 キャラクター データ 保存
            for char_id, char_data in self.character_data.items():
                char_name = char_data.get('name', f'キャラクター_{char_id}')

                # ファイル体用 安全な 名前 (char_id 含むとして 重複 防止)
                safe_name = re.sub(r'[<>:"/\\|?*]', '', char_name).strip()
                if not safe_name:
                    safe_name = f'キャラクター_{char_id}'
                unique_name = f"{char_id}_{safe_name}"

                # 画像 コピー
                image_file = f"{unique_name}_image.png"
                image_path = char_data.get('image_path', '')
                if image_path and os.path.exists(image_path):
                    ext = os.path.splitext(image_path)[1] or '.png'
                    image_file = f"{unique_name}_image{ext}"
                    shutil.copy2(image_path, os.path.join(backup_folder, image_file))
                
                # AI キャッシュ 取得
                ai_cache = {}
                if char_id in _ai_dialogues_cache:
                    cache = _ai_dialogues_cache[char_id]
                    ai_cache = {
                        'solo': cache.get('solo', []),
                        'interaction': cache.get('interaction', {}),
                        'fallback': cache.get('fallback', []),
                        'reference': cache.get('reference', {})  # 参考用手動セリフ
                    }
                
                char_backup = {
                    'char_id': char_id,
                    'char_name': char_name,
                    'image_file': image_file,
                    'scale': char_data.get('scale', 100),
                    'bubble_color': char_data.get('bubble_color', '#A8D5BA'),
                    'bubble_size': char_data.get('bubble_size', 100),
                    'facing_direction': char_data.get('facing_direction', 'right'),
                    'is_active': char_data.get('is_active', True),
                    'personality': char_data.get('personality', ''),
                    'background_story': char_data.get('background_story', ''),
                    'nicknames': char_data.get('nicknames', {}),
                    'stories': char_data.get('stories', {}),
                    'sample_dialogues': char_data.get('sample_dialogues', []),
                    'catchphrase': char_data.get('catchphrase', ''),
                    'ai_cache': ai_cache,
                    'dialogues': self.dialogues.get(char_id, {'基本': []})
                }
                
                # キャラクター別 JSON 保存 (char_id 含む ファイル体)
                json_path = os.path.join(backup_folder, f"{unique_name}.json")
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(char_backup, f, ensure_ascii=False, indent=2)
            
            # 関係 情報 および 設定 保存 (_backup_info.json)
            # キャラクター 順序 保存 (char_id 順序通りに)
            character_order = []
            for char_id, char_data in self.character_data.items():
                char_name = char_data.get('name', f'キャラクター_{char_id}')
                safe_name = re.sub(r'[<>:"/\\|?*]', '', char_name).strip()
                if not safe_name:
                    safe_name = f'キャラクター_{char_id}'
                unique_name = f"{char_id}_{safe_name}"
                character_order.append({
                    'char_id': char_id,
                    'char_name': char_name,
                    'json_file': f"{unique_name}.json"
                })
            
            backup_info = {
                'version': '3.0',
                'backup_type': 'all_characters',
                'character_order': character_order,  # 順序 情報 追加
                'relationships': {},
                'ai_enabled': self.ai_enabled,
                'gemini_api_key': self.gemini_api_key,
            }
            
            for key, value in self.relationships.items():
                if isinstance(key, tuple) and len(key) == 2:
                    # 現在 存在する キャラクターたちの 関係のみ バックアップ
                    if key[0] in self.character_data and key[1] in self.character_data:
                        key_str = f"{key[0]},{key[1]}"
                        backup_info['relationships'][key_str] = value
            
            info_path = os.path.join(backup_folder, "_backup_info.json")
            with open(info_path, 'w', encoding='utf-8') as f:
                json.dump(backup_info, f, ensure_ascii=False, indent=2)
            
            # 関係 こと 計算
            rel_count = len(backup_info['relationships'])
            
            QMessageBox.information(self, "バックアップ完了", 
                f"バックアップが 完了しました!\n\n"
                f"📁 保存 位置:\n{backup_folder}")
            
        except Exception as e:
            import traceback
            print(f"[全体 バックアップ エラー] {e}")
            print(traceback.format_exc())
            QMessageBox.critical(self, "バックアップ 失敗", f"バックアップ中にエラーが発生しました。\n\n{str(e)}")
    
    def _import_all_characters(self):
        """すべての キャラクター 全体 読み込む (フォルダ選択 → 自動 探す)"""
        import shutil
        
        # 案内 ポップアップ
        QMessageBox.information(self, "全体 キャラクター 読み込む", "バックアップ フォルダを 選択してください.")
        
        # フォルダ選択
        folder_path = QFileDialog.getExistingDirectory(
            self,
            "全体 バックアップ フォルダ選択"
        )
        
        if not folder_path:
            return
        
        try:
            # _backup_info.json 確認 (全体 バックアップ フォルダかどうか 確認)
            info_path = os.path.join(folder_path, "_backup_info.json")
            backup_info = {}
            
            if os.path.exists(info_path):
                with open(info_path, 'r', encoding='utf-8') as f:
                    backup_info = json.load(f)
            
            # フォルダ内 すべての キャラクター JSONファイル 探す (_backup_info.json 除外)
            json_files = [f for f in os.listdir(folder_path) 
                         if f.endswith('.json') and not f.startswith('_')]
            
            if not json_files:
                QMessageBox.warning(self, "読み込む 失敗", "選択した フォルダに キャラクター データが ありません.")
                return
            
            # 順序 情報が いれば 該当 順序通りに ソート
            character_order = backup_info.get('character_order', [])
            if character_order:
                # character_orderにある順序通りに ソート
                order_map = {item['json_file']: idx for idx, item in enumerate(character_order)}
                json_files.sort(key=lambda f: order_map.get(f, 999))
                print(f"[読み込む] 順序 情報 使用: {[item['char_name'] for item in character_order]}")
            
            # 確認 ポップアップ
            current_count = len(self.character_data)
            reply = QMessageBox.question(
                self,
                "全体 キャラクター 読み込む",
                f"{len(json_files)}個 キャラクターを 追加します.\n\n現在 {current_count}個 キャラクターは 維持されます.\n\n続けますか?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # temp_imagesフォルダ 準備
            temp_dir = os.path.join(self.app_dir, 'temp_images')
            os.makedirs(temp_dir, exist_ok=True)
            
            # バックアップ ファイルの old_id -> new_id マッピング
            id_mapping = {}
            
            # 各 キャラクター 追加
            loaded_count = 0
            global _ai_dialogues_cache  # グローバル AI キャッシュ 使用
            
            for json_file in json_files:
                try:
                    json_path = os.path.join(folder_path, json_file)
                    with open(json_path, 'r', encoding='utf-8') as f:
                        char_backup = json.load(f)
                    
                    old_char_id = char_backup.get('char_id', loaded_count)
                    char_name = char_backup.get('char_name', 'キャラクター')
                    
                    # 新しい char_id 割り当て
                    new_char_id = self.char_id_counter
                    self.char_id_counter += 1
                    
                    # ID マッピング 保存
                    id_mapping[old_char_id] = new_char_id
                    
                    # 画像 ファイル 探す
                    image_file = char_backup.get('image_file', '')
                    image_path = ""
                    
                    if image_file:
                        possible_path = os.path.join(folder_path, image_file)
                        if os.path.exists(possible_path):
                            image_path = possible_path
                    
                    # 画像 できなかったら 見つけたら ファイル体 ベースとして 検索
                    if not image_path:
                        base_name = os.path.splitext(json_file)[0]
                        for ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.PNG', '.JPG']:
                            test_path = os.path.join(folder_path, f"{base_name}_image{ext}")
                            if os.path.exists(test_path):
                                image_path = test_path
                                break
                    
                    # それでもなければ placeholder 使用
                    if not image_path or not os.path.exists(image_path):
                        from PyQt5.QtSvg import QSvgRenderer
                        from PyQt5.QtGui import QImage, QPainter
                        from PyQt5.QtCore import Qt
                        import uuid
                        
                        unique_filename = f"placeholder_{uuid.uuid4().hex[:8]}.png"
                        image_path = os.path.join(temp_dir, unique_filename)
                        
                        renderer = QSvgRenderer(PLACEHOLDER_SVG.encode('utf-8'))
                        if renderer.isValid():
                            img = QImage(200, 200, QImage.Format_ARGB32)
                            img.fill(Qt.transparent)
                            painter = QPainter(img)
                            renderer.render(painter)
                            painter.end()
                            img.save(image_path, 'PNG')
                    else:
                        # 画像を temp_imagesに コピー
                        import uuid
                        ext = os.path.splitext(image_path)[1]
                        unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                        copied_path = os.path.join(temp_dir, unique_filename)
                        shutil.copy2(image_path, copied_path)
                        image_path = copied_path
                    
                    # キャラクター 設定
                    direction = char_backup.get('facing_direction', 'right')
                    scale = char_backup.get('scale', 100)
                    bubble_color = char_backup.get('bubble_color', '#A8D5BA')
                    bubble_size = char_backup.get('bubble_size', 100)
                    is_active = char_backup.get('is_active', True)
                    catchphrase = char_backup.get('catchphrase', '')
                    
                    # キャラクター ウィジェット 生成
                    char_widget = CharacterWidget(image_path, new_char_id, direction, scale, bubble_color, bubble_size)
                    if not is_active:
                        char_widget.hide()
                    self.characters.append(char_widget)
                    
                    # キャラクター データ 保存 (nicknames/storiesは 後で マッピング)
                    self.character_data[new_char_id] = {
                        'name': char_name,
                        'scale': scale,
                        'bubble_color': bubble_color,
                        'bubble_size': bubble_size,
                        'facing_direction': direction,
                        'image_path': image_path,
                        'is_active': is_active,
                        'catchphrase': catchphrase,
                        'personality': char_backup.get('personality', ''),
                        'background_story': char_backup.get('background_story', ''),
                        'nicknames': {},  # 後で 名前->ID マッピング 後 設定
                        'stories': {},  # 後で 名前->ID マッピング 後 設定
                        'sample_dialogues': char_backup.get('sample_dialogues', [])
                    }
                    
                    # セリフ データ (キー 形式 統一) - 後で id_mappingとして 変換
                    dialogues_data = char_backup.get('dialogues', {'基本': []})
                    if isinstance(dialogues_data, dict):
                        # 一旦 キー 形式のみ 統一 (old_id そのまま維持, 後で変換)
                        converted = {}
                        for key, values in dialogues_data.items():
                            if key == '基本':
                                converted['基本'] = values
                            elif isinstance(key, int):
                                # 一旦 old_id そのまま 保存 (後で変換)
                                converted[f'char_{key}'] = values
                            elif isinstance(key, str) and key.isdigit():
                                converted[f'char_{key}'] = values
                            else:
                                converted[key] = values
                        self.dialogues[new_char_id] = converted
                        # pendingとして old_id ベース キー 保存 (後で変換用)
                        char_widget._pending_dialogues_keys = True
                    else:
                        self.dialogues[new_char_id] = {'基本': dialogues_data}
                    
                    # キャラクター ウィジェットに データ 伝達
                    char_widget.dialogues = self.dialogues.get(new_char_id, {'基本': []})
                    char_widget.personality = char_backup.get('personality', '')
                    char_widget.background_story = char_backup.get('background_story', '')
                    char_widget.char_name = char_name
                    char_widget.catchphrase = catchphrase
                    
                    # nicknamesと storiesは 後で すべての キャラクター 読み込み 後 マッピング
                    # 一旦 名前 ベースとして 保存しておく
                    char_widget._pending_nicknames = char_backup.get('nicknames', {})
                    char_widget._pending_stories = char_backup.get('stories', {})
                    char_widget.nicknames = {}
                    char_widget.stories = {}
                    char_widget.sample_dialogues = char_backup.get('sample_dialogues', [])
                    
                    # AI キャッシュ 復元 (新しい IDで, interaction キーを intで 変換)
                    if char_backup.get('ai_cache'):
                        raw_interaction = char_backup['ai_cache'].get('interaction', {})
                        converted_interaction = {}
                        for k, v in raw_interaction.items():
                            try:
                                converted_interaction[int(k)] = v
                            except (ValueError, TypeError):
                                converted_interaction[k] = v

                        _ai_dialogues_cache[new_char_id] = {
                            'solo': char_backup['ai_cache'].get('solo', []),
                            'interaction': converted_interaction,
                            'fallback': char_backup['ai_cache'].get('fallback', []),
                            'reference': char_backup['ai_cache'].get('reference', {}),  # 参考用手動セリフ
                            'generated_at': time.time()
                        }
                    
                    # 手動 セリフを AI キャッシュに 同期
                    sync_dialogues_to_ai_cache(new_char_id, self.dialogues[new_char_id])
                    
                    # カード 生成
                    card = CharacterCard(new_char_id, image_path, char_name, is_active=is_active, catchphrase=catchphrase)
                    card.remove_clicked.connect(self.remove_character)
                    card.change_image_clicked.connect(self.change_character_image)
                    card.change_scale_clicked.connect(self.change_character_scale)
                    card.change_bubble_color_clicked.connect(self.change_bubble_color)
                    card.change_relationships_clicked.connect(self.change_relationships)
                    card.change_dialogues_clicked.connect(self.change_dialogues)
                    card.change_personality_clicked.connect(self.change_personality)
                    card.name_changed.connect(self.update_character_name)
                    card.catchphrase_changed.connect(self.update_character_catchphrase)
                    card.toggle_active.connect(self.toggle_character_active)
                    card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                    card.update_scale_display(scale)
                    
                    self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                    
                    loaded_count += 1
                    
                except Exception as e:
                    print(f"[読み込む] キャラクター 復元失敗: {e}")
                    continue
            
            # 関係 情報 復元 (新しい IDで マッピング, レガシー 形式 マイグレーション 含む)
            relationships_data = backup_info.get('relationships', {})
            for key_str, value in relationships_data.items():
                try:
                    if ',' not in str(key_str):
                        continue
                    old_ids = list(map(int, str(key_str).split(',')))
                    # 新しい IDで マッピング
                    if old_ids[0] not in id_mapping or old_ids[1] not in id_mapping:
                        continue
                    new_ids = tuple(sorted([id_mapping[old_ids[0]], id_mapping[old_ids[1]]]))

                    # value 正規化: {char_id: "感情", other_id: "感情"} 形式として 統一
                    if isinstance(value, dict):
                        new_value = {}
                        for k, v in value.items():
                            try:
                                old_k = int(k)
                            except (ValueError, TypeError):
                                continue
                            if old_k not in id_mapping:
                                continue
                            new_k = id_mapping[old_k]
                            # 値が 文字列なら そのまま, ネストdictなら my_feeling 抽出
                            if isinstance(v, str):
                                new_value[new_k] = v
                            elif isinstance(v, dict) and 'my_feeling' in v:
                                new_value[new_k] = v.get('my_feeling', '無関心')
                            else:
                                new_value[new_k] = "無関心"
                        if new_value:
                            self.relationships[new_ids] = new_value
                    elif isinstance(value, str):
                        # レガシー シンプル 文字列 形式 -> 現在 形式として 変換
                        self.relationships[new_ids] = {
                            new_ids[0]: value,
                            new_ids[1]: "無関心"
                        }
                    print(f"[読み込む] 関係 復元: {new_ids} -> {self.relationships.get(new_ids, {})}")
                except Exception as e:
                    print(f"[読み込む] 関係 復元失敗: {e}")
                    continue
            
            # 呼び方/ストーリー マッピング (名前 -> ID)
            # 現在 アプリの すべての キャラクター 名前->ID マッピング 生成
            name_to_id = {}
            for cid, cdata in self.character_data.items():
                cname = cdata.get('name', '')
                if cname:
                    name_to_id[cname] = cid
            
            # 各 キャラクターの pending nicknames/storiesを IDで 変換
            for char in self.characters:
                if hasattr(char, '_pending_nicknames') and char._pending_nicknames:
                    new_nicknames = {}
                    for other_name, nickname in char._pending_nicknames.items():
                        # 名前が 数字(ID)である 場合 (旧バージョン バックアップ)
                        try:
                            old_id = int(other_name)
                            if old_id in id_mapping:
                                new_nicknames[id_mapping[old_id]] = nickname
                            continue
                        except ValueError:
                            pass
                        # 名前として ID 探す
                        if other_name in name_to_id:
                            new_nicknames[name_to_id[other_name]] = nickname
                    char.nicknames = new_nicknames
                    self.character_data[char.char_id]['nicknames'] = new_nicknames
                    delattr(char, '_pending_nicknames')
                
                if hasattr(char, '_pending_stories') and char._pending_stories:
                    new_stories = {}
                    for other_name, story in char._pending_stories.items():
                        # 名前が 数字(ID)である 場合 (旧バージョン バックアップ)
                        try:
                            old_id = int(other_name)
                            if old_id in id_mapping:
                                new_stories[id_mapping[old_id]] = story
                            continue
                        except ValueError:
                            pass
                        # 名前として ID 探す
                        if other_name in name_to_id:
                            new_stories[name_to_id[other_name]] = story
                    char.stories = new_stories
                    self.character_data[char.char_id]['stories'] = new_stories
                    delattr(char, '_pending_stories')
            
            # AI キャッシュの interaction キーを old_id → new_idで 変換
            for char_id in list(_ai_dialogues_cache.keys()):
                if char_id in _ai_dialogues_cache:
                    cache = _ai_dialogues_cache[char_id]
                    if 'interaction' in cache and isinstance(cache['interaction'], dict):
                        new_interaction = {}
                        for old_key, dialogues in cache['interaction'].items():
                            if old_key == 'default':
                                new_interaction['default'] = dialogues
                            elif isinstance(old_key, int) and old_key in id_mapping:
                                new_interaction[id_mapping[old_key]] = dialogues
                            elif isinstance(old_key, str):
                                try:
                                    old_key_int = int(old_key)
                                    if old_key_int in id_mapping:
                                        new_interaction[id_mapping[old_key_int]] = dialogues
                                    else:
                                        new_interaction[old_key_int] = dialogues
                                except ValueError:
                                    new_interaction[old_key] = dialogues
                            else:
                                new_interaction[old_key] = dialogues
                        cache['interaction'] = new_interaction
                        print(f"[読み込む] AI キャッシュ interaction キー 変換: char_id={char_id}, keys={list(new_interaction.keys())}")
            
            # セリフ(dialogues)の 'char_X' キーを old_id → new_idで 変換
            for char in self.characters:
                if hasattr(char, '_pending_dialogues_keys') and char._pending_dialogues_keys:
                    char_id = char.char_id
                    if char_id in self.dialogues:
                        old_dialogues = self.dialogues[char_id]
                        new_dialogues = {}
                        for key, values in old_dialogues.items():
                            if key == '基本':
                                new_dialogues['基本'] = values
                            elif key.startswith('char_'):
                                try:
                                    old_id = int(key.replace('char_', ''))
                                    if old_id in id_mapping:
                                        new_dialogues[f'char_{id_mapping[old_id]}'] = values
                                    else:
                                        new_dialogues[key] = values
                                except ValueError:
                                    new_dialogues[key] = values
                            else:
                                new_dialogues[key] = values
                        self.dialogues[char_id] = new_dialogues
                        char.dialogues = new_dialogues
                        print(f"[読み込む] セリフ キー 変換: char_id={char_id}, keys={list(new_dialogues.keys())}")
                    delattr(char, '_pending_dialogues_keys')
            
            # API設定 復元
            if backup_info.get('gemini_api_key'):
                self.gemini_api_key = backup_info['gemini_api_key']
            if 'ai_enabled' in backup_info:
                self.ai_enabled = backup_info['ai_enabled']

            # キャラクター ウィジェットに 感情 情報 伝達
            self.update_character_relationships()

            self.save_characters()
            
            # 関係 こと 計算
            rel_count = len(relationships_data)
            
            QMessageBox.information(self, "読み込み完了", 
                f"{loaded_count}体のキャラクターを読み込みました。")
            
        except Exception as e:
            import traceback
            print(f"[全体 読み込む エラー] {e}")
            print(traceback.format_exc())
            QMessageBox.critical(self, "読み込む 失敗", f"読み込み中にエラーが発生しました。\n\n{str(e)}")

    def _apply_monitor_to_characters(self, monitor_idx):
        """保存された モニター 設定を すべての キャラクターに 適用 (読み込み 時 使用)"""
        from PyQt5.QtWidgets import QApplication
        screens = QApplication.screens()
        
        if monitor_idx == -1:
            # すべての モニター選択 - 全体 以上 画面 使用
            print(f"[モニター 読み込み] すべてのモニター (自由 移動)")
            
            min_x = min(s.geometry().x() for s in screens)
            min_y = min(s.geometry().y() for s in screens)
            max_x = max(s.geometry().x() + s.geometry().width() for s in screens)
            max_y = max(s.geometry().y() + s.geometry().height() for s in screens)
            
            total_width = max_x - min_x
            total_height = max_y - min_y
            
            for char in self.characters:
                char.screen_x = min_x
                char.screen_y = min_y
                char.screen_width = total_width
                char.screen_height = total_height
                char.use_all_monitors = True  # 全体 モニター モード フラグ
                
                # 現在 キャラクター 位置 基準として 該当 モニターの ground_level 使用
                char_center_x = char.x() + char.width() // 2
                target_geo = screens[0].availableGeometry()  # デフォルト
                for screen in screens:
                    geo = screen.availableGeometry()
                    if geo.x() <= char_center_x <= geo.x() + geo.width():
                        target_geo = geo
                        break
                
                foot_offset = getattr(char, 'foot_offset', 0)
                max_foot_offset = char.pixmap.height() // 2
                foot_offset = min(foot_offset, max_foot_offset)
                char.ground_level = target_geo.y() + target_geo.height() - char.height()
                
                # 有効化された キャラクターのみ 移動
                is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
                if is_active:
                    import random
                    new_x = target_geo.x() + random.randint(50, max(100, target_geo.width() - 150))
                    new_y = char.ground_level
                    char.move(new_x, new_y)
                    char.on_ground = True
                    char.velocity_y = 0
                    char.on_window = False
            return
        
        # 保存された モニターが より 以上 なければ 基本 モニター(0) 使用
        if monitor_idx >= len(screens):
            monitor_idx = 0
            self._selected_monitor = 0
            print(f"[モニター 読み込み] 保存された モニター なし, 基本 モニター 使用")
        
        screen = screens[monitor_idx]
        geo = screen.availableGeometry()
        
        print(f"[モニター 読み込み] モニター {monitor_idx} 適用: {geo.x()}, {geo.y()}, {geo.width()}x{geo.height()}")
        
        for char in self.characters:
            # キャラクターの 画面 情報 全体 アップデート
            char.screen_geometry = geo
            char.screen_width = geo.width()
            char.screen_height = geo.height()
            char.screen_x = geo.x()
            char.screen_y = geo.y()
            char.use_all_monitors = False  # 単独 モニター モード
            
            # foot_offset 制限 (キャラクター 高くの 半分 以下で)
            foot_offset = getattr(char, 'foot_offset', 0)
            max_foot_offset = char.pixmap.height() // 2  # 最大 1/3までのみ
            foot_offset = min(foot_offset, max_foot_offset)
            
            # ground_level 再計算
            char.ground_level = geo.y() + geo.height() - char.height()
            
            # ground_levelが 画面 中に あるように 保証
            min_y = geo.y()
            max_y = geo.y() + geo.height() - char.height()
            char.ground_level = max(min_y, min(char.ground_level, max_y))
            
            # 有効化された キャラクターのみ 移動 (無効化された キャラクターは 非表示に あり)
            is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
            if is_active:
                # キャラクターを モニター 内の ランダム 位置で 移動
                import random
                new_x = geo.x() + random.randint(50, max(100, geo.width() - 150))
                new_y = char.ground_level
                char.move(new_x, new_y)
                
                # 床に 着地
                char.on_ground = True
                char.velocity_y = 0
                char.on_window = False
                
                print(f"[モニター 読み込み] キャラクター {char.char_id} 配置: ({new_x}, {new_y}), ground_level={char.ground_level}") 
    
    def show_api_settings(self):
        """API キー 設定 ダイアログ"""
        dialog = QDialog(self)
        dialog.setWindowTitle("AI API 設定")
        dialog.setMinimumSize(480, 520)
        dialog.setMaximumWidth(600)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLineEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 14px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 14px;
            }
            QLineEdit:focus {
                border: 2px solid #8ECFB5;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 12px;
                font-weight: 700;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 13px;
                min-height: 36px;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(35, 35, 35, 35)
        
        # タイトル
        title = QLabel("🔑 Gemini APIキー設定")
        title.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 24px; font-weight: 700; font-family: 'Pretendard JP', 'Meiryo', sans-serif;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        layout.addSpacing(10)
        
        # 説明
        info = QLabel("キャラクターに性格を設定するとAIが自動でセリフを生成します。\n"
                     "Google AI Studioで無料APIキーを発行できます。")
        info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #666; padding: 5px 0;")
        info.setWordWrap(True)
        info.setMinimumHeight(50)
        layout.addWidget(info)

        # リンク
        link_label = QLabel('<a href="https://aistudio.google.com/apikey">Google AI StudioでAPIキーを発行する</a>')
        link_label.setOpenExternalLinks(True)
        link_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700;")
        layout.addWidget(link_label)

        # 待機/制限超過案内（オレンジ色）
        wait_info = QLabel("APIキーを新規発行した場合は10分ほどお待ちください。\n"
                          "新規キーでなく、リクエスト制限を超過した場合は1～2時間（最大1日）お待ちください。")
        wait_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #e67e22; line-height: 1.4;")
        layout.addWidget(wait_info)

        layout.addSpacing(15)

        # API キー 入力
        key_label = QLabel("APIキー:")
        key_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        layout.addWidget(key_label)
        
        key_input = QLineEdit()
        key_input.setPlaceholderText("AIza...（Google AI Studioで発行）")
        key_input.setText(self.gemini_api_key)
        key_input.setEchoMode(QLineEdit.Password)
        key_input.setMinimumHeight(45)
        layout.addWidget(key_input)
        
        # キー 見る チェックボックス
        show_key = QCheckBox("キーを表示")
        show_key.toggled.connect(lambda checked: key_input.setEchoMode(
            QLineEdit.Normal if checked else QLineEdit.Password))
        show_key.setStyleSheet("color: #666; font-size: 13px; font-weight: 700;")
        layout.addWidget(show_key)

        layout.addSpacing(10)

        # 区切り線
        separator_key = QFrame()
        separator_key.setFrameShape(QFrame.HLine)
        separator_key.setStyleSheet("background-color: #C5E8D8;")
        separator_key.setFixedHeight(1)
        layout.addWidget(separator_key)

        layout.addSpacing(10)

        # AI 有効化 トグル
        ai_toggle_layout = QHBoxLayout()
        ai_toggle_label = QLabel("セリフ生成:")
        ai_toggle_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        ai_toggle_layout.addWidget(ai_toggle_label)
        
        ai_toggle = ToggleSwitch(self.ai_enabled)
        ai_toggle_layout.addWidget(ai_toggle)
        ai_toggle_layout.addStretch()
        layout.addLayout(ai_toggle_layout)
        
        # AI 説明
        ai_info = QLabel("有効にすると1時間ごとにキャラクター別セリフを事前生成します。\n"
                        "（性格が設定されているキャラクターのみ適用）")
        ai_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        ai_info.setWordWrap(True)
        layout.addWidget(ai_info)
        
        # キャラクター選択 ボタン
        char_select_btn = QPushButton("キャラクター選択")
        char_select_btn.setStyleSheet("""
            QPushButton {
                background-color: #D4E8DC;
                color: #5A9C85;
                border: 1px solid #9DD4BA;
                padding: 8px 16px;
                border-radius: 10px;
                font-size: 13px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #C5E0CE;
            }
        """)
        char_select_btn.clicked.connect(lambda: self.show_ai_character_select_dialog())
        layout.addWidget(char_select_btn)
        
        # キャラクター選択 説明
        char_select_info = QLabel("AIセリフを自動生成するキャラクターを選択します。\nセリフが少ないキャラクターが優先生成されます。")
        char_select_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        char_select_info.setWordWrap(True)
        layout.addWidget(char_select_info)
        
        layout.addSpacing(5)
        
        # 今すぐセリフ生成 ボタン
        generate_now_btn = QPushButton("今すぐセリフ生成")
        generate_now_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
            QPushButton:disabled {
                background-color: #ccc;
                color: #888;
            }
        """)
        generate_now_btn.clicked.connect(lambda: self.generate_dialogues_now(generate_now_btn))
        layout.addWidget(generate_now_btn)
        
        # 既に 生成中なら ボタン 状態 同期
        if getattr(self, '_is_generating_now', False):
            generate_now_btn.setEnabled(False)
            idx = getattr(self, '_generate_now_index', 0) + 1
            total = len(getattr(self, '_generate_now_queue', []))
            generate_now_btn.setText(f"生成中... {idx}/{total}")
            # ボタン 参照 アップデート
            self._generate_now_btn = generate_now_btn
        
        # 今すぐセリフ生成 説明
        generate_now_info = QLabel("ボタンを押すと即座にセリフを生成します。\n（キャラクターが複数いる場合、1分間隔で順次生成）")
        generate_now_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        layout.addWidget(generate_now_info)

        layout.addSpacing(10)

        # 区切り線
        separator = QFrame()
        separator.setFrameShape(QFrame.HLine)
        separator.setStyleSheet("background-color: #C5E8D8;")
        separator.setFixedHeight(1)
        layout.addWidget(separator)

        layout.addSpacing(10)

        # モデル選択
        model_label = QLabel("AIモデル:")
        model_label.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 15px; font-weight: 700;")
        layout.addWidget(model_label)

        from PyQt5.QtWidgets import QComboBox
        model_combo = QComboBox()
        model_combo.setStyleSheet("""
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 10px;
                padding: 8px 12px;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 13px;
                font-weight: 700;
                min-height: 20px;
            }
            QComboBox:hover {
                border: 1px solid #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                width: 30px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 6px solid #5A9C85;
                margin-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #E8F5EE;
                selection-color: #5A9C85;
                font-weight: 700;
            }
        """)

        # モデルリスト追加
        current_model_index = 0
        for i, (model_id, model_name) in enumerate(GEMINI_MODELS):
            model_combo.addItem(model_name, model_id)
            if model_id == self.gemini_model:
                current_model_index = i
        model_combo.setCurrentIndex(current_model_index)
        layout.addWidget(model_combo)

        # モデル選択案内
        model_info = QLabel("制限超過が繰り返される場合は、別のモデルに変更してセリフ生成を試してください。\n"
                           "ただし、全体の使用量を使い切った場合はモデルを変更しても生成できない場合があります。\n"
                           "保存ボタンを押した後に選択したモデルが適用されます。")
        model_info.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        model_info.setWordWrap(True)
        layout.addWidget(model_info)

        layout.addSpacing(10)

        # テスト 結果 ラベル
        test_result = QLabel("")
        test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #666;")
        test_result.setWordWrap(True)
        test_result.setMinimumHeight(25)
        layout.addWidget(test_result)
        
        layout.addStretch()
        
        # ボタン
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(12)
        
        # テスト ボタン
        test_btn = QPushButton("テスト")
        test_btn.setStyleSheet("""
            QPushButton { background-color: #B5DEFF; color: white; }
            QPushButton:hover { background-color: #9ED0FF; }
        """)
        def test_api():
            test_key = key_input.text().strip()
            original_len = len(test_key)
            # clean_api_key 関数で すべての 異常 文字 削除
            test_key = clean_api_key(test_key)
            cleaned_len = len(test_key)
            print(f"[API テスト] 元の 長さ: {original_len}, 整理 後 長さ: {cleaned_len}")
            print(f"[API テスト] キー 開始: {test_key[:15] if len(test_key) >= 15 else test_key}...")
            
            # 長さが 減ったら 特別文字が あった こと
            if original_len != cleaned_len:
                print(f"[API テスト] 特別文字 削除される: {original_len - cleaned_len}字")
            
            if not test_key:
                test_result.setText("❌ APIキーを入力してください。")
                test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
                return
            
            if not test_key.startswith("AIza"):
                test_result.setText("❌ APIキーは'AIza'で始まる必要があります。")
                test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
                return
            
            if len(test_key) != 39:
                test_result.setText(f"❌ APIキー長さエラー ({len(test_key)}字, 39字 必要)")
                test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
                return
            
            test_result.setText("⏳ テスト中...")
            test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #666;")
            QApplication.processEvents()
            
            try:
                import urllib.request
                # URL 直接 構成 (選択されたモデル使用)
                selected_model = model_combo.currentData()
                url = f"https://generativelanguage.googleapis.com/v1beta/models/{selected_model}:generateContent?key={test_key}"
                print(f"[API テスト] URL 生成 完了 (モデル: {selected_model}), 長さ: {len(url)}")
                data = {
                    "contents": [{"parts": [{"text": "Hi"}]}],
                    "generationConfig": {"maxOutputTokens": 10}
                }
                req = urllib.request.Request(
                    url,
                    data=json.dumps(data).encode('utf-8'),
                    headers={'Content-Type': 'application/json'},
                    method='POST'
                )
                with urllib.request.urlopen(req, timeout=15, context=_ssl_context) as response:
                    result = json.loads(response.read().decode('utf-8'))
                    if 'candidates' in result:
                        test_result.setText("✅ APIキーが正常に動作しています！")
                        test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #4CAF50;")
                    else:
                        test_result.setText("❌ レスポンス形式エラー")
                        test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
            except urllib.error.HTTPError as e:
                error_body = ""
                try:
                    error_body = e.read().decode('utf-8')
                except:
                    pass
                print(f"[API テスト] HTTP {e.code}: {error_body[:500]}")
                
                if e.code == 400:
                    if "API_KEY_INVALID" in error_body:
                        test_result.setText("❌ APIキーが無効です。")
                    elif "INVALID_ARGUMENT" in error_body:
                        test_result.setText("❌ APIキーの形式が間違っています。")
                    else:
                        test_result.setText(f"❌ リクエストエラー（400）")
                elif e.code == 403:
                    test_result.setText("❌ APIキーの権限がありません。")
                elif e.code == 429:
                    test_result.setText("⚠️ リクエスト制限超過（しばらく後に再試行）")
                elif e.code == 404:
                    # モデルが なくても キーは 有効な こと あり
                    test_result.setText("✅ APIキー認証成功（モデル確認必要）")
                    test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #FF9800;")
                    return
                else:
                    test_result.setText(f"❌ サーバーエラー: {e.code}")
                test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
            except urllib.error.URLError as e:
                print(f"[API テスト] URLError: {e.reason}")
                test_result.setText(f"❌ ネットワークエラー - インターネット接続を確認してください")
                test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
            except Exception as e:
                error_msg = str(e)
                error_type = type(e).__name__
                print(f"[API テスト] {error_type}: {error_msg}")
                test_result.setText(f"❌ エラー: {error_type}")
                test_result.setStyleSheet("font-family: 'Pretendard JP', 'Meiryo', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
        
        test_btn.clicked.connect(test_api)
        
        cancel_btn = QPushButton("キャンセル")
        cancel_btn.setStyleSheet("""
            QPushButton { background-color: #E0E0E0; color: #666; }
            QPushButton:hover { background-color: #D0D0D0; }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        
        save_btn = QPushButton("保存")
        save_btn.clicked.connect(dialog.accept)
        
        btn_layout.addWidget(test_btn)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)
        
        dialog.setLayout(layout)
        
        if dialog.exec_() == QDialog.Accepted:
            try:
                new_key = key_input.text().strip()
                # clean_api_key 関数で すべての 異常 文字 削除
                new_key = clean_api_key(new_key)
                new_ai_enabled = ai_toggle.checked
                
                # 状態 変更 確認
                key_changed = new_key != self.gemini_api_key
                enabled_changed = new_ai_enabled != self.ai_enabled
                
                self.gemini_api_key = new_key
                self.ai_enabled = new_ai_enabled
                new_model = model_combo.currentData()
                self.gemini_model = new_model

                set_gemini_api_key(new_key)
                set_ai_enabled(new_ai_enabled)
                set_gemini_model(new_model)
                self.save_characters()
                
                # ボタン スタイル アップデート
                self.update_api_button_style()
                
                # AI 有効化されて キーが いれば キャッシュ生成
                if new_ai_enabled and new_key:
                    if key_changed or enabled_changed:
                        # キャッシュが なければ 生成
                        if not _ai_dialogues_cache:
                            self.generate_ai_cache()
                            QMessageBox.information(self, "保存完了", "API 設定が 保存されました.\nセリフ生成が 開始されます.")
                        else:
                            QMessageBox.information(self, "保存完了", "API 設定が 保存されました.")
                    else:
                        QMessageBox.information(self, "保存完了", "API 設定が 保存されました.")
                elif new_key and not new_ai_enabled:
                    QMessageBox.information(self, "保存完了", "API キーが 保存されました.\nセリフ生成 機能が 無効化されました.")
                else:
                    QMessageBox.information(self, "保存完了", "API キーが 削除されました.")
            except Exception as e:
                import traceback
                print(f"[API 保存 エラー] {e}")
                print(traceback.format_exc())
                QMessageBox.warning(self, "エラー", f"保存 中 エラー 発生:\n{str(e)}")
    
    def toggle_minimize(self):
        """最小化/復元 トグル (未使用 - 互換性 維持用)"""
        pass
    
    def show_ai_character_select_dialog(self):
        """AI セリフ 自動生成 キャラクター選択ダイアログ"""
        from PyQt5.QtWidgets import QCheckBox, QScrollArea
        
        if not self.character_data:
            QMessageBox.information(self, "キャラクターなし", "登録された キャラクターが ありません.")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("AI セリフ生成 キャラクター選択")
        dialog.setMinimumSize(350, 400)
        dialog.setMaximumWidth(450)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
            }
            QCheckBox {
                font-size: 13px;
                color: #333;
                spacing: 8px;
                padding: 8px 4px;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(12)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # タイトル
        title = QLabel("AI セリフ 自動生成 キャラクター")
        title.setStyleSheet("font-size: 18px; font-weight: 700; color: #317C75;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # 説明
        info = QLabel("選択した キャラクターのみ AI セリフが 自動 生成されます.\nセリフが少ないキャラクターが優先生成されます。")
        info.setStyleSheet("font-size: 12px; color: #666; font-weight: 500;")
        info.setWordWrap(True)
        info.setAlignment(Qt.AlignCenter)
        layout.addWidget(info)
        
        layout.addSpacing(5)
        
        # すべて選択/解除 ボタン
        select_all_layout = QHBoxLayout()
        
        select_all_btn = QPushButton("すべて選択")
        select_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 600;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        
        deselect_all_btn = QPushButton("すべて解除")
        deselect_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                border: none;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 600;
            }
            QPushButton:hover { background-color: #D0D0D0; }
        """)
        
        select_all_layout.addWidget(select_all_btn)
        select_all_layout.addWidget(deselect_all_btn)
        select_all_layout.addStretch()
        layout.addLayout(select_all_layout)
        
        # スクロール 領域
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 10px;
                background-color: white;
            }
        """)
        
        scroll_widget = QWidget()
        scroll_widget.setStyleSheet("background-color: white;")
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setSpacing(2)
        scroll_layout.setContentsMargins(10, 10, 10, 10)
        
        checkboxes = {}
        
        # キャラクター別 セリフ こと 計算 および ソート
        char_dialogue_counts = []
        for char_id, char_data in self.character_data.items():
            char_name = char_data.get('name', f'キャラクター {char_id + 1}')
            personality = char_data.get('personality', '')
            
            # セリフ こと 計算
            cache = _ai_dialogues_cache.get(char_id, {})
            solo_count = len(cache.get('solo', []))
            interaction_count = sum(len(v) for v in cache.get('interaction', {}).values())
            total_count = solo_count + interaction_count
            
            # 現在 AI 自動生成 有効化 可否
            ai_auto = char_data.get('ai_auto_generate', True)  # デフォルト True
            
            char_dialogue_counts.append({
                'char_id': char_id,
                'name': char_name,
                'personality': personality,
                'total_count': total_count,
                'ai_auto': ai_auto
            })
        
        # セリフ 数が 少ない 順序で ソート
        char_dialogue_counts.sort(key=lambda x: x['total_count'])
        
        for item in char_dialogue_counts:
            char_id = item['char_id']
            char_name = item['name']
            personality = item['personality']
            total_count = item['total_count']
            ai_auto = item['ai_auto']
            
            # チェックボックス 生成
            cb = QCheckBox()
            cb.setChecked(ai_auto)
            
            # 性格 有無に による 表示
            if personality:
                label_text = f"{char_name} (セリフ {total_count}個)"
                cb.setStyleSheet("QCheckBox { color: #333; }")
            else:
                label_text = f"{char_name} (性格 未設定)"
                cb.setStyleSheet("QCheckBox { color: #999; }")
            
            cb.setText(label_text)
            checkboxes[char_id] = cb
            scroll_layout.addWidget(cb)
        
        scroll_layout.addStretch()
        scroll.setWidget(scroll_widget)
        layout.addWidget(scroll)
        
        # すべて選択/解除 機能
        def select_all():
            for cb in checkboxes.values():
                cb.setChecked(True)
        
        def deselect_all():
            for cb in checkboxes.values():
                cb.setChecked(False)
        
        select_all_btn.clicked.connect(select_all)
        deselect_all_btn.clicked.connect(deselect_all)
        
        # ボタン
        btn_layout = QHBoxLayout()
        
        cancel_btn = QPushButton("キャンセル")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                border: none;
                padding: 10px 20px;
                border-radius: 10px;
                font-weight: 600;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #D0D0D0; }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        
        save_btn = QPushButton("保存")
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 10px;
                font-weight: 700;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        save_btn.clicked.connect(dialog.accept)
        
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)
        
        dialog.setLayout(layout)
        
        if dialog.exec_() == QDialog.Accepted:
            # 設定 保存
            for char_id, cb in checkboxes.items():
                if char_id in self.character_data:
                    self.character_data[char_id]['ai_auto_generate'] = cb.isChecked()
                
                # CharacterWidgetにも 反映
                for char in self.characters:
                    if char.char_id == char_id:
                        char.ai_auto_generate = cb.isChecked()
                        break
            
            self.save_characters()
            
            # 有効化された キャラクター こと 計算
            enabled_count = sum(1 for cb in checkboxes.values() if cb.isChecked())
            total_count = len(checkboxes)
            
            QMessageBox.information(self, "保存完了", 
                f"設定が 保存されました.\n\n{enabled_count}/{total_count}個 キャラクターが AI セリフ 自動生成 対象です.")
    
    def close_all(self):
        """すべての キャラクターと プログラム 終了"""
        self.save_characters()
        for char in self.characters:
            char.close()
        self.close()
    
    def _set_svg_icon(self, button, svg_data, size):
        """SVG データで ボタン アイコン 設定 (比率維持)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 元の サイズ 取得
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 比率維持しながら sizeに 合う スケール
            if orig_w >= orig_h:
                scale = size / orig_w
                new_w = size
                new_h = int(orig_h * scale)
            else:
                scale = size / orig_h
                new_h = size
                new_w = int(orig_w * scale)
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
    
    def _set_button_icon(self, button, svg_data, size):
        """ボタンに SVG アイコン 設定 (比率維持, テキスト 維持)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 元の サイズ 取得
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 比率維持しながら sizeに 合う スケール
            if orig_w >= orig_h:
                scale = size / orig_w
                new_w = size
                new_h = int(orig_h * scale)
            else:
                scale = size / orig_h
                new_h = size
                new_w = int(orig_w * scale)
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
    
    def show_tutorial(self):
        """チュートリアル ダイアログ 表示"""
        from PyQt5.QtWidgets import QMessageBox
        msg = QMessageBox(self)
        msg.setWindowTitle("Kiwipet 使用方法")
        msg.setText(
            "<b>Kiwipet 使用ガイド</b><br><br>"
            "<b>1. キャラクター追加</b><br>"
            "• 'キャラクターを追加'ボタンで画像を追加してください。<br>"
            "• キャラクターが見ている方向を選択してください。<br><br>"
            "<b>2. 性格設定</b><br>"
            "• 名前を設定します。<br>"
            "• 'キャラクター セリフ&amp;性格 設定'に入ります。<br>"
            "• 基本セリフと性格を入力します。<br><br>"
            "<b>3. 関係設定</b><br>"
            "• 'キャラクター間感情設定'から他のキャラクターへ感じる感情を指定します。<br>"
            "• 感情に応じて相互作用が変わります。<br><br>"
            "<b>4. API有効化</b><br>"
            "• ガイドに従ってAPIキーを発行してください。<br>"
            "• キーを入力して有効化し、しばらくお待ちください。<br><br>"
            "<b>5. バックアップ</b><br>"
            "• 'キャラクターバックアップ'ですべてのキャラクターデータを保存できます。"
        )
        msg.setStyleSheet("""
            QMessageBox {
                background-color: #E8F5EE;
            }
            QLabel {
                color: #3D7A5F;
                font-size: 13px;
            }
        """)
        msg.exec_()
    
    def backup_all_characters(self):
        """キャラクター な括 バックアップ ダイアログ"""
        # キャラクターが なければ 読み込む オプション 提供
        if not self.character_data:
            from PyQt5.QtWidgets import QMessageBox
            reply = QMessageBox.question(
                self,
                "キャラクターバックアップ",
                "バックアップする キャラクターが ありません.\n\n全体 バックアップ ファイルから キャラクターを 読み込みますか?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                self._import_all_characters()
            return
        
        from PyQt5.QtWidgets import QCheckBox
        from PyQt5.QtSvg import QSvgRenderer
        import subprocess
        
        # バックアップ ダイアログ 生成
        dialog = QDialog(self)
        dialog.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        dialog.setFixedWidth(340)
        
        # メイン コンテナ
        container = QWidget()
        container.setStyleSheet("""
            QWidget#backupContainer {
                background-color: #E8F5EE;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        container.setObjectName("backupContainer")
        
        main_layout = QVBoxLayout(container)
        main_layout.setContentsMargins(20, 16, 20, 20)
        main_layout.setSpacing(12)
        
        # X ボタン (右 上部)
        close_layout = QHBoxLayout()
        close_layout.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(dialog.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        close_layout.addWidget(close_btn)
        main_layout.addLayout(close_layout)
        
        # タイトル
        title = QLabel("キャラクター な括 バックアップ")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 18px;
            font-weight: 700;
            color: #317C75;
            background: transparent;
        """)
        main_layout.addWidget(title)
        
        # 説明 ボックス
        desc_box = QWidget()
        desc_box.setStyleSheet("""
            background-color: white;
            border-radius: 12px;
            border: 1px solid #9DD4BA;
        """)
        desc_layout = QVBoxLayout(desc_box)
        desc_layout.setContentsMargins(15, 12, 15, 12)
        
        desc_text = QLabel("バックアップする キャラクターを 選択した 後,\n'キャラクターバックアップする' ボタンとして エクスポートしてください.\n\n各 キャラクターが (名前)_バックアップ フォルダで\n保存されます. (画像+JSON)")
        desc_text.setAlignment(Qt.AlignCenter)
        desc_text.setStyleSheet("""
            font-size: 12px;
            color: #5A9C85;
            background: transparent;
            border: none;
        """)
        desc_layout.addWidget(desc_text)
        main_layout.addWidget(desc_box)
        
        # すべて選択 + エクスポート パス ボタン
        top_btn_layout = QHBoxLayout()
        
        select_all_cb = QCheckBox("すべて選択")
        select_all_cb.setChecked(True)
        select_all_cb.setStyleSheet("""
            QCheckBox {
                font-size: 13px;
                color: #317C75;
                spacing: 6px;
                background: transparent;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border-radius: 4px;
                border: 2px solid #8ECFB5;
            }
            QCheckBox::indicator:checked {
                background-color: #8ECFB5;
                border: 2px solid #8ECFB5;
            }
        """)
        top_btn_layout.addWidget(select_all_cb)
        top_btn_layout.addStretch()
        
        export_path_btn = QPushButton("📁 エクスポート パス")
        export_path_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #317C75;
                border: 1px solid #9DD4BA;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        
        # エクスポート パス 保存 変数 (設定 ファイルから 読み)
        last_backup = ''
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                    last_backup = config_data.get('last_backup_folder', '')
            except:
                pass
        self._backup_export_path = last_backup
        
        def select_export_path():
            from PyQt5.QtWidgets import QFileDialog
            folder = QFileDialog.getExistingDirectory(dialog, "エクスポート パス 選択", self._backup_export_path or "")
            if folder:
                self._backup_export_path = folder
        
        export_path_btn.clicked.connect(select_export_path)
        top_btn_layout.addWidget(export_path_btn)
        main_layout.addLayout(top_btn_layout)
        
        # キャラクター チェックボックス リスト
        checkbox_container = QWidget()
        checkbox_container.setStyleSheet("""
            background-color: white;
            border-radius: 12px;
            border: 1px solid #9DD4BA;
        """)
        checkbox_layout = QVBoxLayout(checkbox_container)
        checkbox_layout.setContentsMargins(15, 12, 15, 12)
        checkbox_layout.setSpacing(8)
        
        checkboxes = {}
        for char_id, data in self.character_data.items():
            char_name = data.get('name', f'キャラクター {char_id + 1}')
            cb = QCheckBox(char_name)
            cb.setChecked(True)
            cb.setStyleSheet("""
                QCheckBox {
                    font-size: 13px;
                    color: #317C75;
                    spacing: 8px;
                    border: none;
                    background: transparent;
                }
                QCheckBox::indicator {
                    width: 16px;
                    height: 16px;
                    border-radius: 4px;
                    border: 2px solid #C5E8D8;
                }
                QCheckBox::indicator:checked {
                    background-color: #8ECFB5;
                    border: 2px solid #8ECFB5;
                }
            """)
            checkboxes[char_id] = cb
            checkbox_layout.addWidget(cb)
        
        # すべて選択 チェックボックス 連動
        def toggle_all(checked):
            for cb in checkboxes.values():
                cb.setChecked(checked)
        select_all_cb.toggled.connect(toggle_all)
        
        # 個別 チェックボックス 変更 時 すべて選択 状態 アップデート
        def update_select_all():
            all_checked = all(cb.isChecked() for cb in checkboxes.values())
            select_all_cb.blockSignals(True)
            select_all_cb.setChecked(all_checked)
            select_all_cb.blockSignals(False)
        
        for cb in checkboxes.values():
            cb.toggled.connect(update_select_all)
        
        main_layout.addWidget(checkbox_container)
        
        # キャラクターバックアップする ボタン
        backup_btn = QPushButton("キャラクターバックアップする")
        backup_btn.setMinimumHeight(42)
        backup_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                font-weight: 700;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        def do_backup():
            selected = [cid for cid, cb in checkboxes.items() if cb.isChecked()]
            if not selected:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.warning(dialog, "バックアップ", "バックアップする キャラクターを 選択してください.")
                return
            
            dialog.accept()
            self._backup_selected_characters(selected, self._backup_export_path)
        
        backup_btn.clicked.connect(do_backup)
        main_layout.addWidget(backup_btn)
        
        # アプリ全体バックアップ/読み込み ボタン
        app_backup_btn = QPushButton("アプリ全体バックアップ/読み込み")
        app_backup_btn.setMinimumHeight(42)
        app_backup_btn.setCursor(Qt.PointingHandCursor)
        app_backup_btn.setStyleSheet("""
            QPushButton {
                background-color: #E8F5EE;
                color: #5A9C85;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                font-weight: 700;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #D8EBE0;
            }
        """)
        app_backup_btn.clicked.connect(lambda: self._show_app_backup_dialog_from_batch(dialog))
        main_layout.addWidget(app_backup_btn)
        
        # バックアップされた パス 開く ボタン
        open_folder_btn = QPushButton("バックアップされた パス 開く")
        open_folder_btn.setMinimumHeight(42)
        open_folder_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #5A9C85;
                border: 1px solid #9DD4BA;
                border-radius: 12px;
                font-weight: 700;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        
        def open_backup_folder():
            import subprocess
            # 設定 ファイルから パス 読み
            backup_path = ''
            if os.path.exists(self.config_file):
                try:
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        config_data = json.load(f)
                        backup_path = config_data.get('last_backup_folder', '')
                except:
                    pass
            
            if backup_path and os.path.exists(backup_path):
                try:
                    if sys.platform == 'win32':
                        os.startfile(backup_path)
                    elif sys.platform == 'darwin':
                        subprocess.run(['open', backup_path])
                    else:
                        subprocess.run(['xdg-open', backup_path])
                except Exception as e:
                    print(f"フォルダ 開く 失敗: {e}")
            else:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.information(dialog, "お知らせ", "まだ バックアップされた フォルダが ありません.\nまず バックアップを 進行してください.")
        
        open_folder_btn.clicked.connect(open_backup_folder)
        main_layout.addWidget(open_folder_btn)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()
    
    def _backup_selected_characters(self, char_ids, export_path=''):
        """選択された キャラクターたち バックアップ (フォルダ + 画像 + JSON 方式)"""
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        import json
        import shutil
        import re
        
        # フォルダ選択 (export_pathが なければ ダイアログで 選択)
        folder = export_path if export_path and os.path.exists(export_path) else QFileDialog.getExistingDirectory(self, "バックアップ 保存 位置 選択")
        if not folder:
            return
        
        try:
            backup_count = 0
            created_folders = []
            
            # 選択された キャラクター それぞれ フォルダで バックアップ
            for char_id in char_ids:
                if char_id not in self.character_data:
                    continue
                    
                data = self.character_data[char_id]
                char_name = data.get('name', f'キャラクター_{char_id}')
                
                # フォルダ体 生成 (特別文字 削除)
                safe_name = re.sub(r'[<>:"/\\|?*]', '', char_name).strip()
                if not safe_name:
                    safe_name = f'キャラクター_{char_id}'
                
                backup_folder = os.path.join(folder, f"{safe_name}_バックアップ")
                
                # 同じ 名前 フォルダが いれば 数字 付ける
                counter = 1
                original_folder = backup_folder
                while os.path.exists(backup_folder):
                    backup_folder = f"{original_folder}_{counter}"
                    counter += 1
                
                os.makedirs(backup_folder, exist_ok=True)
                created_folders.append(backup_folder)
                
                # 画像 コピー
                image_file = "image.png"
                image_path = data.get('image_path', '')
                if image_path and os.path.exists(image_path):
                    ext = os.path.splitext(image_path)[1] or '.png'
                    image_file = f"image{ext}"
                    shutil.copy2(image_path, os.path.join(backup_folder, image_file))
                
                # AI キャッシュ 取得
                ai_cache = {}
                if char_id in _ai_dialogues_cache:
                    cache = _ai_dialogues_cache[char_id]
                    ai_cache = {
                        'solo': cache.get('solo', []),
                        'interaction': cache.get('interaction', {}),
                        'fallback': cache.get('fallback', []),
                        'reference': cache.get('reference', {})  # 参考用手動セリフ
                    }
                
                # バックアップ データ 生成 (画像 ファイル体のみ 保存, base64 なし)
                # nicknamesと storiesの キーを char_idから char_nameとして 変換
                nicknames_by_name = {}
                stories_by_name = {}
                
                raw_nicknames = data.get('nicknames', {})
                raw_stories = data.get('stories', {})
                
                for other_id, nickname in raw_nicknames.items():
                    try:
                        other_id_int = int(other_id) if isinstance(other_id, str) else other_id
                        if other_id_int in self.character_data:
                            other_name = self.character_data[other_id_int].get('name', f'キャラクター_{other_id_int}')
                            nicknames_by_name[other_name] = nickname
                    except:
                        pass
                
                for other_id, story in raw_stories.items():
                    try:
                        other_id_int = int(other_id) if isinstance(other_id, str) else other_id
                        if other_id_int in self.character_data:
                            other_name = self.character_data[other_id_int].get('name', f'キャラクター_{other_id_int}')
                            stories_by_name[other_name] = story
                    except:
                        pass
                
                backup_data = {
                    'version': '3.1',  # バージョン アップ (名前 ベース 呼び方/ストーリー)
                    'backup_type': 'single_character',
                    'char_name': char_name,
                    'image_file': image_file,
                    'catchphrase': data.get('catchphrase', ''),
                    'personality': data.get('personality', ''),
                    'background_story': data.get('background_story', ''),
                    'nicknames': nicknames_by_name,  # 名前 ベース
                    'stories': stories_by_name,  # 名前 ベース
                    'nicknames_by_id': data.get('nicknames', {}),  # 旧バージョン 互換用
                    'stories_by_id': data.get('stories', {}),  # 旧バージョン 互換用
                    'sample_dialogues': data.get('sample_dialogues', []),
                    'dialogues': self.dialogues.get(char_id, {'基本': []}),
                    'ai_cache': ai_cache,
                    'scale': data.get('scale', 100),
                    'bubble_color': data.get('bubble_color', '#A8D5BA'),
                    'bubble_size': data.get('bubble_size', 100),
                    'facing_direction': data.get('facing_direction', 'right'),
                    'is_active': data.get('is_active', True)
                }
                
                # JSONファイルで 保存
                json_path = os.path.join(backup_folder, "data.json")
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(backup_data, f, ensure_ascii=False, indent=2)
                
                backup_count += 1
            
            # 最後 バックアップ フォルダ パス 保存
            try:
                config_data = {}
                if os.path.exists(self.config_file):
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        config_data = json.load(f)
                config_data['last_backup_folder'] = folder
                with open(self.config_file, 'w', encoding='utf-8') as f:
                    json.dump(config_data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                print(f"バックアップ パス 保存 失敗: {e}")
            
            QMessageBox.information(self, "バックアップ完了", 
                f"バックアップが 完了しました!\n\n"
                f"📁 保存 位置: {folder}")
        
        except Exception as e:
            QMessageBox.warning(self, "バックアップ 失敗", f"バックアップ 中 エラーが 発生しました:\n{str(e)}")
    
    def show_credit_dialog(self):
        """クレジット ダイアログ 表示"""
        from PyQt5.QtSvg import QSvgRenderer
        
        dialog = QDialog(self)
        dialog.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        dialog.setFixedWidth(371)  # 331 + padding
        
        # メイン コンテナ
        container = QWidget()
        container.setStyleSheet("""
            QWidget#creditContainer {
                background-color: white;
                border-radius: 20px;
                border: 1px solid #C5E8D8;
            }
        """)
        container.setObjectName("creditContainer")
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 16, 20, 20)
        layout.setSpacing(0)
        
        # 閉じる ボタン (左 上部)
        close_btn = QPushButton()
        close_btn.setFixedSize(20, 20)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(dialog.close)
        
        # X アイコン SVG
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        
        # 閉じる ボタン 右 ソート
        close_layout = QHBoxLayout()
        close_layout.setContentsMargins(0, 0, 0, 10)
        close_layout.addStretch()
        close_layout.addWidget(close_btn)
        layout.addLayout(close_layout)
        
        # Kiwipet タイトル ロゴ (SVG 使用)
        kiwipet_title_svg = '''<svg width="150" height="76" viewBox="0 0 150 76" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M46.6403 43.9567C47.0397 43.9567 47.347 44.1411 47.5621 44.5098C47.8079 44.8785 47.9308 45.3854 47.9308 46.0306C47.9308 47.2289 47.6389 48.1814 47.0551 48.8881C45.5803 50.6701 44.0901 52.0527 42.5846 53.0359C41.0791 53.9884 39.2971 54.4646 37.2385 54.4646C34.9649 54.4646 33.106 53.804 31.6619 52.4829C30.2179 51.131 28.866 49.0417 27.6063 46.215C26.6845 44.1872 25.9164 42.6816 25.3019 41.6984C24.7181 40.6845 24.1344 39.9779 23.5506 39.5784C22.9668 39.1483 22.2294 38.8871 21.3384 38.7949L20.8314 42.2054C20.1862 46.5991 18.9265 49.7637 17.0523 51.6994C15.2088 53.635 12.6586 54.6029 9.4018 54.6029C7.28179 54.6029 5.39221 54.0959 3.73307 53.082C2.10465 52.0374 0.967833 50.7162 0.322611 49.1185C0.107537 48.5654 0 47.9663 0 47.3211C0 46.3993 0.215074 45.6005 0.645222 44.9246C1.07537 44.2486 1.62842 43.9106 2.30436 43.9106C2.70379 43.9106 3.04176 44.0182 3.31828 44.2332C3.59481 44.4176 3.85597 44.7556 4.10177 45.2472C5.05424 47.0292 5.88381 48.2736 6.59048 48.9802C7.32787 49.6869 8.23426 50.0402 9.30963 50.0402C10.5386 50.0402 11.5833 49.4872 12.4436 48.3811C13.3346 47.2443 13.9644 45.5083 14.3331 43.1732L14.9784 38.7949H14.241C13.5343 38.7949 12.9812 38.5952 12.5818 38.1958C12.1824 37.7964 11.9827 37.2433 11.9827 36.5367C11.9827 35.7378 12.1824 35.108 12.5818 34.6471C13.012 34.1555 13.5343 33.9097 14.1488 33.9097H15.6697C15.8847 32.4042 16.0384 31.3595 16.1305 30.7758L17.5592 20.4061C16.7604 20.314 16.0076 20.2679 15.301 20.2679C12.6894 20.2679 10.7076 20.7287 9.35571 21.6505C8.00382 22.5415 7.32787 23.8319 7.32787 25.5218C7.32787 26.2899 7.40469 26.9198 7.55831 27.4114C7.74266 27.8723 7.9731 28.3946 8.24962 28.9784C8.37252 29.2242 8.43397 29.5007 8.43397 29.8079C8.43397 30.4839 8.11136 31.083 7.46614 31.6053C6.85164 32.0969 6.16033 32.3427 5.39221 32.3427C4.40902 32.3427 3.68698 31.9126 3.22611 31.0523C2.30436 29.4239 1.84349 27.6726 1.84349 25.7983C1.84349 23.8627 2.36581 22.096 3.41046 20.4983C4.48583 18.9006 6.09888 17.6255 8.24962 16.6731C10.4004 15.6899 13.0581 15.1983 16.2227 15.1983C17.6053 15.1983 18.8651 15.2751 20.0019 15.4287C21.1694 15.5823 22.4445 15.8742 23.8271 16.3044C25.3326 16.7652 26.0854 17.6255 26.0854 18.8853C26.0854 20.5751 25.3634 21.42 23.9193 21.42L22.1219 33.8175C25.7167 33.4488 28.6356 31.9126 30.8785 29.2088C33.1521 26.4743 35.0417 22.7719 36.5472 18.1018C36.8237 17.2415 37.2846 16.5809 37.9298 16.12C38.6058 15.6591 39.4507 15.4287 40.4646 15.4287C41.3249 15.4287 41.9855 15.6284 42.4464 16.0278C42.938 16.3965 43.1838 16.9342 43.1838 17.6409C43.1838 17.856 43.1223 18.2093 42.9994 18.7009C41.4632 23.7705 39.2663 27.7955 36.4089 30.7758C33.5515 33.7561 30.433 35.7378 27.0532 36.721C28.2208 36.9975 29.1732 37.4123 29.9106 37.9654C30.6788 38.5184 31.324 39.2097 31.8463 40.0393C32.3686 40.8381 32.9678 41.9596 33.6437 43.4037C34.5962 45.4315 35.4872 46.8756 36.3168 47.7359C37.1463 48.5654 38.1142 48.9802 39.2203 48.9802C40.2035 48.9802 41.1406 48.6576 42.0316 48.0124C42.9226 47.3365 44.0441 46.1996 45.396 44.6019C45.7646 44.1718 46.1794 43.9567 46.6403 43.9567Z" fill="#4FB98F"/>
<path d="M48.8305 29.7158C47.5401 29.7158 46.5723 29.4239 45.927 28.8401C45.2818 28.2256 44.9592 27.3807 44.9592 26.3053C44.9592 25.2299 45.374 24.3389 46.2036 23.6322C47.0639 22.8948 48.1239 22.5261 49.3836 22.5261C50.5204 22.5261 51.4421 22.8027 52.1488 23.3557C52.8555 23.9088 53.2088 24.6922 53.2088 25.7062C53.2088 26.9352 52.8094 27.9184 52.0106 28.6558C51.2117 29.3624 50.1517 29.7158 48.8305 29.7158ZM48.4618 54.4646C46.4647 54.4646 45.0053 53.7579 44.0835 52.3446C43.1925 50.9313 42.747 49.057 42.747 46.722C42.747 45.3393 42.916 43.5727 43.254 41.4219C43.6227 39.2405 44.0835 37.2126 44.6366 35.3384C44.9131 34.3552 45.2818 33.6793 45.7427 33.3106C46.2036 32.9419 46.941 32.7575 47.9549 32.7575C49.5218 32.7575 50.3053 33.2798 50.3053 34.3245C50.3053 35.0926 50.0134 36.8746 49.4297 39.6706C48.6923 43.0503 48.3236 45.3393 48.3236 46.5376C48.3236 47.4594 48.4465 48.166 48.6923 48.6576C48.9381 49.1492 49.3529 49.395 49.9366 49.395C50.4897 49.395 51.181 49.011 52.0106 48.2428C52.8401 47.4747 53.9462 46.2611 55.3288 44.6019C55.6975 44.1718 56.1123 43.9567 56.5732 43.9567C56.9726 43.9567 57.2799 44.1411 57.4949 44.5098C57.7407 44.8785 57.8636 45.3854 57.8636 46.0306C57.8636 47.2596 57.5718 48.2121 56.988 48.8881C53.9462 52.6058 51.1042 54.4646 48.4618 54.4646Z" fill="#4FB98F"/>
<path d="M87.5834 40.2237C87.6756 40.1929 87.8292 40.1776 88.0443 40.1776C88.5052 40.1776 88.8585 40.3312 89.1043 40.6384C89.3501 40.9457 89.473 41.3605 89.473 41.8828C89.473 42.8353 89.2887 43.588 88.92 44.1411C88.5513 44.6634 87.9982 45.0475 87.2608 45.2932C85.8475 45.7541 84.342 45.9846 82.7443 45.9846C81.3924 45.9846 80.1173 45.8002 78.919 45.4315C78.028 46.8756 77.0448 48.3657 75.9694 49.902C74.7404 51.6533 73.6805 52.8516 72.7894 53.4968C71.9291 54.142 70.9459 54.4646 69.8398 54.4646C68.6108 54.4646 67.6737 53.9884 67.0285 53.0359C66.414 52.0834 66.03 50.5165 65.8763 48.335L65.6459 44.9706C64.6934 47.5515 63.8331 49.5179 63.065 50.8698C62.3276 52.2217 61.5749 53.1588 60.8067 53.6811C60.0693 54.2035 59.1937 54.4646 58.1798 54.4646C56.92 54.4646 55.9215 53.973 55.1841 52.9898C54.4774 52.0066 54.0319 50.455 53.8476 48.335C53.4789 44.0335 53.2945 40.2697 53.2945 37.0436V35.4306C53.3252 34.4167 53.6018 33.71 54.1241 33.3106C54.6464 32.9111 55.4299 32.7114 56.4745 32.7114C57.2734 32.7114 57.8572 32.8958 58.2259 33.2645C58.6253 33.6024 58.825 34.1862 58.825 35.0158C58.825 38.5491 59.0401 43.1425 59.4702 48.7959C61.5595 44.4022 63.4798 39.8242 65.2311 35.0619C65.5691 34.1401 65.9685 33.5256 66.4294 33.2184C66.921 32.8804 67.5048 32.7114 68.1807 32.7114C69.0103 32.7114 69.5787 32.8804 69.8859 33.2184C70.2239 33.5564 70.3929 34.1555 70.3929 35.0158C70.3929 38.5491 70.608 43.1425 71.0381 48.7959C72.8816 46.0614 74.2642 43.8799 75.186 42.2515C74.7251 41.3605 74.4947 40.3005 74.4947 39.0715C74.4947 38.0268 74.7251 37.0129 75.186 36.0297C75.6468 35.0465 76.2767 34.2477 77.0755 33.6332C77.8744 33.0187 78.7808 32.7114 79.7947 32.7114C80.6857 32.7114 81.4077 33.034 81.9608 33.6793C82.5138 34.2938 82.7904 35.2001 82.7904 36.3984C82.7904 37.781 82.4217 39.3634 81.6843 41.1454C82.8518 41.0839 84.4034 40.8535 86.3391 40.4541L87.5834 40.2237Z" fill="#4FB98F"/>
<path d="M90.1272 29.7158C88.8368 29.7158 87.869 29.4239 87.2237 28.8401C86.5785 28.2256 86.2559 27.3807 86.2559 26.3053C86.2559 25.2299 86.6707 24.3389 87.5003 23.6322C88.3606 22.8948 89.4206 22.5261 90.6803 22.5261C91.8171 22.5261 92.7389 22.8027 93.4455 23.3557C94.1522 23.9088 94.5055 24.6922 94.5055 25.7062C94.5055 26.9352 94.1061 27.9184 93.3073 28.6558C92.5084 29.3624 91.4484 29.7158 90.1272 29.7158ZM89.7585 54.4646C87.7614 54.4646 86.302 53.7579 85.3802 52.3446C84.4892 50.9313 84.0437 49.057 84.0437 46.722C84.0437 45.3393 84.2127 43.5727 84.5507 41.4219C84.9194 39.2405 85.3803 37.2126 85.9333 35.3384C86.2098 34.3552 86.5785 33.6793 87.0394 33.3106C87.5003 32.9419 88.2377 32.7575 89.2516 32.7575C90.8186 32.7575 91.602 33.2798 91.602 34.3245C91.602 35.0926 91.3101 36.8746 90.7264 39.6706C89.989 43.0503 89.6203 45.3393 89.6203 46.5376C89.6203 47.4594 89.7432 48.166 89.989 48.6576C90.2348 49.1492 90.6496 49.395 91.2333 49.395C91.7864 49.395 92.4777 49.011 93.3073 48.2428C94.1368 47.4747 95.2429 46.2611 96.6255 44.6019C96.9942 44.1718 97.409 43.9567 97.8699 43.9567C98.2693 43.9567 98.5766 44.1411 98.7916 44.5098C99.0374 44.8785 99.1603 45.3854 99.1603 46.0306C99.1603 47.2596 98.8685 48.2121 98.2847 48.8881C95.2429 52.6058 92.4009 54.4646 89.7585 54.4646Z" fill="#4FB98F"/>
<path d="M118.66 43.9567C119.059 43.9567 119.366 44.1411 119.581 44.5098C119.827 44.8785 119.95 45.3854 119.95 46.0306C119.95 47.2596 119.658 48.2121 119.074 48.8881C117.753 50.5165 116.324 51.853 114.788 52.8977C113.283 53.9423 111.562 54.4646 109.626 54.4646C107.998 54.4646 106.677 53.8808 105.663 52.7133C103.912 53.8501 102.084 54.4339 100.179 54.4646C99.7792 60.3945 98.8728 65.3412 97.4594 69.3047C96.0461 73.2989 93.9722 75.2961 91.2377 75.2961C89.5785 75.2961 88.3495 74.6969 87.5507 73.4987C86.7518 72.3004 86.3524 70.6412 86.3524 68.5212C86.3524 65.5102 87.0437 61.9922 88.4263 57.9672C89.8089 53.973 91.9443 49.564 94.8325 44.7402C94.8325 40.2544 94.8017 37.1358 94.7403 35.3845C94.7096 34.4935 95.0629 33.7868 95.8003 33.2645C96.5377 32.7422 97.4594 32.481 98.5655 32.481C99.2107 32.481 99.6716 32.6193 99.9481 32.8958C100.255 33.1416 100.424 33.6485 100.455 34.4167C100.455 35.1848 100.47 35.7532 100.501 36.1219C101.484 34.8929 102.452 34.0172 103.405 33.4949C104.357 32.9419 105.371 32.6653 106.446 32.6653C108.167 32.6653 109.565 33.3566 110.64 34.7393C111.746 36.1219 112.3 37.9347 112.3 40.1776C112.3 41.806 112.038 43.3883 111.516 44.9246C110.994 46.4608 110.272 47.8588 109.35 49.1185C109.995 49.3028 110.533 49.395 110.963 49.395C111.977 49.395 112.945 49.0263 113.866 48.2889C114.788 47.5515 115.971 46.3225 117.415 44.6019C117.784 44.1718 118.199 43.9567 118.66 43.9567ZM100.409 50.0402C101.515 49.7944 102.529 49.1953 103.451 48.2428C104.403 47.2596 105.156 46.0614 105.709 44.648C106.262 43.204 106.539 41.6984 106.539 40.1315C106.539 39.2097 106.354 38.5184 105.986 38.0576C105.617 37.566 105.125 37.3202 104.511 37.3202C103.405 37.3202 102.068 38.4877 100.501 40.8228C100.47 42.1747 100.455 44.1564 100.455 46.768C100.455 48.1814 100.44 49.2721 100.409 50.0402ZM91.6063 70.7795C92.4359 70.7795 93.1272 68.9667 93.6803 65.3412C94.2333 61.7464 94.5867 57.2606 94.7403 51.8837C93.4191 54.9562 92.3745 57.8904 91.6063 60.6864C90.8382 63.4824 90.4542 65.8328 90.4542 67.7378C90.4542 68.7209 90.5771 69.4737 90.8229 69.996C91.0379 70.5183 91.2991 70.7795 91.6063 70.7795Z" fill="#4FB98F"/>
<path d="M135.41 43.9567C135.809 43.9567 136.116 44.1411 136.332 44.5098C136.577 44.8785 136.7 45.3854 136.7 46.0306C136.7 47.2596 136.408 48.2121 135.825 48.8881C134.688 50.2707 133.075 51.5458 130.985 52.7133C128.927 53.8808 126.715 54.4646 124.349 54.4646C121.123 54.4646 118.619 53.589 116.837 51.8376C115.055 50.0863 114.164 47.6898 114.164 44.648C114.164 42.528 114.609 40.5616 115.5 38.7489C116.391 36.9054 117.62 35.4459 119.187 34.3706C120.785 33.2952 122.582 32.7575 124.579 32.7575C126.361 32.7575 127.79 33.2952 128.865 34.3706C129.941 35.4152 130.478 36.8439 130.478 38.6567C130.478 40.7767 129.71 42.6048 128.174 44.1411C126.669 45.6466 124.103 46.8449 120.478 47.7359C121.246 49.1492 122.705 49.8559 124.856 49.8559C126.238 49.8559 127.805 49.3797 129.557 48.4272C131.339 47.444 132.875 46.1689 134.165 44.6019C134.534 44.1718 134.949 43.9567 135.41 43.9567ZM123.796 37.2741C122.659 37.2741 121.691 37.9347 120.892 39.2558C120.124 40.577 119.74 42.1747 119.74 44.0489V44.1411C121.553 43.7109 122.982 43.0657 124.026 42.2054C125.071 41.3451 125.593 40.3466 125.593 39.2097C125.593 38.626 125.424 38.1651 125.086 37.8271C124.779 37.4584 124.349 37.2741 123.796 37.2741Z" fill="#4FB98F"/>
<path d="M139.169 37.1358C139.108 38.672 139.077 39.8703 139.077 40.7306C139.077 42.9428 139.185 44.6788 139.4 45.9385C139.646 47.1675 140.03 48.0585 140.552 48.6115C141.105 49.1339 141.858 49.395 142.81 49.395C143.302 49.395 143.886 49.2414 144.562 48.9341C145.238 48.6269 145.852 48.2275 146.405 47.7359C146.743 47.4286 147.081 47.275 147.419 47.275C147.788 47.275 148.08 47.4901 148.295 47.9202C148.541 48.3196 148.663 48.8112 148.663 49.395C148.663 49.9788 148.541 50.5472 148.295 51.1002C148.08 51.6533 147.742 52.1142 147.281 52.4829C145.683 53.804 143.87 54.4646 141.843 54.4646C138.924 54.4646 136.788 53.251 135.436 50.8237C134.085 48.3657 133.409 45.1704 133.409 41.2376C133.409 39.8857 133.455 38.5184 133.547 37.1358H131.749C130.828 37.1358 130.198 36.9668 129.86 36.6288C129.553 36.2909 129.399 35.7532 129.399 35.0158C129.399 33.2952 130.09 32.4349 131.473 32.4349H134.1C134.622 29.0552 135.421 25.9673 136.496 23.1714C137.572 20.3754 138.862 18.1479 140.368 16.4887C141.904 14.8296 143.548 14 145.299 14C146.59 14 147.603 14.5684 148.341 15.7052C149.078 16.842 149.447 18.2708 149.447 19.9913C149.447 24.7537 147.45 28.9015 143.456 32.4349H148.617C149.109 32.4349 149.462 32.5424 149.677 32.7575C149.892 32.9726 150 33.372 150 33.9558C150 36.0758 148.264 37.1358 144.792 37.1358H139.169ZM144.055 18.4244C143.594 18.4244 143.072 19.0081 142.488 20.1757C141.935 21.3125 141.397 22.9102 140.875 24.9688C140.383 26.9966 139.968 29.2549 139.63 31.7436C141.443 30.1766 142.795 28.4253 143.686 26.4896C144.608 24.5233 145.069 22.7412 145.069 21.1435C145.069 19.3308 144.731 18.4244 144.055 18.4244Z" fill="#4FB98F"/>
</svg>'''
        
        renderer = QSvgRenderer(kiwipet_title_svg.encode('utf-8'))
        if renderer.isValid():
            # 150x76 比率維持しながら 高く 38で レンダリング (クレジットに 合う 縮小)
            title_pixmap = QPixmap(150, 76)
            title_pixmap.fill(Qt.transparent)
            painter = QPainter(title_pixmap)
            renderer.render(painter)
            painter.end()
            
            # 適切な サイズで スケール
            title_pixmap = title_pixmap.scaledToHeight(38, Qt.SmoothTransformation)
            
            title_label = QLabel()
            title_label.setPixmap(title_pixmap)
            title_label.setAlignment(Qt.AlignCenter)
            title_label.setContentsMargins(0, 0, 0, 15)
            layout.addWidget(title_label)
        
        # クレジット 内容 (各 行を 個別 ラベルで)
        credit_style = """
            QLabel {
                color: #349971;
                font-family: 'Pretendard JP', 'Meiryo', sans-serif;
                font-size: 14px;
                font-weight: 700;
                line-height: 19px;
                background: transparent;
                border: none;
            }
        """
        
        divider_style = """
            QLabel {
                color: #C5E8D8;
                font-size: 14px;
                background: transparent;
                border: none;
            }
        """
        
        def add_text(text, style=credit_style, margin_top=0, margin_bottom=0):
            label = QLabel(text)
            label.setAlignment(Qt.AlignCenter)
            label.setStyleSheet(style)
            label.setContentsMargins(0, margin_top, 0, margin_bottom)
            layout.addWidget(label)
        
        def add_divider():
            add_text("—", divider_style, 8, 8)
        
        # Version & Release
        add_text("Version 1.2.2")
        add_text("Release 2026.01.11", margin_bottom=0)
        
        add_divider()
        
        # Made by
        add_text("made by Kiwicat(@kiwwwicat)")
        
        add_divider()
        
        # Used Tools
        add_text("Used Tools")
        add_text("Claude")
        add_text("Gemini API")
        
        add_divider()
        
        # UI デザイン
        add_text("UI デザイン")
        add_text("Nyaha(@nyahyanyahya)")

        add_divider()

        # 日本語翻訳検収
        add_text("日本語翻訳検収")
        add_text("Haengbil(@dlobfish)")

        add_divider()

        # Special Thanks
        add_text("Special Thanks to")
        add_text("Gwansick(@GWAN5ICK)")

        add_divider()

        # Contact
        add_text("Contact")
        add_text("Twitter(X): @kiwwwicat")
        add_text("Email: kiwwwicat@naver.com")
        
        add_divider()

        # License & Copyright
        add_text("License: GNU GPL v3")
        add_text("© 2026 Kiwicat.", margin_bottom=15)

        # 下部 画像 (kiwicat_kiwipet.svg) - 36x36
        kiwicat1_svg = '''<svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13 5H12V6H13V5Z" fill="#349971"/>
<path d="M24 5H23V6H24V5Z" fill="#349971"/>
<path d="M12 6H11V7H12V6Z" fill="#349971"/>
<path d="M13 6H12V7H13V6Z" fill="#9DD4BA"/>
<path d="M14 6H13V7H14V6Z" fill="#349971"/>
<path d="M23 6H22V7H23V6Z" fill="#349971"/>
<path d="M24 6H23V7H24V6Z" fill="#9DD4BA"/>
<path d="M25 6H24V7H25V6Z" fill="#349971"/>
<path d="M11 7H10V9H11V7Z" fill="#349971"/>
<path d="M12 7H11V8H12V7Z" fill="#9DD4BA"/>
<path d="M13 7H12V8H13V7Z" fill="#E3EBE2"/>
<path d="M14 7H13V8H14V7Z" fill="#9DD4BA"/>
<path d="M15 7H14V8H15V7Z" fill="#349971"/>
<path d="M22 7H21V8H22V7Z" fill="#349971"/>
<path d="M23 7H22V8H23V7Z" fill="#9DD4BA"/>
<path d="M24 7H23V8H24V7Z" fill="#E3EBE2"/>
<path d="M25 7H24V8H25V7Z" fill="#9DD4BA"/>
<path d="M26 7H25V9H26V7Z" fill="#349971"/>
<path d="M15 8H11V9H15V8Z" fill="#1C8C7F"/>
<path d="M21 8H15V9H21V8Z" fill="#349971"/>
<path d="M25 8H21V9H25V8Z" fill="#1C8C7F"/>
<path d="M10 9H9V10H10V9Z" fill="#349971"/>
<path d="M26 9H10V15H26V9Z" fill="#9DD4BA"/>
<path d="M27 9H26V10H27V9Z" fill="#349971"/>
<path d="M9 10H8V11H9V10Z" fill="#349971"/>
<path d="M10 10H9V16H10V10Z" fill="#9DD4BA"/>
<path d="M27 10H26V16H27V10Z" fill="#9DD4BA"/>
<path d="M28 10H27V11H28V10Z" fill="#349971"/>
<path d="M8 11H7V12H8V11Z" fill="#349971"/>
<path d="M9 11H8V26H9V11Z" fill="#9DD4BA"/>
<path d="M28 11H27V26H28V11Z" fill="#9DD4BA"/>
<path d="M29 11H28V12H29V11Z" fill="#349971"/>
<path d="M7 12H6V14H7V12Z" fill="#349971"/>
<path d="M8 12H7V25H8V12Z" fill="#9DD4BA"/>
<path d="M29 12H28V25H29V12Z" fill="#9DD4BA"/>
<path d="M30 12H29V14H30V12Z" fill="#349971"/>
<path d="M6 14H5V24H6V14Z" fill="#349971"/>
<path d="M7 14H6V24H7V14Z" fill="#9DD4BA"/>
<path d="M30 14H29V24H30V14Z" fill="#9DD4BA"/>
<path d="M31 14H30V24H31V14Z" fill="#349971"/>
<path d="M13 15H10V16H13V15Z" fill="#9DD4BA"/>
<path d="M14 15H13V16H14V15Z" fill="#14655B"/>
<path d="M22 15H14V17H22V15Z" fill="#9DD4BA"/>
<path d="M23 15H22V16H23V15Z" fill="#14655B"/>
<path d="M26 15H23V16H26V15Z" fill="#9DD4BA"/>
<path d="M11 16H9V17H11V16Z" fill="#1C8C7F"/>
<path d="M14 16H11V25H14V16Z" fill="#9DD4BA"/>
<path d="M25 16H22V25H25V16Z" fill="#9DD4BA"/>
<path d="M27 16H25V17H27V17Z" fill="#1C8C7F"/>
<path d="M11 17H9V27H11V17Z" fill="#9DD4BA"/>
<path d="M17 17H14V18H17V17Z" fill="#9DD4BA"/>
<path d="M19 17H17V18H19V17Z" fill="#14655B"/>
<path d="M22 17H19V18H22V17Z" fill="#9DD4BA"/>
<path d="M27 17H25V27H27V17Z" fill="#9DD4BA"/>
<path d="M15 18H14V24H15V18Z" fill="#9DD4BA"/>
<path d="M17 18H15V19H17V18Z" fill="#14655B"/>
<path d="M19 18H17V24H19V18Z" fill="#9DD4BA"/>
<path d="M21 18H19V19H21V18Z" fill="#14655B"/>
<path d="M22 18H21V24H22V18Z" fill="#9DD4BA"/>
<path d="M17 19H15V24H17V19Z" fill="#9DD4BA"/>
<path d="M21 19H19V24H21V19Z" fill="#9DD4BA"/>
<path d="M7 24H6V25H7V24Z" fill="#349971"/>
<path d="M22 24H14V29H22V24Z" fill="#E3EBE2"/>
<path d="M30 24H29V25H30V24Z" fill="#349971"/>
<path d="M8 25H7V26H8V25Z" fill="#349971"/>
<path d="M12 25H11V26H12V25Z" fill="#9DD4BA"/>
<path d="M14 25H12V28H14V25Z" fill="#E3EBE2"/>
<path d="M24 25H22V28H24V25Z" fill="#E3EBE2"/>
<path d="M25 25H24V26H25V25Z" fill="#9DD4BA"/>
<path d="M29 25H28V26H29V25Z" fill="#349971"/>
<path d="M9 26H8V27H9V26Z" fill="#349971"/>
<path d="M12 26H11V28H12V26Z" fill="#E3EBE2"/>
<path d="M25 26H24V28H25V26Z" fill="#E3EBE2"/>
<path d="M28 26H27V27H28V26Z" fill="#349971"/>
<path d="M11 27H9V28H11V27Z" fill="#349971"/>
<path d="M27 27H25V28H27V27Z" fill="#349971"/>
<path d="M13 28H11V29H13V28Z" fill="#349971"/>
<path d="M14 28H13V29H14V28Z" fill="#E3EBE2"/>
<path d="M23 28H22V29H23V28Z" fill="#E3EBE2"/>
<path d="M25 28H23V29H25V28Z" fill="#349971"/>
<path d="M23 29H13V30H23V29Z" fill="#349971"/>
</svg>'''
        
        footer_renderer = QSvgRenderer(kiwicat1_svg.encode('utf-8'))
        if footer_renderer.isValid():
            footer_pixmap = QPixmap(36, 36)
            footer_pixmap.fill(Qt.transparent)
            painter = QPainter(footer_pixmap)
            footer_renderer.render(painter)
            painter.end()
            
            footer_label = QLabel()
            footer_label.setPixmap(footer_pixmap)
            footer_label.setAlignment(Qt.AlignCenter)
            footer_label.setStyleSheet("background: transparent; border: none;")
            layout.addWidget(footer_label)
        
        # ダイアログ レイアウト
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()
    
    def dragEnterEvent(self, event):
        """ドラッグ 進入 イベント - 画像 ファイルのみ 許可"""
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                file_path = url.toLocalFile()
                if file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                    event.acceptProposedAction()
                    return
        event.ignore()
    
    def dropEvent(self, event):
        """ドロップ イベント - 画像 ファイルで キャラクター 追加"""
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                # キャラクター 追加
                self.add_character_from_path(file_path)
                event.acceptProposedAction()
                return
        event.ignore()
    
    def add_character_from_path(self, file_path):
        """ファイル パスで キャラクター 追加 (ドラッグ アンド ドロップ用)"""
        try:
            # 方向選択ダイアログ
            direction_dialog = DirectionDialog(self)
            if direction_dialog.exec_() != QDialog.Accepted:
                return
            direction = direction_dialog.get_direction()
            
            # 空の キャラクター 番号 探す
            used_ids = set(self.character_data.keys())
            new_char_id = self.char_id_counter
            for i in range(self.char_id_counter):
                if i not in used_ids:
                    new_char_id = i
                    break
            
            # キャラクター ウィジェット 生成
            char_widget = CharacterWidget(file_path, new_char_id, direction, 100, '#A8D5BA', 100)
            self.characters.append(char_widget)
            
            # キャラクター データ 保存
            self.character_data[new_char_id] = {
                'name': f'キャラクター {new_char_id + 1}',
                'scale': 100,
                'bubble_color': '#A8D5BA',
                'bubble_size': 100,
                'facing_direction': direction,
                'image_path': file_path,
                'is_active': True,
                'personality': '',
                'nicknames': {},
                'stories': {},
                'background_story': '',
                'sample_dialogues': [],
                'catchphrase': '',
                'ai_auto_generate': True  # AI 自動生成 デフォルト
            }
            
            # セリフリセット
            if new_char_id not in self.dialogues:
                self.dialogues[new_char_id] = {'基本': []}
            char_widget.dialogues = self.dialogues.get(new_char_id, {'基本': []})
            
            # カード 生成
            card = CharacterCard(new_char_id, file_path, is_active=True)
            card.remove_clicked.connect(self.remove_character)
            card.change_image_clicked.connect(self.change_character_image)
            card.change_scale_clicked.connect(self.change_character_scale)
            card.change_bubble_color_clicked.connect(self.change_bubble_color)
            card.change_relationships_clicked.connect(self.change_relationships)
            card.change_dialogues_clicked.connect(self.change_dialogues)
            card.change_personality_clicked.connect(self.change_personality)
            card.name_changed.connect(self.update_character_name)
            card.catchphrase_changed.connect(self.update_character_catchphrase)
            card.toggle_active.connect(self.toggle_character_active)
            card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
            
            self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
            
            # char_id_counter アップデート
            if new_char_id >= self.char_id_counter:
                self.char_id_counter = new_char_id + 1
            
            # 保存
            self.save_characters()
            
            print(f"[ドラッグアンドドロップ] キャラクター {new_char_id} 追加される: {file_path}")
            QMessageBox.information(self, "成功", "キャラクターが追加されました！")
            
        except Exception as e:
            print(f"[エラー] キャラクター 追加 失敗: {e}")
            import traceback
            traceback.print_exc()
    
    def closeEvent(self, event):
        # 復元 後には 保存しな ない (復元された ファイル 保護)
        if not getattr(self, '_skip_save_on_close', False):
            self.save_characters()
        self.collision_timer.stop()
        for char in self.characters:
            char.close()
        event.accept()


def main():
    app = QApplication(sys.argv)
    app.setApplicationName("Kiwipet")
    
    # Pretendard フォント 読み込み 試行
    pretendard_loaded = load_pretendard_font()
    
    if pretendard_loaded:
        # Pretendard フォント 使用 (DemiBold weight)
        font = QFont('Pretendard JP', 10)
        font.setWeight(QFont.Bold)  # 700
        print(f"[フォント] Pretendard Bold 適用")
    else:
        # Fallback: システム フォント
        if platform.system() == 'Darwin':
            font = QFont("Apple SD Gothic Neo", 10)
        else:
            font = QFont("Meiryo", 10)
        print("[フォント] システム フォント 使用")
    
    app.setFont(font)
    
    # アプリ アイコン 設定 (すべての ウィンドウに 適用)
    app_icon = load_app_icon()
    if app_icon:
        app.setWindowIcon(app_icon)
    
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec_())



def load_app_icon():
    """アプリ アイコン 読み込み (kiwipet_6 SVG 内蔵)"""
    try:
        from PyQt5.QtSvg import QSvgRenderer
        
        # kiwipet_6 SVG (内蔵)
        kiwipet_svg = '''<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 7H11V8H13V7H14V6H18V7H19V8H20V13H19V14H18V15H17V16H16V17H15V18H14V19H13V20H11V19H10V18H9V17H8V16H7V15H6V14H5V13H4V8H5V7H6V6H10V7Z" fill="#D5E8DF"/>
<path d="M13 20V21H11V20H13Z" fill="#9DD4BA"/>
<path d="M11 20H10V19H11V20Z" fill="#9DD4BA"/>
<path d="M14 20H13V19H14V20Z" fill="#9DD4BA"/>
<path d="M10 19H9V18H10V19Z" fill="#9DD4BA"/>
<path d="M15 19H14V18H15V19Z" fill="#9DD4BA"/>
<path d="M9 18H8V17H9V18Z" fill="#9DD4BA"/>
<path d="M16 18H15V17H16V18Z" fill="#9DD4BA"/>
<path d="M8 17H7V16H8V17Z" fill="#9DD4BA"/>
<path d="M17 17H16V16H17V17Z" fill="#9DD4BA"/>
<path d="M7 16H6V15H7V16Z" fill="#9DD4BA"/>
<path d="M18 16H17V15H18V16Z" fill="#9DD4BA"/>
<path d="M6 15H5V14H6V15Z" fill="#9DD4BA"/>
<path d="M19 15H18V14H19V15Z" fill="#9DD4BA"/>
<path d="M5 14H4V13H5V14Z" fill="#9DD4BA"/>
<path d="M20 14H19V13H20V14Z" fill="#9DD4BA"/>
<path d="M4 13H3V8H4V13Z" fill="#9DD4BA"/>
<path d="M21 13H20V8H21V13Z" fill="#9DD4BA"/>
<path d="M5 8H4V7H5V8Z" fill="#9DD4BA"/>
<path d="M13 8H11V7H13V8Z" fill="#9DD4BA"/>
<path d="M20 8H19V7H20V8Z" fill="#9DD4BA"/>
<path d="M6 7H5V6H6V7Z" fill="#9DD4BA"/>
<path d="M11 7H10V6H11V7Z" fill="#9DD4BA"/>
<path d="M14 7H13V6H14V7Z" fill="#9DD4BA"/>
<path d="M19 7H18V6H19V7Z" fill="#9DD4BA"/>
<path d="M10 6H6V5H10V6Z" fill="#9DD4BA"/>
<path d="M18 6H14V5H18V6Z" fill="#9DD4BA"/>
<path d="M13 13H14V14H10V13H11V12H13V13Z" fill="#63BA91"/>
<path d="M9 12H8V10H9V12Z" fill="#63BA91"/>
<path d="M15 10H16V12H15V10Z" fill="#63BA91"/>
</svg>'''
        
        icon = QIcon()
        
        # SVG レンダラー 生成
        renderer = QSvgRenderer(kiwipet_svg.encode('utf-8'))
        
        if renderer.isValid():
            # 複数の サイズで レンダリング
            for size in [16, 24, 32, 48, 64, 128, 256]:
                pixmap = QPixmap(size, size)
                pixmap.fill(QColor(0, 0, 0, 0))  # 透明 背景
                
                painter = QPainter(pixmap)
                renderer.render(painter)
                painter.end()
                
                icon.addPixmap(pixmap)
            
            print("[アプリ アイコン] kiwipet_6 SVG 読み込み成功")
            return icon
        else:
            print("[アプリ アイコン] SVG レンダリング 失敗, 基本 アイコン 使用")
            return create_default_app_icon()
        
    except Exception as e:
        print(f"[アプリ アイコン エラー] {e}")
        return create_default_app_icon()


def create_settings_icon(size=24, color="#8ECFB5"):
    """歯車 設定 アイコン 生成 (SVG ベース)"""
    try:
        # SVG テンプレート (色のみ 変更 可能)
        svg_template = '''<svg width="140" height="140" viewBox="0 0 140 140" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M50.7958 139.167L48.0125 116.9C46.5049 116.32 45.0854 115.624 43.754 114.813C42.4226 114.001 41.1168 113.131 39.8365 112.203L19.1354 120.901L0 87.849L17.9177 74.2802C17.8017 73.4684 17.7438 72.6868 17.7438 71.9353V67.2384C17.7438 66.4822 17.8017 65.6983 17.9177 64.8865L0 51.3177L19.1354 18.2656L39.8365 26.9635C41.1122 26.0358 42.4458 25.166 43.8375 24.3542C45.2292 23.5424 46.6208 22.8465 48.0125 22.2667L50.7958 0H89.0667L91.85 22.2667C93.3576 22.8465 94.7795 23.5424 96.1155 24.3542C97.4515 25.166 98.755 26.0358 100.026 26.9635L120.727 18.2656L139.862 51.3177L121.945 64.8865C122.061 65.6983 122.119 66.4822 122.119 67.2384V71.9283C122.119 72.6844 122.003 73.4684 121.771 74.2802L139.689 87.849L120.553 120.901L100.026 112.203C98.7504 113.131 97.4167 114.001 96.025 114.813C94.6333 115.624 93.2417 116.32 91.85 116.9L89.0667 139.167H50.7958ZM70.2792 93.9375C77.0056 93.9375 82.7462 91.5601 87.501 86.8052C92.2559 82.0504 94.6333 76.3097 94.6333 69.5833C94.6333 62.8569 92.2559 57.1163 87.501 52.3615C82.7462 47.6066 77.0056 45.2292 70.2792 45.2292C63.4368 45.2292 57.666 47.6066 52.9668 52.3615C48.2676 57.1163 45.9204 62.8569 45.925 69.5833C45.9296 76.3097 48.2792 82.0504 52.9738 86.8052C57.6683 91.5601 63.4368 93.9375 70.2792 93.9375Z" fill="{color}"/>
</svg>'''
        
        svg_data = svg_template.format(color=color)
        
        # SVGを QPixmapとして 変換
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.transparent)
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)
        renderer.render(painter)
        painter.end()
        
        return QIcon(pixmap)
    except Exception as e:
        print(f"[設定 アイコン] SVG レンダリング 失敗, fallback 使用: {e}")
        # Fallback: 簡単な 歯車 描画
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.transparent)
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        pen = QPen(QColor(color))
        pen.setWidth(max(2, size // 10))
        pen.setCapStyle(Qt.RoundCap)
        painter.setPen(pen)
        painter.setBrush(Qt.NoBrush)
        
        center = size / 2
        outer_r = size * 0.4
        inner_r = size * 0.25
        
        # 中央 円
        painter.drawEllipse(QPointF(center, center), inner_r * 0.6, inner_r * 0.6)
        # 外側 円
        painter.drawEllipse(QPointF(center, center), outer_r * 0.7, outer_r * 0.7)
        # 歯車の歯 8個
        for i in range(8):
            angle = (i * 360 / 8) - 90
            rad = math.radians(angle)
            x1 = center + outer_r * math.cos(rad)
            y1 = center + outer_r * math.sin(rad)
            x2 = center + inner_r * math.cos(rad)
            y2 = center + inner_r * math.sin(rad)
            painter.drawLine(QPointF(x1, y1), QPointF(x2, y2))
        
        painter.end()
        return QIcon(pixmap)


def create_default_app_icon():
    """基本 アプリ アイコン 生成 - ハート 形 (SVG 失敗 時 fallback)"""
    try:
        icon = QIcon()
        
        # 複数の サイズで アイコン 生成
        for size in [16, 24, 32, 48, 64, 128]:
            pixmap = QPixmap(size, size)
            pixmap.fill(QColor(0, 0, 0, 0))  # 完全 透明 背景
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # スケール 計算
            scale = size / 25.0
            
            # ハート 形 描画 (ミント色)
            path = QPainterPath()
            # ハート 曲線
            cx, cy = 12.5 * scale, 10 * scale
            path.moveTo(cx, cy + 3 * scale)
            # 左 半円
            path.cubicTo(cx - 6 * scale, cy - 3 * scale, 
                        cx - 10 * scale, cy + 5 * scale,
                        cx, cy + 12 * scale)
            # 右 半円
            path.cubicTo(cx + 10 * scale, cy + 5 * scale,
                        cx + 6 * scale, cy - 3 * scale,
                        cx, cy + 3 * scale)
            
            painter.setBrush(QColor("#AAC9B8"))
            painter.setPen(Qt.NoPen)
            painter.drawPath(path)
            
            painter.end()
            icon.addPixmap(pixmap)
        
        return icon
    except Exception as e:
        print(f"[基本 アイコン 生成 エラー] {e}")
        return None


if __name__ == '__main__':
    main()
