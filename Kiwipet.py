import sys
import os
import random
import math
import base64
import json
import time

# ============ NEW UI SVG ICONS ============
# Placeholder 이미지 (이미지 없는 캐릭터용)
PLACEHOLDER_SVG = '''<svg width="808" height="808" viewBox="0 0 808 808" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M336.667 235.667H370.334V269.333H437.667V235.667H471.334V202H606V235.667H639.667V269.333H673.334V437.667H639.667V471.333H606V505H572.334V538.667H538.667V572.333H505V606H471.334V639.667H437.667V673.333H370.334V639.667H336.667V606H303V572.333H269.334V538.667H235.667V505H202V471.333H168.334V437.667H134.667V269.333H168.334V235.667H202V202H336.667V235.667Z" fill="#D5E8DF"/>
<path d="M437.667 673.333V707H370.333V673.333H437.667Z" fill="#9DD4BA"/>
<path d="M370.333 673.333H336.667V639.666H370.333V673.333Z" fill="#9DD4BA"/>
<path d="M471.333 673.333H437.667V639.666H471.333V673.333Z" fill="#9DD4BA"/>
<path d="M336.667 639.666H303V606H336.667V639.666Z" fill="#9DD4BA"/>
<path d="M505 639.666H471.333V606H505V639.666Z" fill="#9DD4BA"/>
<path d="M303 606H269.333V572.333H303V606Z" fill="#9DD4BA"/>
<path d="M538.667 606H505V572.333H538.667V606Z" fill="#9DD4BA"/>
<path d="M269.333 572.333H235.667V538.666H269.333V572.333Z" fill="#9DD4BA"/>
<path d="M572.333 572.333H538.667V538.666H572.333V572.333Z" fill="#9DD4BA"/>
<path d="M235.667 538.666H202V505H235.667V538.666Z" fill="#9DD4BA"/>
<path d="M606 538.666H572.333V505H606V538.666Z" fill="#9DD4BA"/>
<path d="M202 505H168.333V471.333H202V505Z" fill="#9DD4BA"/>
<path d="M639.667 505H606V471.333H639.667V505Z" fill="#9DD4BA"/>
<path d="M168.333 471.333H134.667V437.666H168.333V471.333Z" fill="#9DD4BA"/>
<path d="M673.333 471.333H639.667V437.666H673.333V471.333Z" fill="#9DD4BA"/>
<path d="M134.667 437.666H101V269.333H134.667V437.666Z" fill="#9DD4BA"/>
<path d="M707 437.666H673.333V269.333H707V437.666Z" fill="#9DD4BA"/>
<path d="M168.333 269.333H134.667V235.666H168.333V269.333Z" fill="#9DD4BA"/>
<path d="M437.667 269.333H370.333V235.666H437.667V269.333Z" fill="#9DD4BA"/>
<path d="M673.333 269.333H639.667V235.666H673.333V269.333Z" fill="#9DD4BA"/>
<path d="M202 235.666H168.333V202H202V235.666Z" fill="#9DD4BA"/>
<path d="M370.333 235.666H336.667V202H370.333V235.666Z" fill="#9DD4BA"/>
<path d="M471.333 235.666H437.667V202H471.333V235.666Z" fill="#9DD4BA"/>
<path d="M639.667 235.666H606V202H639.667V235.666Z" fill="#9DD4BA"/>
<path d="M336.667 202H202V168.333H336.667V202Z" fill="#9DD4BA"/>
<path d="M606 202H471.333V168.333H606V202Z" fill="#9DD4BA"/>
<path d="M437.666 437.667H471.333V471.334H336.666V437.667H370.333V404H437.666V437.667Z" fill="#63BA91"/>
<path d="M303 404H269.333V336.667H303V404Z" fill="#63BA91"/>
<path d="M505 336.667H538.666V404H505V336.667Z" fill="#63BA91"/>
</svg>'''

# i 버튼 (크레딧)
SVG_INFO = '''<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 7H11V8H13V7H14V6H18V7H19V8H20V13H19V14H18V15H17V16H16V17H15V18H14V19H13V20H11V19H10V18H9V17H8V16H7V15H6V14H5V13H4V8H5V7H6V6H10V7Z" fill="#D5E8DF"/>
<path d="M13 20V21H11V20H13Z" fill="#9DD4BA"/>
<path d="M11 20H10V19H11V20Z" fill="#9DD4BA"/>
<path d="M14 20H13V19H14V20Z" fill="#9DD4BA"/>
<path d="M10 19H9V18H10V19Z" fill="#9DD4BA"/>
<path d="M15 19H14V18H15V19Z" fill="#9DD4BA"/>
<path d="M9 18H8V17H9V18Z" fill="#9DD4BA"/>
<path d="M16 18H15V17H16V18Z" fill="#9DD4BA"/>
<path d="M8 17H7V16H8V17Z" fill="#9DD4BA"/>
<path d="M17 17H16V16H17V17Z" fill="#9DD4BA"/>
<path d="M7 16H6V15H7V16Z" fill="#9DD4BA"/>
<path d="M18 16H17V15H18V16Z" fill="#9DD4BA"/>
<path d="M6 15H5V14H6V15Z" fill="#9DD4BA"/>
<path d="M19 15H18V14H19V15Z" fill="#9DD4BA"/>
<path d="M5 14H4V13H5V14Z" fill="#9DD4BA"/>
<path d="M20 14H19V13H20V14Z" fill="#9DD4BA"/>
<path d="M4 13H3V8H4V13Z" fill="#9DD4BA"/>
<path d="M21 13H20V8H21V13Z" fill="#9DD4BA"/>
<path d="M5 8H4V7H5V8Z" fill="#9DD4BA"/>
<path d="M13 8H11V7H13V8Z" fill="#9DD4BA"/>
<path d="M20 8H19V7H20V8Z" fill="#9DD4BA"/>
<path d="M6 7H5V6H6V7Z" fill="#9DD4BA"/>
<path d="M11 7H10V6H11V7Z" fill="#9DD4BA"/>
<path d="M14 7H13V6H14V7Z" fill="#9DD4BA"/>
<path d="M19 7H18V6H19V7Z" fill="#9DD4BA"/>
<path d="M10 6H6V5H10V6Z" fill="#9DD4BA"/>
<path d="M18 6H14V5H18V6Z" fill="#9DD4BA"/>
<path d="M13 13H14V14H10V13H11V12H13V13Z" fill="#63BA91"/>
<path d="M9 12H8V10H9V12Z" fill="#63BA91"/>
<path d="M15 10H16V12H15V10Z" fill="#63BA91"/>
</svg>'''

# ? 버튼 (튜토리얼)
SVG_QUESTION = '''<svg width="8" height="14" viewBox="0 0 8 14" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.81638 3.73947C5.81638 3.2114 5.63454 2.78772 5.27086 2.46842C4.90718 2.14912 4.425 1.98947 3.82432 1.98947C3.45399 1.98947 3.11892 2.06635 2.81909 2.2201C2.51925 2.37386 2.26054 2.59786 2.04295 2.8921C1.83863 3.17456 1.56076 3.3374 1.20934 3.38063C0.857919 3.42385 0.554767 3.3347 0.299885 3.11315C0.121109 2.9535 0.0222718 2.75701 0.00337267 2.52368C-0.0155264 2.29035 0.0450018 2.0693 0.184957 1.86052C0.593587 1.27105 1.11408 0.813718 1.74643 0.488526C2.37879 0.163333 3.07142 0.000491227 3.82432 0C5.06297 0 6.06871 0.337719 6.84153 1.01316C7.61435 1.68859 8.00051 2.5728 8 3.66578C8 4.21842 7.87869 4.71578 7.63606 5.15789C7.39344 5.59999 6.9465 6.12192 6.29525 6.72367C5.82277 7.1535 5.50353 7.48827 5.33752 7.72799C5.17152 7.96771 5.06297 8.24083 5.0119 8.54736C4.96082 8.84209 4.8298 9.08771 4.61884 9.2842C4.40789 9.48069 4.15582 9.57893 3.86262 9.57893C3.56943 9.57893 3.31736 9.48388 3.1064 9.29378C2.89545 9.10367 2.78997 8.86715 2.78997 8.5842C2.78997 8.10525 2.89851 7.66634 3.1156 7.26746C3.33268 6.86859 3.69662 6.44785 4.20741 6.00525C4.85866 5.45262 5.28976 5.02599 5.50072 4.72536C5.71167 4.42473 5.8169 4.0961 5.81638 3.73947ZM3.82432 14C3.40292 14 3.0423 13.8558 2.74247 13.5675C2.44264 13.2791 2.29246 12.9321 2.29195 12.5263C2.29144 12.1205 2.44161 11.7737 2.74247 11.4859C3.04332 11.198 3.40394 11.0536 3.82432 11.0526C4.24469 11.0516 4.60556 11.1961 4.90693 11.4859C5.20829 11.7757 5.35821 12.1225 5.35668 12.5263C5.35514 12.9301 5.20523 13.2771 4.90693 13.5675C4.60863 13.8578 4.24776 14.0019 3.82432 14Z" fill="#317C75"/>
</svg>'''

# Kiwipet 타이틀 로고 SVG
SVG_KIWIPET_TITLE = '''<svg width="150" height="76" viewBox="0 0 150 76" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M46.6403 43.9567C47.0397 43.9567 47.347 44.1411 47.5621 44.5098C47.8079 44.8785 47.9308 45.3854 47.9308 46.0306C47.9308 47.2289 47.6389 48.1814 47.0551 48.8881C45.5803 50.6701 44.0901 52.0527 42.5846 53.0359C41.0791 53.9884 39.2971 54.4646 37.2385 54.4646C34.9649 54.4646 33.106 53.804 31.6619 52.4829C30.2179 51.131 28.866 49.0417 27.6063 46.215C26.6845 44.1872 25.9164 42.6816 25.3019 41.6984C24.7181 40.6845 24.1344 39.9779 23.5506 39.5784C22.9668 39.1483 22.2294 38.8871 21.3384 38.7949L20.8314 42.2054C20.1862 46.5991 18.9265 49.7637 17.0523 51.6994C15.2088 53.635 12.6586 54.6029 9.4018 54.6029C7.28179 54.6029 5.39221 54.0959 3.73307 53.082C2.10465 52.0374 0.967833 50.7162 0.322611 49.1185C0.107537 48.5654 0 47.9663 0 47.3211C0 46.3993 0.215074 45.6005 0.645222 44.9246C1.07537 44.2486 1.62842 43.9106 2.30436 43.9106C2.70379 43.9106 3.04176 44.0182 3.31828 44.2332C3.59481 44.4176 3.85597 44.7556 4.10177 45.2472C5.05424 47.0292 5.88381 48.2736 6.59048 48.9802C7.32787 49.6869 8.23426 50.0402 9.30963 50.0402C10.5386 50.0402 11.5833 49.4872 12.4436 48.3811C13.3346 47.2443 13.9644 45.5083 14.3331 43.1732L14.9784 38.7949H14.241C13.5343 38.7949 12.9812 38.5952 12.5818 38.1958C12.1824 37.7964 11.9827 37.2433 11.9827 36.5367C11.9827 35.7378 12.1824 35.108 12.5818 34.6471C13.012 34.1555 13.5343 33.9097 14.1488 33.9097H15.6697C15.8847 32.4042 16.0384 31.3595 16.1305 30.7758L17.5592 20.4061C16.7604 20.314 16.0076 20.2679 15.301 20.2679C12.6894 20.2679 10.7076 20.7287 9.35571 21.6505C8.00382 22.5415 7.32787 23.8319 7.32787 25.5218C7.32787 26.2899 7.40469 26.9198 7.55831 27.4114C7.74266 27.8723 7.9731 28.3946 8.24962 28.9784C8.37252 29.2242 8.43397 29.5007 8.43397 29.8079C8.43397 30.4839 8.11136 31.083 7.46614 31.6053C6.85164 32.0969 6.16033 32.3427 5.39221 32.3427C4.40902 32.3427 3.68698 31.9126 3.22611 31.0523C2.30436 29.4239 1.84349 27.6726 1.84349 25.7983C1.84349 23.8627 2.36581 22.096 3.41046 20.4983C4.48583 18.9006 6.09888 17.6255 8.24962 16.6731C10.4004 15.6899 13.0581 15.1983 16.2227 15.1983C17.6053 15.1983 18.8651 15.2751 20.0019 15.4287C21.1694 15.5823 22.4445 15.8742 23.8271 16.3044C25.3326 16.7652 26.0854 17.6255 26.0854 18.8853C26.0854 20.5751 25.3634 21.42 23.9193 21.42L22.1219 33.8175C25.7167 33.4488 28.6356 31.9126 30.8785 29.2088C33.1521 26.4743 35.0417 22.7719 36.5472 18.1018C36.8237 17.2415 37.2846 16.5809 37.9298 16.12C38.6058 15.6591 39.4507 15.4287 40.4646 15.4287C41.3249 15.4287 41.9855 15.6284 42.4464 16.0278C42.938 16.3965 43.1838 16.9342 43.1838 17.6409C43.1838 17.856 43.1223 18.2093 42.9994 18.7009C41.4632 23.7705 39.2663 27.7955 36.4089 30.7758C33.5515 33.7561 30.433 35.7378 27.0532 36.721C28.2208 36.9975 29.1732 37.4123 29.9106 37.9654C30.6788 38.5184 31.324 39.2097 31.8463 40.0393C32.3686 40.8381 32.9678 41.9596 33.6437 43.4037C34.5962 45.4315 35.4872 46.8756 36.3168 47.7359C37.1463 48.5654 38.1142 48.9802 39.2203 48.9802C40.2035 48.9802 41.1406 48.6576 42.0316 48.0124C42.9226 47.3365 44.0441 46.1996 45.396 44.6019C45.7646 44.1718 46.1794 43.9567 46.6403 43.9567Z" fill="#4FB98F"/>
<path d="M48.8305 29.7158C47.5401 29.7158 46.5723 29.4239 45.927 28.8401C45.2818 28.2256 44.9592 27.3807 44.9592 26.3053C44.9592 25.2299 45.374 24.3389 46.2036 23.6322C47.0639 22.8948 48.1239 22.5261 49.3836 22.5261C50.5204 22.5261 51.4421 22.8027 52.1488 23.3557C52.8555 23.9088 53.2088 24.6922 53.2088 25.7062C53.2088 26.9352 52.8094 27.9184 52.0106 28.6558C51.2117 29.3624 50.1517 29.7158 48.8305 29.7158ZM48.4618 54.4646C46.4647 54.4646 45.0053 53.7579 44.0835 52.3446C43.1925 50.9313 42.747 49.057 42.747 46.722C42.747 45.3393 42.916 43.5727 43.254 41.4219C43.6227 39.2405 44.0835 37.2126 44.6366 35.3384C44.9131 34.3552 45.2818 33.6793 45.7427 33.3106C46.2036 32.9419 46.941 32.7575 47.9549 32.7575C49.5218 32.7575 50.3053 33.2798 50.3053 34.3245C50.3053 35.0926 50.0134 36.8746 49.4297 39.6706C48.6923 43.0503 48.3236 45.3393 48.3236 46.5376C48.3236 47.4594 48.4465 48.166 48.6923 48.6576C48.9381 49.1492 49.3529 49.395 49.9366 49.395C50.4897 49.395 51.181 49.011 52.0106 48.2428C52.8401 47.4747 53.9462 46.2611 55.3288 44.6019C55.6975 44.1718 56.1123 43.9567 56.5732 43.9567C56.9726 43.9567 57.2799 44.1411 57.4949 44.5098C57.7407 44.8785 57.8636 45.3854 57.8636 46.0306C57.8636 47.2596 57.5718 48.2121 56.988 48.8881C53.9462 52.6058 51.1042 54.4646 48.4618 54.4646Z" fill="#4FB98F"/>
<path d="M87.5834 40.2237C87.6756 40.1929 87.8292 40.1776 88.0443 40.1776C88.5052 40.1776 88.8585 40.3312 89.1043 40.6384C89.3501 40.9457 89.473 41.3605 89.473 41.8828C89.473 42.8353 89.2887 43.588 88.92 44.1411C88.5513 44.6634 87.9982 45.0475 87.2608 45.2932C85.8475 45.7541 84.342 45.9846 82.7443 45.9846C81.3924 45.9846 80.1173 45.8002 78.919 45.4315C78.028 46.8756 77.0448 48.3657 75.9694 49.902C74.7404 51.6533 73.6805 52.8516 72.7894 53.4968C71.9291 54.142 70.9459 54.4646 69.8398 54.4646C68.6108 54.4646 67.6737 53.9884 67.0285 53.0359C66.414 52.0834 66.03 50.5165 65.8763 48.335L65.6459 44.9706C64.6934 47.5515 63.8331 49.5179 63.065 50.8698C62.3276 52.2217 61.5749 53.1588 60.8067 53.6811C60.0693 54.2035 59.1937 54.4646 58.1798 54.4646C56.92 54.4646 55.9215 53.973 55.1841 52.9898C54.4774 52.0066 54.0319 50.455 53.8476 48.335C53.4789 44.0335 53.2945 40.2697 53.2945 37.0436V35.4306C53.3252 34.4167 53.6018 33.71 54.1241 33.3106C54.6464 32.9111 55.4299 32.7114 56.4745 32.7114C57.2734 32.7114 57.8572 32.8958 58.2259 33.2645C58.6253 33.6024 58.825 34.1862 58.825 35.0158C58.825 38.5491 59.0401 43.1425 59.4702 48.7959C61.5595 44.4022 63.4798 39.8242 65.2311 35.0619C65.5691 34.1401 65.9685 33.5256 66.4294 33.2184C66.921 32.8804 67.5048 32.7114 68.1807 32.7114C69.0103 32.7114 69.5787 32.8804 69.8859 33.2184C70.2239 33.5564 70.3929 34.1555 70.3929 35.0158C70.3929 38.5491 70.608 43.1425 71.0381 48.7959C72.8816 46.0614 74.2642 43.8799 75.186 42.2515C74.7251 41.3605 74.4947 40.3005 74.4947 39.0715C74.4947 38.0268 74.7251 37.0129 75.186 36.0297C75.6468 35.0465 76.2767 34.2477 77.0755 33.6332C77.8744 33.0187 78.7808 32.7114 79.7947 32.7114C80.6857 32.7114 81.4077 33.034 81.9608 33.6793C82.5138 34.2938 82.7904 35.2001 82.7904 36.3984C82.7904 37.781 82.4217 39.3634 81.6843 41.1454C82.8518 41.0839 84.4034 40.8535 86.3391 40.4541L87.5834 40.2237Z" fill="#4FB98F"/>
<path d="M90.1272 29.7158C88.8368 29.7158 87.869 29.4239 87.2237 28.8401C86.5785 28.2256 86.2559 27.3807 86.2559 26.3053C86.2559 25.2299 86.6707 24.3389 87.5003 23.6322C88.3606 22.8948 89.4206 22.5261 90.6803 22.5261C91.8171 22.5261 92.7389 22.8027 93.4455 23.3557C94.1522 23.9088 94.5055 24.6922 94.5055 25.7062C94.5055 26.9352 94.1061 27.9184 93.3073 28.6558C92.5084 29.3624 91.4484 29.7158 90.1272 29.7158ZM89.7585 54.4646C87.7614 54.4646 86.302 53.7579 85.3802 52.3446C84.4892 50.9313 84.0437 49.057 84.0437 46.722C84.0437 45.3393 84.2127 43.5727 84.5507 41.4219C84.9194 39.2405 85.3803 37.2126 85.9333 35.3384C86.2098 34.3552 86.5785 33.6793 87.0394 33.3106C87.5003 32.9419 88.2377 32.7575 89.2516 32.7575C90.8186 32.7575 91.602 33.2798 91.602 34.3245C91.602 35.0926 91.3101 36.8746 90.7264 39.6706C89.989 43.0503 89.6203 45.3393 89.6203 46.5376C89.6203 47.4594 89.7432 48.166 89.989 48.6576C90.2348 49.1492 90.6496 49.395 91.2333 49.395C91.7864 49.395 92.4777 49.011 93.3073 48.2428C94.1368 47.4747 95.2429 46.2611 96.6255 44.6019C96.9942 44.1718 97.409 43.9567 97.8699 43.9567C98.2693 43.9567 98.5766 44.1411 98.7916 44.5098C99.0374 44.8785 99.1603 45.3854 99.1603 46.0306C99.1603 47.2596 98.8685 48.2121 98.2847 48.8881C95.2429 52.6058 92.4009 54.4646 89.7585 54.4646Z" fill="#4FB98F"/>
<path d="M118.66 43.9567C119.059 43.9567 119.366 44.1411 119.581 44.5098C119.827 44.8785 119.95 45.3854 119.95 46.0306C119.95 47.2596 119.658 48.2121 119.074 48.8881C117.753 50.5165 116.324 51.853 114.788 52.8977C113.283 53.9423 111.562 54.4646 109.626 54.4646C107.998 54.4646 106.677 53.8808 105.663 52.7133C103.912 53.8501 102.084 54.4339 100.179 54.4646C99.7792 60.3945 98.8728 65.3412 97.4594 69.3047C96.0461 73.2989 93.9722 75.2961 91.2377 75.2961C89.5785 75.2961 88.3495 74.6969 87.5507 73.4987C86.7518 72.3004 86.3524 70.6412 86.3524 68.5212C86.3524 65.5102 87.0437 61.9922 88.4263 57.9672C89.8089 53.973 91.9443 49.564 94.8325 44.7402C94.8325 40.2544 94.8017 37.1358 94.7403 35.3845C94.7096 34.4935 95.0629 33.7868 95.8003 33.2645C96.5377 32.7422 97.4594 32.481 98.5655 32.481C99.2107 32.481 99.6716 32.6193 99.9481 32.8958C100.255 33.1416 100.424 33.6485 100.455 34.4167C100.455 35.1848 100.47 35.7532 100.501 36.1219C101.484 34.8929 102.452 34.0172 103.405 33.4949C104.357 32.9419 105.371 32.6653 106.446 32.6653C108.167 32.6653 109.565 33.3566 110.64 34.7393C111.746 36.1219 112.3 37.9347 112.3 40.1776C112.3 41.806 112.038 43.3883 111.516 44.9246C110.994 46.4608 110.272 47.8588 109.35 49.1185C109.995 49.3028 110.533 49.395 110.963 49.395C111.977 49.395 112.945 49.0263 113.866 48.2889C114.788 47.5515 115.971 46.3225 117.415 44.6019C117.784 44.1718 118.199 43.9567 118.66 43.9567ZM100.409 50.0402C101.515 49.7944 102.529 49.1953 103.451 48.2428C104.403 47.2596 105.156 46.0614 105.709 44.648C106.262 43.204 106.539 41.6984 106.539 40.1315C106.539 39.2097 106.354 38.5184 105.986 38.0576C105.617 37.566 105.125 37.3202 104.511 37.3202C103.405 37.3202 102.068 38.4877 100.501 40.8228C100.47 42.1747 100.455 44.1564 100.455 46.768C100.455 48.1814 100.44 49.2721 100.409 50.0402ZM91.6063 70.7795C92.4359 70.7795 93.1272 68.9667 93.6803 65.3412C94.2333 61.7464 94.5867 57.2606 94.7403 51.8837C93.4191 54.9562 92.3745 57.8904 91.6063 60.6864C90.8382 63.4824 90.4542 65.8328 90.4542 67.7378C90.4542 68.7209 90.5771 69.4737 90.8229 69.996C91.0379 70.5183 91.2991 70.7795 91.6063 70.7795Z" fill="#4FB98F"/>
<path d="M135.41 43.9567C135.809 43.9567 136.116 44.1411 136.332 44.5098C136.577 44.8785 136.7 45.3854 136.7 46.0306C136.7 47.2596 136.408 48.2121 135.825 48.8881C134.688 50.2707 133.075 51.5458 130.985 52.7133C128.927 53.8808 126.715 54.4646 124.349 54.4646C121.123 54.4646 118.619 53.589 116.837 51.8376C115.055 50.0863 114.164 47.6898 114.164 44.648C114.164 42.528 114.609 40.5616 115.5 38.7489C116.391 36.9054 117.62 35.4459 119.187 34.3706C120.785 33.2952 122.582 32.7575 124.579 32.7575C126.361 32.7575 127.79 33.2952 128.865 34.3706C129.941 35.4152 130.478 36.8439 130.478 38.6567C130.478 40.7767 129.71 42.6048 128.174 44.1411C126.669 45.6466 124.103 46.8449 120.478 47.7359C121.246 49.1492 122.705 49.8559 124.856 49.8559C126.238 49.8559 127.805 49.3797 129.557 48.4272C131.339 47.444 132.875 46.1689 134.165 44.6019C134.534 44.1718 134.949 43.9567 135.41 43.9567ZM123.796 37.2741C122.659 37.2741 121.691 37.9347 120.892 39.2558C120.124 40.577 119.74 42.1747 119.74 44.0489V44.1411C121.553 43.7109 122.982 43.0657 124.026 42.2054C125.071 41.3451 125.593 40.3466 125.593 39.2097C125.593 38.626 125.424 38.1651 125.086 37.8271C124.779 37.4584 124.349 37.2741 123.796 37.2741Z" fill="#4FB98F"/>
<path d="M139.169 37.1358C139.108 38.672 139.077 39.8703 139.077 40.7306C139.077 42.9428 139.185 44.6788 139.4 45.9385C139.646 47.1675 140.03 48.0585 140.552 48.6115C141.105 49.1339 141.858 49.395 142.81 49.395C143.302 49.395 143.886 49.2414 144.562 48.9341C145.238 48.6269 145.852 48.2275 146.405 47.7359C146.743 47.4286 147.081 47.275 147.419 47.275C147.788 47.275 148.08 47.4901 148.295 47.9202C148.541 48.3196 148.663 48.8112 148.663 49.395C148.663 49.9788 148.541 50.5472 148.295 51.1002C148.08 51.6533 147.742 52.1142 147.281 52.4829C145.683 53.804 143.87 54.4646 141.843 54.4646C138.924 54.4646 136.788 53.251 135.436 50.8237C134.085 48.3657 133.409 45.1704 133.409 41.2376C133.409 39.8857 133.455 38.5184 133.547 37.1358H131.749C130.828 37.1358 130.198 36.9668 129.86 36.6288C129.553 36.2909 129.399 35.7532 129.399 35.0158C129.399 33.2952 130.09 32.4349 131.473 32.4349H134.1C134.622 29.0552 135.421 25.9673 136.496 23.1714C137.572 20.3754 138.862 18.1479 140.368 16.4887C141.904 14.8296 143.548 14 145.299 14C146.59 14 147.603 14.5684 148.341 15.7052C149.078 16.842 149.447 18.2708 149.447 19.9913C149.447 24.7537 147.45 28.9015 143.456 32.4349H148.617C149.109 32.4349 149.462 32.5424 149.677 32.7575C149.892 32.9726 150 33.372 150 33.9558C150 36.0758 148.264 37.1358 144.792 37.1358H139.169ZM144.055 18.4244C143.594 18.4244 143.072 19.0081 142.488 20.1757C141.935 21.3125 141.397 22.9102 140.875 24.9688C140.383 26.9966 139.968 29.2549 139.63 31.7436C141.443 30.1766 142.795 28.4253 143.686 26.4896C144.608 24.5233 145.069 22.7412 145.069 21.1435C145.069 19.3308 144.731 18.4244 144.055 18.4244Z" fill="#4FB98F"/>
</svg>'''

# 모니터 아이콘
SVG_MONITOR = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M5.33325 14V12.6667H2.66659C2.29992 12.6667 1.98614 12.5362 1.72525 12.2753C1.46436 12.0144 1.3337 11.7004 1.33325 11.3333V3.33333C1.33325 2.96667 1.46392 2.65289 1.72525 2.392C1.98659 2.13111 2.30036 2.00044 2.66659 2H13.3333C13.6999 2 14.0139 2.13067 14.2753 2.392C14.5366 2.65333 14.667 2.96711 14.6666 3.33333V11.3333C14.6666 11.7 14.5361 12.014 14.2753 12.2753C14.0144 12.5367 13.7004 12.6671 13.3333 12.6667H10.6666V14H5.33325ZM2.66659 11.3333H13.3333V3.33333H2.66659V11.3333Z" fill="#317C75"/>
</svg>'''

# 열쇠 아이콘 (API KEY)
SVG_KEY = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 1.75C7.65279 1.75 5.75 3.65279 5.75 6C5.75023 6.37267 5.79949 6.74369 5.89648 7.10352L1.75 11.25V14.25H4.75V12.75H6.25V11.25H7.75L8.90039 10.0996C9.25878 10.1976 9.62847 10.2482 10 10.25C12.3472 10.25 14.25 8.34722 14.25 6.00001C14.25 3.6528 12.3472 1.75 10 1.75Z" stroke="#317C75" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M10.75 5.75C11.0261 5.75 11.25 5.52614 11.25 5.25C11.25 4.97386 11.0261 4.75 10.75 4.75C10.4739 4.75 10.25 4.97386 10.25 5.25C10.25 5.52614 10.4739 5.75 10.75 5.75Z" fill="#317C75" stroke="#317C75" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# 백업 아이콘
SVG_BACKUP = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.75 10.75H1.75M1.75 10.75C1.75 10.75 4.25 14.25 8 14.25C11.4518 14.25 14.25 11.75 14.25 8.75M1.75 10.75V14.25M11.25 5.25H14.25M14.25 5.25C14.25 5.25 11.75 1.75 8 1.75C4.54822 1.75 1.75 4.25 1.75 7.25M14.25 5.25V1.75" stroke="#317C75" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# 쓰레기통 아이콘 (캐릭터 삭제) - 기본 초록색
SVG_TRASH = '''<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.25 1.125V9.875C9.25 10.1875 8.9375 10.5 8.625 10.5H5.5H2.375C2.0625 10.5 1.75 10.1875 1.75 9.875V1.125" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M0.5 1.125H10.5" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.25 0.5H6.75M4.25 3.625V8M6.75 3.625V8" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# 쓰레기통 아이콘 (빨간색 - 호버용)
SVG_TRASH_RED = '''<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.25 1.125V9.875C9.25 10.1875 8.9375 10.5 8.625 10.5H5.5H2.375C2.0625 10.5 1.75 10.1875 1.75 9.875V1.125" stroke="#E57373" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M0.5 1.125H10.5" stroke="#E57373" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.25 0.5H6.75M4.25 3.625V8M6.75 3.625V8" stroke="#E57373" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# 펜 아이콘 (이름 수정)
SVG_PEN = '''<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22 7.24002C22.0008 7.10841 21.9756 6.97795 21.9258 6.85611C21.876 6.73427 21.8027 6.62346 21.71 6.53002L17.47 2.29002C17.3766 2.19734 17.2658 2.12401 17.1439 2.07425C17.0221 2.02448 16.8916 1.99926 16.76 2.00002C16.6284 1.99926 16.4979 2.02448 16.3761 2.07425C16.2543 2.12401 16.1435 2.19734 16.05 2.29002L13.22 5.12002L2.29002 16.05C2.19734 16.1435 2.12401 16.2543 2.07425 16.3761C2.02448 16.4979 1.99926 16.6284 2.00002 16.76V21C2.00002 21.2652 2.10537 21.5196 2.29291 21.7071C2.48045 21.8947 2.7348 22 3.00002 22H7.24002C7.37994 22.0076 7.51991 21.9857 7.65084 21.9358C7.78176 21.8858 7.90073 21.8089 8.00002 21.71L18.87 10.78L21.71 8.00002C21.8011 7.90298 21.8755 7.79146 21.93 7.67002C21.9397 7.59031 21.9397 7.50973 21.93 7.43002C21.9347 7.38347 21.9347 7.33657 21.93 7.29002L22 7.24002ZM6.83002 20H4.00002V17.17L13.93 7.24002L16.76 10.07L6.83002 20ZM18.17 8.66002L15.34 5.83002L16.76 4.42002L19.58 7.24002L18.17 8.66002Z" fill="#65CAA2"/>
</svg>'''

# 말풍선 팔레트 아이콘
SVG_PALETTE = '''<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 0C7.57372 0 9.09315 0.562557 10.2217 1.57812C11.3521 2.59552 12 3.98881 12 5.45508C11.9999 6.32295 11.6547 7.15487 11.041 7.76855C10.4273 8.38222 9.59544 8.72753 8.72754 8.72754H7.5C7.42411 8.72758 7.34972 8.74916 7.28516 8.78906C7.22063 8.829 7.1687 8.88623 7.13477 8.9541C7.10094 9.02186 7.08606 9.09742 7.09277 9.17285C7.09958 9.24837 7.12742 9.32113 7.17285 9.38184L7.33691 9.59961C7.50401 9.8224 7.60581 10.0879 7.63086 10.3652C7.65587 10.6426 7.60302 10.9218 7.47852 11.1709C7.35394 11.4201 7.16177 11.6299 6.9248 11.7764C6.68796 11.9227 6.4151 12 6.13672 12H6C4.40892 11.9999 2.88294 11.3682 1.75781 10.2432C0.632604 9.11796 0 7.59129 0 6C6.37294e-05 4.4088 0.632661 2.88296 1.75781 1.75781C2.88296 0.632661 4.4088 6.37263e-05 6 0ZM6 1.09082C4.69813 1.09088 3.44987 1.60873 2.5293 2.5293C1.60873 3.44987 1.09088 4.69813 1.09082 6C1.09082 7.30196 1.60867 8.55105 2.5293 9.47168C3.44984 10.3921 4.69824 10.9091 6 10.9092H6.13672C6.21265 10.9092 6.28697 10.8876 6.35156 10.8477C6.41611 10.8077 6.46898 10.7505 6.50293 10.6826C6.53663 10.6149 6.55066 10.5392 6.54395 10.4639C6.53713 10.3883 6.50934 10.3156 6.46387 10.2549L6.2998 10.0371C6.1327 9.8143 6.0309 9.54887 6.00586 9.27148C5.98085 8.99412 6.0337 8.71492 6.1582 8.46582C6.28275 8.21674 6.47504 8.00777 6.71191 7.86133C6.9488 7.71495 7.22154 7.63676 7.5 7.63672H8.72754L8.83594 7.63379C9.3751 7.60698 9.88698 7.3806 10.2705 6.99707C10.6794 6.58801 10.9091 6.03345 10.9092 5.45508C10.9092 4.31744 10.4076 3.21252 9.49219 2.38867C8.57492 1.56323 7.31933 1.09082 6 1.09082ZM3 5.4541C3.4516 5.45425 3.81814 5.82087 3.81836 6.27246C3.81836 6.72423 3.45174 7.09067 3 7.09082C2.54831 7.09061 2.18164 6.7242 2.18164 6.27246C2.18186 5.82091 2.54845 5.45431 3 5.4541ZM9 4.36328C9.45161 4.36343 9.81815 4.73005 9.81836 5.18164C9.81826 5.63333 9.45167 5.99985 9 6C8.54838 5.99979 8.18174 5.63329 8.18164 5.18164C8.18185 4.73008 8.54844 4.36349 9 4.36328ZM4.09082 2.72754C4.54241 2.72759 4.9088 3.0934 4.90918 3.54492C4.90918 3.99676 4.54265 4.36323 4.09082 4.36328C3.63913 4.36307 3.27246 3.99666 3.27246 3.54492C3.27284 3.09351 3.63937 2.72775 4.09082 2.72754ZM6.81836 2.18164C7.26992 2.18185 7.63553 2.54844 7.63574 3C7.63559 3.45161 7.26996 3.81815 6.81836 3.81836C6.36677 3.81815 6.00015 3.45161 6 3C6.00021 2.54844 6.3668 2.18185 6.81836 2.18164Z" fill="#349971"/>
</svg>'''

# 돋보기+ 아이콘 (크기 조절)
SVG_SCALE = '''<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M7.19706 0.642873C7.76832 0.972721 8.26543 1.41682 8.65734 1.94744C9.04925 2.47806 9.32754 3.08379 9.47484 3.7268C9.62213 4.36981 9.63526 5.03629 9.51341 5.6846C9.39155 6.33292 9.13733 6.94914 8.76662 7.49478L11.7318 10.4595C11.8969 10.6222 11.9928 10.8423 11.9996 11.074C12.0064 11.3057 11.9235 11.531 11.7682 11.7031C11.613 11.8752 11.3973 11.9807 11.1661 11.9976C10.935 12.0145 10.7062 11.9416 10.5275 11.794L10.4591 11.7322L7.49454 8.76692C6.78527 9.24872 5.95984 9.53164 5.10416 9.58625C4.24847 9.64086 3.39378 9.46517 2.62902 9.07744C1.86425 8.68971 1.21735 8.10412 0.755628 7.3816C0.293903 6.65908 0.0342202 5.82602 0.00359856 4.9691L0 4.79816L0.00299884 4.62722C0.0325031 3.79997 0.275509 2.99443 0.708398 2.28887C1.14129 1.58332 1.74933 1.00177 2.47344 0.600726C3.19755 0.199686 4.01309 -0.00719433 4.8408 0.000191023C5.66851 0.00757638 6.48022 0.228977 7.19706 0.642873ZM4.79804 2.39904C4.65114 2.39905 4.50936 2.45299 4.39958 2.55061C4.2898 2.64823 4.21967 2.78274 4.20249 2.92864L4.19829 2.99882V4.19838H2.99878L2.9286 4.20258C2.78283 4.21992 2.64849 4.29012 2.55101 4.39989C2.45353 4.50965 2.39969 4.65136 2.39969 4.79816C2.39969 4.94497 2.45353 5.08667 2.55101 5.19644C2.64849 5.3062 2.78283 5.37641 2.9286 5.39375L2.99878 5.39794H4.19829V6.59751L4.20249 6.66768C4.21982 6.81346 4.29002 6.94781 4.39978 7.0453C4.50954 7.14278 4.65124 7.19662 4.79804 7.19662C4.94484 7.19662 5.08654 7.14278 5.1963 7.0453C5.30606 6.94781 5.37626 6.81346 5.3936 6.66768L5.3978 6.59751V5.39794H6.59731L6.66748 5.39375C6.81325 5.37641 6.9476 5.3062 7.04508 5.19644C7.14256 5.08667 7.19639 4.94497 7.19639 4.79816C7.19639 4.65136 7.14256 4.50965 7.04508 4.39989C6.9476 4.29012 6.81325 4.21992 6.66748 4.20258L6.59731 4.19838H5.3978V2.99882L5.3936 2.92864C5.37641 2.78274 5.30628 2.64823 5.1965 2.55061C5.08673 2.45299 4.94494 2.39905 4.79804 2.39904Z" fill="#349971"/>
</svg>'''

# 삭제 아이콘
SVG_DELETE = '''<svg width="11" height="11" viewBox="0 0 11 11" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M9.25 1.125V9.875C9.25 10.1875 8.9375 10.5 8.625 10.5H5.5H2.375C2.0625 10.5 1.75 10.1875 1.75 9.875V1.125" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M0.5 1.125H10.5" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
<path d="M4.25 0.5H6.75M4.25 3.625V8M6.75 3.625V8" stroke="#349971" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# 카메라 아이콘 (이미지 변경)
SVG_CAMERA = '''<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
<rect x="1" y="4" width="14" height="10" rx="2" stroke="#8ECFB5" stroke-width="1.2" fill="none"/>
<circle cx="8" cy="9" r="3" stroke="#8ECFB5" stroke-width="1.2" fill="none"/>
<path d="M5 4V3C5 2.44772 5.44772 2 6 2H10C10.5523 2 11 2.44772 11 3V4" stroke="#8ECFB5" stroke-width="1.2"/>
</svg>'''

# 말풍선 아이콘 (이미지 변경 버튼용)
SVG_IMAGE_CHANGE = '''<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M0 1.94801C0 1.43137 0.205236 0.935882 0.570559 0.570559C0.935882 0.205236 1.43137 0 1.94801 0H11.0387C11.5554 0 12.0509 0.205236 12.4162 0.570559C12.7815 0.935882 12.9867 1.43137 12.9867 1.94801V6.1687C12.9867 6.22347 12.9797 6.27801 12.966 6.33103C12.9797 6.38405 12.9867 6.4386 12.9867 6.49337V11.0387C12.9867 11.5554 12.7815 12.0509 12.4162 12.4162C12.0509 12.7815 11.5554 12.9867 11.0387 12.9867H1.94801C1.43137 12.9867 0.935882 12.7815 0.570559 12.4162C0.205236 12.0509 0 11.5554 0 11.0387V9.09071C5.2139e-05 9.03594 0.00703388 8.9814 0.0207788 8.92838C0.00703388 8.87536 5.2139e-05 8.82082 0 8.76605V1.94801ZM1.94411 8.33099C1.71814 8.33532 1.503 8.34528 1.29867 8.36086V1.94801C1.29867 1.7758 1.36709 1.61063 1.48886 1.48886C1.61063 1.36709 1.7758 1.29867 1.94801 1.29867H11.0387C11.2109 1.29867 11.3761 1.36709 11.4979 1.48886C11.6196 1.61063 11.6881 1.7758 11.6881 1.94801V5.85442C8.89786 5.94468 6.88297 6.61674 5.46741 7.55763C6.00377 7.74789 6.60375 8.01866 7.19205 8.3732C8.10048 8.91864 9.02383 9.68486 9.64525 10.6998C9.68976 10.7725 9.71951 10.8533 9.7328 10.9375C9.74609 11.0218 9.74265 11.1078 9.7227 11.1907C9.70274 11.2736 9.66664 11.3518 9.61648 11.4207C9.56631 11.4897 9.50305 11.5481 9.43032 11.5926C9.35758 11.6371 9.27679 11.6669 9.19255 11.6802C9.10832 11.6934 9.02229 11.69 8.93938 11.6701C8.85648 11.6501 8.77831 11.614 8.70935 11.5638C8.64039 11.5137 8.58199 11.4504 8.53748 11.3777C8.05957 10.5965 7.31802 9.96342 6.52324 9.48616C5.72975 9.00955 4.92262 8.71215 4.36289 8.58228C3.57438 8.40243 2.76706 8.31828 1.9584 8.33164H1.94411V8.33099ZM3.2324 2.91422C3.52174 2.71016 3.86663 2.59958 4.22069 2.59735C4.48692 2.59735 4.87197 2.67202 5.20898 2.91422C5.5791 3.18045 5.84403 3.6194 5.84403 4.22069C5.84403 4.82197 5.5791 5.26028 5.20898 5.5265C4.91971 5.7308 4.57482 5.84161 4.22069 5.84403C3.95446 5.84403 3.5694 5.76936 3.2324 5.5265C2.86228 5.26028 2.59735 4.82262 2.59735 4.22069C2.59735 3.6194 2.86228 3.1811 3.2324 2.91422Z" fill="#349971"/>
</svg>'''

# 말풍선 설정 아이콘 (하단 버튼용) - 하트 아이콘
SVG_BUBBLE_SETTING = '''<svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M6 10.5C6 10.5 1.5 7.5 1.5 4.5C1.5 3.5 2.5 2 4 2C5 2 5.5 2.5 6 3C6.5 2.5 7 2 8 2C9.5 2 10.5 3.5 10.5 4.5C10.5 7.5 6 10.5 6 10.5Z" stroke="#349971" stroke-width="1.2" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''

# Kiwipet 로고 SVG (간략화)
SVG_LOGO = '''<svg width="150" height="40" viewBox="0 0 150 40" fill="none" xmlns="http://www.w3.org/2000/svg">
<text x="0" y="30" font-family="Pretendard, sans-serif" font-size="28" font-weight="600" fill="#4FB98F">Kiwipet</text>
</svg>'''
import urllib.request
import urllib.error
import threading
import ssl
from io import BytesIO
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QPushButton, QLabel, QFileDialog, 
                             QScrollArea, QFrame, QMessageBox, QDialog, 
                             QRadioButton, QButtonGroup, QComboBox, QLineEdit,
                             QCheckBox, QColorDialog, QTextEdit, QGridLayout,
                             QGroupBox, QGraphicsDropShadowEffect, QSlider)
from PyQt5.QtCore import Qt, QTimer, QPoint, QPointF, QPropertyAnimation, QEasingCurve, pyqtSignal, QSize
from PyQt5.QtGui import QPixmap, QPainter, QFont, QColor, QPen, QPainterPath, QTransform, QIcon, QMovie, QImage

# SSL 인증서 검증 우회 (Mac에서 인증서 문제 해결용)
try:
    _ssl_context = ssl.create_default_context()
    _ssl_context.check_hostname = False
    _ssl_context.verify_mode = ssl.CERT_NONE
except:
    _ssl_context = None

# Windows 윈도우 감지용 (선택적)
_win32_available = False
try:
    import win32gui
    import win32con
    _win32_available = True
except ImportError:
    pass

# ==================== 플랫폼별 폰트 설정 ====================
import platform
from PyQt5.QtGui import QFontDatabase

# Pretendard 폰트 로드 함수
def load_pretendard_font():
    """Pretendard 폰트 로드 - 내장 또는 시스템"""
    font_db = QFontDatabase()
    
    # 1. 실행 파일과 같은 경로에서 폰트 찾기
    if getattr(sys, 'frozen', False):
        base_path = sys._MEIPASS
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    
    font_files = [
        'Pretendard-Medium.otf',
        'Pretendard-Bold.otf'
    ]
    
    loaded = False
    for font_file in font_files:
        font_path = os.path.join(base_path, font_file)
        if os.path.exists(font_path):
            font_id = font_db.addApplicationFont(font_path)
            if font_id >= 0:
                loaded = True
                print(f"[폰트] {font_file} 로드 성공")
        else:
            print(f"[폰트] {font_file} 파일 없음: {font_path}")
    
    # 2. 시스템에 Pretendard가 설치되어 있는지 확인
    if not loaded:
        families = font_db.families()
        if 'Pretendard' in families or 'Pretendard Variable' in families:
            loaded = True
            print("[폰트] 시스템 Pretendard 사용")
    
    return loaded

# 폰트 이름 설정 (나중에 QApplication 생성 후 로드)
KOREAN_FONT = 'Pretendard'
KOREAN_FONT_FALLBACK = 'Apple SD Gothic Neo' if platform.system() == 'Darwin' else '맑은 고딕'
KOREAN_FONT_CSS = f"'Pretendard', '{KOREAN_FONT_FALLBACK}', sans-serif"

# ==================== 내장 이미지 (Base64) ====================
# kiwipet_title.png - Base64 인코딩
TITLE_IMAGE_BASE64 = """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53Frw8orVXYjY7NrvO3WoWlX3s3hbyt6utl/IEjk7nGcZ9S0PSuv19NnZqi0YAsieitVziqKxKe6/oXAhKKFFYyhvtfC3lb1dbL9chEEmitXIAARkBd80a3hNpaJT3ZeGbz7Q6aQR1U7z2Vs0xFCe85+FcUJH4mNZTOVnTNQZlsrvn2jwPRvPZWzTES04jFUTZ5pp5GcKS9y9nZz53yiXu2bdu3aWFr7R3obxOM64oQaM0xn1R8dLbakCxZ8aJT0fM9PefaPml5noiUygM95q4zDe0fNq5xolPefaPm1c40SnvPtHzaLmqr1aucaJT3n2j5tXONEp7z7R82rm3jLdnT0K1C0q+5NIKJ7+UVquQAmZj/mf3yie/lFarnGiU959o+bVzjRKe8+0PcrrtiU959o+bVzjRKe8+0fNq5xolPebDUZwsWLBBPfyitVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzaubZ5z527weUVqucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzauPRBgguV2d8onv5RWq5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKej5BjtxvtfaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm0XNVcfiz40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm1c40SnpS/NoRVZWP5q5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xokvFCihl+bVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjOWy/Vm+lY5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPSl+acatVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzaucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRJVUg3oHyytkwqJ7+UVqucaJT3n2j5tXONEp7z7R82rnGiU959o+bVzjRKe8+0fNq5xolPefaPm1c40SnvPtHzS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"""

# kiwipet_character.png - Base64 인코딩 (간단한 캐릭터 실루엣)
def get_embedded_pixmap(base64_data):
    """Base64 문자열에서 QPixmap 생성"""
    try:
        image_data = base64.b64decode(base64_data.strip())
        pixmap = QPixmap()
        pixmap.loadFromData(image_data)
        return pixmap
    except:
        return QPixmap()


def find_image_file(app_dir, base_name):
    """다양한 확장자로 이미지 파일 찾기"""
    extensions = ['.png', '.PNG', '.jpg', '.JPG', '.jpeg', '.JPEG', '.gif', '.GIF', '.bmp', '.BMP']
    
    for ext in extensions:
        file_path = os.path.join(app_dir, base_name + ext)
        if os.path.exists(file_path):
            print(f"[이미지 발견] {file_path}")
            return file_path
    
    # 확장자 없는 파일도 시도
    file_path = os.path.join(app_dir, base_name)
    if os.path.exists(file_path):
        print(f"[이미지 발견] {file_path}")
        return file_path
    
    print(f"[이미지 없음] {base_name} in {app_dir}")
    return None


class ToggleSwitch(QWidget):
    """iOS 스타일 토글 스위치 - 33x17 크기"""
    toggled = pyqtSignal(bool)
    rightClicked = pyqtSignal()  # 우클릭 시그널
    
    def __init__(self, checked=True, parent=None):
        super().__init__(parent)
        self._checked = checked
        self.setFixedSize(33, 17)
        self.setCursor(Qt.PointingHandCursor)
    
    @property
    def checked(self):
        return self._checked
    
    @checked.setter
    def checked(self, value):
        self._checked = value
        self.update()
    
    def isChecked(self):
        return self._checked
    
    def setChecked(self, checked):
        self._checked = checked
        self.update()
    
    def mousePressEvent(self, event):
        if event.button() == Qt.RightButton:
            self.rightClicked.emit()
        else:
            self._checked = not self._checked
            self.toggled.emit(self._checked)
            self.update()
    
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 배경
        if self._checked:
            # ON: 파스텔 민트 배경
            painter.setBrush(QColor("#8ECFB5"))
            painter.setPen(Qt.NoPen)
        else:
            # OFF: 어두운 민트 배경
            painter.setBrush(QColor("#536E6C"))
            painter.setPen(Qt.NoPen)
        
        painter.drawRoundedRect(0, 0, self.width(), self.height(), 8, 8)
        
        # 흰색 원 (지름 약 14)
        circle_diameter = 14
        circle_y = (self.height() - circle_diameter) // 2
        if self._checked:
            # ON: 흰색 원 오른쪽
            circle_x = self.width() - circle_diameter - 2
        else:
            # OFF: 흰색 원 왼쪽
            circle_x = 2
        
        painter.setBrush(QColor("#FFFFFF"))
        painter.setPen(Qt.NoPen)
        painter.drawEllipse(circle_x, circle_y, circle_diameter, circle_diameter)


class IconButton(QPushButton):
    """미니멀한 아이콘 버튼 - 귀여운 파스텔 민트"""
    def __init__(self, icon_type, parent=None):
        super().__init__(parent)
        self.icon_type = icon_type  # 'pen', 'palette', 'scale'
        self.setFixedSize(28, 28)
        self.setCursor(Qt.PointingHandCursor)
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # 호버 효과 - 연한 민트
        if self.underMouse():
            painter.fillRect(self.rect(), QColor("#E8F5EE"))
        
        # 아이콘 색상 - 파스텔 민트
        icon_color = QColor("#8ECFB5")
        pen = QPen(icon_color)
        pen.setWidth(2)
        pen.setCapStyle(Qt.RoundCap)
        pen.setJoinStyle(Qt.RoundJoin)
        painter.setPen(pen)
        
        cx, cy = self.width() // 2, self.height() // 2
        
        if self.icon_type == 'pen':
            # 단정한 연필 아이콘 (대각선 연필)
            painter.setPen(QPen(icon_color, 2, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin))
            # 연필 몸체 (기울어진 사각형)
            path = QPainterPath()
            path.moveTo(18, 6)
            path.lineTo(22, 10)
            path.lineTo(10, 22)
            path.lineTo(6, 18)
            path.closeSubpath()
            painter.drawPath(path)
            # 연필 끝 (삼각형)
            painter.drawLine(6, 18, 4, 24)
            painter.drawLine(10, 22, 4, 24)
            # 연필 끝 선
            painter.drawLine(6, 18, 10, 22)
            
        elif self.icon_type == 'palette':
            # 물방울/색상 아이콘 (3개의 겹친 원)
            painter.setPen(Qt.NoPen)
            # 연한 핑크 원
            painter.setBrush(QColor("#FFB5BA"))
            painter.drawEllipse(4, 8, 10, 10)
            # 연한 노랑 원
            painter.setBrush(QColor("#FFE5A0"))
            painter.drawEllipse(11, 5, 10, 10)
            # 연한 민트 원
            painter.setBrush(QColor("#8ECFB5"))
            painter.drawEllipse(9, 13, 10, 10)
            
        elif self.icon_type == 'scale':
            # 확대경 아이콘
            painter.setBrush(Qt.NoBrush)
            painter.setPen(QPen(icon_color, 2))
            painter.drawEllipse(5, 5, 14, 14)
            painter.setPen(QPen(icon_color, 3, Qt.SolidLine, Qt.RoundCap))
            painter.drawLine(17, 17, 23, 23)

__version__ = "1.2.3"
__author__ = "Kiwipet Team"

# ==================== AI 대사 생성 (Gemini API) ====================
# API 설정
_gemini_api_key = None
_gemini_model = "gemini-2.5-flash-lite"  # 기본 모델
_ai_enabled = False

# 사용 가능한 Gemini 모델 목록
GEMINI_MODELS = [
    ("gemini-2.5-flash-lite", "Gemini 2.5 Flash Lite (기본 모델)"),
    ("gemini-2.0-flash", "Gemini 2.0 Flash"),
    ("gemini-1.5-flash", "Gemini 1.5 Flash"),
    ("gemini-1.5-flash-8b", "Gemini 1.5 Flash 8B"),
]
_ai_dialogues_cache = {}  # {char_id: {'solo': [], 'interaction': [], 'generated_at': time}}
_temp_dialogues_cache = {}  # 시간/날짜 임시 대사
_ai_generation_interval = 3600  # 1시간 (초)
_ai_dialogues_count = 10  # 캐릭터당 생성할 대사 수

def is_similar_dialogue(new_dialogue, existing_dialogues, prefix_len=4):
    """
    새 대사가 기존 대사와 유사한지 체크
    - 앞 N글자가 같으면 유사하다고 판단
    - 정확히 같은 대사도 유사로 처리
    """
    if not new_dialogue or not existing_dialogues:
        return False

    new_clean = new_dialogue.strip()
    if len(new_clean) < prefix_len:
        # 짧은 대사는 정확히 같은 경우만 체크
        return new_clean in [d.strip() for d in existing_dialogues if d]

    new_prefix = new_clean[:prefix_len]

    for existing in existing_dialogues:
        if not existing:
            continue
        existing_clean = existing.strip()

        # 정확히 같은 경우
        if new_clean == existing_clean:
            return True

        # 앞 N글자가 같은 경우
        if len(existing_clean) >= prefix_len and existing_clean[:prefix_len] == new_prefix:
            return True

    return False

def sync_dialogues_to_ai_cache(char_id, dialogues):
    """수동 대사를 AI 캐시의 reference 필드에 동기화 (AI 생성 시 참고용으로만 사용, 실제 대사로는 출력 안 함)"""
    global _ai_dialogues_cache

    if not dialogues:
        return

    if char_id not in _ai_dialogues_cache:
        _ai_dialogues_cache[char_id] = {
            'solo': [],
            'interaction': {},
            'fallback': [],
            'reference': {},  # 참고용 수동 대사 (AI 생성 시에만 사용)
            'generated_at': time.time()
        }

    cache = _ai_dialogues_cache[char_id]

    # reference 필드 초기화
    if 'reference' not in cache:
        cache['reference'] = {}

    # 기본 대사 → reference['기본'] (참고용으로만 저장)
    if '기본' in dialogues:
        if '기본' not in cache['reference']:
            cache['reference']['기본'] = []
        for d in dialogues['기본']:
            if d and isinstance(d, str) and d.strip() and d != '(선택)' and d not in cache['reference']['기본']:
                cache['reference']['기본'].append(d)

    # 상호작용 대사 → reference (참고용으로만 저장)
    for key, values in dialogues.items():
        if key == '기본':
            continue
        if not isinstance(values, list):
            continue

        # 키 형식 통일: 'char_X' → int X, int → int, str 숫자 → int
        cache_key = None
        if isinstance(key, str):
            if key.startswith('char_'):
                try:
                    cache_key = int(key.replace('char_', ''))
                except ValueError:
                    cache_key = key
            else:
                try:
                    cache_key = int(key)
                except ValueError:
                    cache_key = key
        elif isinstance(key, int):
            cache_key = key
        else:
            cache_key = key

        if cache_key is None:
            continue

        ref_key = f'char_{cache_key}' if isinstance(cache_key, int) else cache_key
        if ref_key not in cache['reference']:
            cache['reference'][ref_key] = []

        for d in values:
            if d and isinstance(d, str) and d.strip() and d != '(선택)' and d not in cache['reference'][ref_key]:
                cache['reference'][ref_key].append(d)

# 시간대 구분
TIME_PERIODS = {
    'dawn': (0, 6),        # 새벽 (0-6시)
    'morning': (6, 12),    # 아침 (6-12시)
    'afternoon': (12, 15), # 낮 (12-15시)
    'late_afternoon': (15, 18), # 늦은 오후 (15-18시)
    'evening': (18, 21),   # 저녁 (18-21시)
    'night': (21, 24)      # 밤 (21-24시)
}

# 월별 계절/기온 정보
MONTH_SEASON_INFO = {
    1: ("한겨울", "매우 춥고 눈이 올 수 있음"),
    2: ("겨울", "춥지만 조금씩 해가 길어짐"),
    3: ("초봄", "아직 쌀쌀하지만 따뜻해지는 중"),
    4: ("봄", "따뜻하고 꽃이 피는 시기"),
    5: ("늦봄", "포근하고 화창함"),
    6: ("초여름", "더워지기 시작, 장마 가능성"),
    7: ("한여름", "매우 덥고 습함"),
    8: ("한여름", "무더위, 폭염 가능성"),
    9: ("초가을", "선선해지기 시작"),
    10: ("가을", "선선하고 단풍 시기"),
    11: ("늦가을", "쌀쌀하고 낙엽"),
    12: ("초겨울", "춥고 눈이 올 수 있음")
}

def get_time_period(hour):
    """현재 시간의 시간대 반환"""
    for period, (start, end) in TIME_PERIODS.items():
        if start <= hour < end:
            return period
    return 'night'

def get_season_info(month):
    """월에 따른 계절/기온 정보 반환"""
    return MONTH_SEASON_INFO.get(month, ("", ""))

def clean_api_key(api_key):
    """API 키에서 모든 비정상 문자 제거 (ASCII 영숫자와 _-만 허용)"""
    if not api_key:
        return ""
    import re
    # 문자열로 변환
    api_key = str(api_key)
    # 1. 유니코드 BOM 제거
    api_key = api_key.replace('\ufeff', '').replace('\ufffe', '')
    # 2. 모든 공백, 줄바꿈, 탭, 제어 문자 제거
    api_key = re.sub(r'[\s\x00-\x1f\x7f-\x9f\u200b-\u200f\u2028-\u202f]', '', api_key)
    # 3. ASCII 영숫자와 _-만 허용 (Google API 키 형식)
    api_key = ''.join(c for c in api_key if c.isascii() and (c.isalnum() or c in '_-'))
    return api_key

def make_safe_url(base_url, api_key):
    """안전한 URL 생성 (제어 문자 완전 제거)"""
    import urllib.parse
    cleaned_key = clean_api_key(api_key)
    # URL 안전 인코딩 (추가 안전 조치)
    safe_key = urllib.parse.quote(cleaned_key, safe='')
    return f"{base_url}?key={safe_key}"

def set_gemini_api_key(api_key):
    """Gemini API 키 설정 (제어 문자 자동 제거)"""
    global _gemini_api_key
    _gemini_api_key = clean_api_key(api_key)

def set_gemini_model(model):
    """Gemini 모델 설정"""
    global _gemini_model
    _gemini_model = model

def get_gemini_model():
    """현재 선택된 Gemini 모델 반환"""
    return _gemini_model

def set_ai_enabled(enabled):
    """AI 기능 활성화/비활성화"""
    global _ai_enabled
    _ai_enabled = enabled

def is_ai_enabled():
    """AI 기능 활성화 여부"""
    return _ai_enabled and bool(_gemini_api_key)

def init_temp_cache(char_id):
    """캐릭터 임시 캐시 초기화"""
    global _temp_dialogues_cache
    from datetime import datetime
    import time
    
    if char_id not in _temp_dialogues_cache:
        _temp_dialogues_cache[char_id] = {
            'time': {
                'dawn': [],           # 새벽
                'morning': [],        # 아침
                'afternoon': [],      # 낮
                'late_afternoon': [], # 늦은 오후
                'evening': [],        # 저녁
                'night': []           # 밤
            },
            'season': [],             # 계절 대사
            'date': [],               # 날짜 대사
            'last_date': datetime.now().strftime('%Y-%m-%d'),
            'last_month': datetime.now().month,
            'last_cleanup': time.time()
        }

def cleanup_temp_dialogues():
    """임시 대사 정리
    - 시간 대사: 삭제하지 않음 (계속 쌓임)
    - 계절 대사: 월이 바뀌면 삭제
    - 날짜 대사: 자정에 삭제
    """
    global _temp_dialogues_cache
    import time
    from datetime import datetime
    
    today = datetime.now().strftime('%Y-%m-%d')
    current_month = datetime.now().month
    
    for char_id in list(_temp_dialogues_cache.keys()):
        cache = _temp_dialogues_cache[char_id]
        last_date = cache.get('last_date', today)
        last_month = cache.get('last_month', current_month)
        
        # 자정이 지나면 날짜 대사 삭제
        if last_date != today:
            cache['date'] = []
            cache['last_date'] = today
            print(f"[AI] 캐릭터 {char_id} 날짜 대사 초기화 (자정)")
        
        # 월이 바뀌면 계절 대사 삭제
        if last_month != current_month:
            cache['season'] = []
            cache['last_month'] = current_month
            print(f"[AI] 캐릭터 {char_id} 계절 대사 초기화 (새로운 달)")

def add_temp_dialogue(char_id, dialogue_type, dialogue, sub_type=None):
    """임시 대사 추가
    
    Args:
        char_id: 캐릭터 ID
        dialogue_type: 'time', 'season', 'date'
        dialogue: 대사 텍스트
        sub_type: 시간대 (time 타입일 때)
    """
    global _temp_dialogues_cache
    import time
    
    init_temp_cache(char_id)
    
    if dialogue_type == 'time' and sub_type:
        # 시간 대사는 시간대별로 저장 (계속 쌓임)
        if sub_type not in _temp_dialogues_cache[char_id]['time']:
            _temp_dialogues_cache[char_id]['time'][sub_type] = []
        _temp_dialogues_cache[char_id]['time'][sub_type].append(dialogue)
        print(f"[AI] 시간 대사 추가 ({sub_type}): {dialogue}")
    elif dialogue_type == 'season':
        # 계절 대사
        _temp_dialogues_cache[char_id]['season'].append(dialogue)
        print(f"[AI] 계절 대사 추가: {dialogue}")
    else:
        # 날짜 대사
        _temp_dialogues_cache[char_id]['date'].append(dialogue)
        print(f"[AI] 날짜 대사 추가: {dialogue}")

def get_temp_dialogue(char_id, dialogue_type, sub_type=None):
    """임시 대사 가져오기
    
    Args:
        char_id: 캐릭터 ID
        dialogue_type: 'time', 'season', 'date'
        sub_type: 시간대
    """
    if char_id not in _temp_dialogues_cache:
        return None
    
    cache = _temp_dialogues_cache[char_id]
    
    if dialogue_type == 'time':
        # 현재 시간대의 대사만 반환
        if sub_type and sub_type in cache.get('time', {}):
            dialogues = cache['time'][sub_type]
            if dialogues:
                return random.choice(dialogues)
        return None
    elif dialogue_type == 'season':
        dialogues = cache.get('season', [])
        if dialogues:
            return random.choice(dialogues)
        return None
    else:  # date
        dialogues = cache.get('date', [])
        if dialogues:
            return random.choice(dialogues)
        return None

def get_cached_dialogue(char_id, dialogue_type='solo', other_char_id=None, other_char_name=None):
    """캐시에서 랜덤 대사 가져오기
    
    Args:
        char_id: 캐릭터 ID
        dialogue_type: 'solo', 'interaction', 'fallback' 중 하나
        other_char_id: 상호작용 상대 ID (interaction 타입일 때)
        other_char_name: 상호작용 상대 이름 (interaction 타입일 때, 이름으로 저장된 경우)
    """
    import re
    
    if char_id not in _ai_dialogues_cache:
        return None
    
    cache = _ai_dialogues_cache[char_id]
    
    if dialogue_type == 'solo':
        dialogues = cache.get('solo', [])
    elif dialogue_type == 'fallback':
        dialogues = cache.get('fallback', [])
    else:  # interaction
        interaction_cache = cache.get('interaction', {})
        # 1. 먼저 char_id로 조회
        dialogues = interaction_cache.get(other_char_id, [])
        # 2. 없으면 캐릭터 이름으로 조회
        if not dialogues and other_char_name:
            dialogues = interaction_cache.get(other_char_name, [])
        # 3. 그래도 없으면 default로 조회
        if not dialogues:
            dialogues = interaction_cache.get('default', [])
    
    if dialogues:
        dialogue = random.choice(dialogues)
        # 메타 정보 패턴 제거 (관계:, 호칭: 등)
        dialogue = re.sub(r'\(관계:\s*[^,)]+,\s*호칭:\s*[^)]+\)', '', dialogue)
        dialogue = re.sub(r'\(호칭:\s*[^,)]+,\s*관계:\s*[^)]+\)', '', dialogue)
        dialogue = re.sub(r'\[관계:\s*[^\]]+\]', '', dialogue)
        dialogue = re.sub(r'\[호칭:\s*[^\]]+\]', '', dialogue)
        # 앞뒤 공백 제거
        dialogue = dialogue.strip()
        return dialogue if dialogue else None
    return None

def make_unique_names(other_chars_info):
    """
    같은 이름의 캐릭터가 있으면 구분자 추가
    예: [("키위", ...), ("키위", ...)] -> [("키위", ...), ("키위(2)", ...)]
    
    Args:
        other_chars_info: [(name, nicknames, relationship, story), ...]
    Returns:
        [(unique_name, nicknames, relationship, story), ...]
    """
    if not other_chars_info:
        return []
    
    # 이름별 등장 횟수 카운트
    name_counts = {}
    for info in other_chars_info:
        name = info[0]
        name_counts[name] = name_counts.get(name, 0) + 1
    
    # 중복 이름에 인덱스 추가
    name_indices = {}
    result = []
    
    for info in other_chars_info:
        name = info[0]
        
        if name_counts[name] > 1:
            # 중복 이름 - 인덱스 추가
            name_indices[name] = name_indices.get(name, 0) + 1
            idx = name_indices[name]
            if idx == 1:
                unique_name = name  # 첫 번째는 그대로
            else:
                unique_name = f"{name}({idx})"  # 두 번째부터 (2), (3)...
        else:
            unique_name = name
        
        # 튜플 재구성
        if len(info) == 4:
            result.append((unique_name, info[1], info[2], info[3]))
        else:
            result.append((unique_name,) + info[1:])
    
    return result

def generate_dialogues_batch(char_name_orig, personality_orig, sample_dialogues, other_chars_info, callback, background_story="", retry_count=0, existing_dialogues=None):
    """
    Gemini API를 사용해 대사 일괄 생성 (비동기)
    429 에러 시 120초 후 재시도 (최대 2회)

    Args:
        char_name_orig: 캐릭터 이름
        personality_orig: 캐릭터 성격
        sample_dialogues: 유저가 입력한 샘플 대사 리스트 (말투 참고 1순위)
        other_chars_info: [(other_name, nicknames_str, relationship, story), ...] 다른 캐릭터 정보
        callback: 생성 완료 후 호출 (solo_dialogues, interaction_dialogues, fallback_dialogues)
        background_story: 캐릭터 배경 스토리 (선택)
        retry_count: 재시도 횟수 (내부 사용)
        existing_dialogues: 기존 대사 dict {'solo': [...], 'interaction': {...}} (중복 방지용)
    """
    if not _gemini_api_key:
        callback([], {}, [])
        return
    
    def api_call():
        try:
            import re
            # 모든 입력 텍스트에서 제어 문자 제거 (URL 오류 방지)
            def clean_text(text):
                if not text:
                    return ""
                text = str(text)
                # 유니코드 BOM 제거
                text = text.replace('\ufeff', '').replace('\ufffe', '')
                # 모든 제어 문자 제거 (줄바꿈/탭 제외)
                text = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x9f]', '', text)
                # 특수 유니코드 공백 문자 제거
                text = re.sub(r'[\u200b-\u200f\u2028-\u202f\u205f-\u206f]', '', text)
                return text.strip()
            
            char_name = clean_text(char_name_orig)
            personality = clean_text(personality_orig)
            background_story_clean = clean_text(background_story)
            
            print(f"[AI] 정리된 입력 - 이름: {char_name}, 성격 길이: {len(personality)}")
            
            # other_chars_info도 정리
            cleaned_other_chars = []
            for info in other_chars_info:
                if len(info) == 4:
                    name, nicknames, rel, story = info
                    cleaned_other_chars.append((clean_text(name), clean_text(nicknames), clean_text(rel), clean_text(story)))
                else:
                    cleaned_other_chars.append(tuple(clean_text(x) for x in info))
            
            # 현재 시간/날짜 파악
            from datetime import datetime
            now = datetime.now()
            hour = now.hour
            month = now.month
            day = now.day
            
            # 시간대
            if 5 <= hour < 9:
                time_context = "이른 아침"
                time_examples = "좋은 아침!, 일어났어?, 오늘도 파이팅!"
            elif 9 <= hour < 12:
                time_context = "오전"
                time_examples = "오늘 뭐해?, 좋은 하루!, 힘내자~"
            elif 12 <= hour < 14:
                time_context = "점심시간"
                time_examples = "밥 먹었어?, 점심 맛있게!, 배고파~"
            elif 14 <= hour < 18:
                time_context = "오후"
                time_examples = "좀 졸려…, 간식 먹을까?, 오후도 파이팅!"
            elif 18 <= hour < 21:
                time_context = "저녁"
                time_examples = "좋은 저녁!, 저녁 뭐 먹어?, 오늘 수고했어!"
            elif 21 <= hour < 24:
                time_context = "밤"
                time_examples = "졸리다.., 잘 자!, 좋은 꿈 꿔~"
            else:  # 0 <= hour < 5
                time_context = "새벽"
                time_examples = "아직 안 잤어?, 늦었다.., 푹 자!"
            
            # 날짜/계절 컨텍스트
            date_context = f"{month}월 {day}일"
            special_day = ""
            
            # 특별한 날
            if month == 1 and day == 1:
                special_day = "새해 첫날! (새해 복 많이 받아!, 올해도 잘 부탁해~)"
            elif month == 2 and day == 14:
                special_day = "발렌타인데이! (초콜릿 먹고 싶다~, 해피 발렌타인!)"
            elif month == 3 and day == 14:
                special_day = "화이트데이! (사탕 좋아!, 달콤한 하루~)"
            elif month == 3 and day == 1:
                special_day = "삼일절! (대한독립만세!)"
            elif month == 5 and day == 5:
                special_day = "어린이날! (선물 뭐야?, 신난다~)"
            elif month == 12 and day == 24:
                special_day = "크리스마스 이브! (내일이 크리스마스!, 설렌다~)"
            elif month == 12 and day == 25:
                special_day = "크리스마스! (메리 크리스마스!, 산타 왔나?)"
            elif month == 12 and day == 31:
                special_day = "연말! (올해 마지막 날!, 내년에도 잘 부탁해~)"
            elif month == 10 and day == 31:
                special_day = "할로윈! (트릭 오어 트릿!, 으스스~)"
            
            # 계절
            if month in [3, 4, 5]:
                season = "봄 (날씨 좋다~, 꽃이 예쁘네)"
            elif month in [6, 7, 8]:
                season = "여름 (더워.., 아이스크림 먹고 싶다)"
            elif month in [9, 10, 11]:
                season = "가을 (선선하다~, 단풍 예쁘네)"
            else:
                season = "겨울 (추워.., 따뜻한 게 좋아)"
            
            # 월별 특징
            month_context = ""
            if month == 12:
                month_context = "12월이라 연말 분위기, 크리스마스 기대"
            elif month == 1:
                month_context = "새해라서 새로운 시작 분위기"
            elif month == 2:
                month_context = "아직 추운 겨울"
            
            # 특별한 날
            special_context = ""
            if special_day:
                special_context = f"오늘은 특별한 날: {special_day}"
            
            # 샘플 대사로 말투 분석 (1순위) - 제어 문자 제거
            speech_style = ""
            has_ellipsis_in_samples = False  # 수동 대사에 말줄임표가 있는지
            if sample_dialogues:
                valid_samples = [clean_text(d) for d in sample_dialogues if d and d.strip() and d != '(선택)']
                if valid_samples:
                    samples_text = '\n'.join([f'  - "{s}"' for s in valid_samples[:8]])
                    speech_style = f"""
★★★ [최우선 - 말투 참고] ★★★
아래는 유저가 직접 입력한 이 캐릭터의 말투 예시입니다.
반드시 이 말투(어미, 존댓말/반말, 어조, 문장 스타일)를 그대로 따라해야 합니다:
{samples_text}

위 예시의 말투 특징을 분석하고, 생성하는 모든 대사에 동일한 말투를 적용하세요."""
                    # 수동 대사에 말줄임표('…' 또는 '...')가 있는지 체크
                    for sample in valid_samples:
                        if '…' in sample or '...' in sample:
                            has_ellipsis_in_samples = True
                            break
            
            # 말줄임표 제한 규칙 (수동 대사에 말줄임표가 없는 경우만)
            ellipsis_rule = ""
            if not has_ellipsis_in_samples:
                ellipsis_rule = "\n- [중요] 말줄임표(…)는 전체 대사 중 최대 2개에만 사용할 것 (남용 금지)"
            
            # 상호작용 대상 정보 (호칭, 관계, 서사 포함)
            interaction_targets = ""
            interaction_prompt_sections = ""
            if cleaned_other_chars:
                targets = []
                sections = []
                for info in cleaned_other_chars[:10]:  # 최대 10명까지 지원
                    name, nicknames, rel, story = info if len(info) == 4 else (*info, '')
                    target_str = f"{name}(호칭: {nicknames}, 관계: {rel})"
                    if story:
                        target_str += f" - {story}"
                    targets.append(target_str)
                    # 캐릭터별 상호작용 대사 섹션 추가
                    sections.append(f"[{name}]\n{name}에게 하는 대사 5개 (관계: {rel}, 호칭: {nicknames}):")
                interaction_targets = "상호작용 대상: " + ", ".join(targets)
                interaction_prompt_sections = "\n\n".join(sections)
            
            # 서사 정보 추출
            story_context = ""
            if cleaned_other_chars:
                stories = []
                for info in cleaned_other_chars[:10]:  # 최대 10명까지 지원
                    name, nicknames, rel, story = info if len(info) == 4 else (*info, '')
                    if story:
                        stories.append(f"{name}: {story}")
                if stories:
                    story_context = "다른 캐릭터와의 서사:\n" + "\n".join(stories)
            
            # 캐릭터 배경 스토리
            bg_story_context = ""
            if background_story_clean:
                bg_story_context = f"캐릭터 배경 스토리: {background_story_clean}"
            
            # 상호작용 대사 섹션 (캐릭터별로 분리)
            interaction_section = ""
            if interaction_prompt_sections:
                interaction_section = f"""
[상호작용]
각 캐릭터에게 하는 대사를 캐릭터별로 작성하세요:

{interaction_prompt_sections}

- 성격이 드러나는 대화
- 호칭은 1~2개 대사에만 자연스럽게 포함
- 서사/관계를 반영한 대사"""
            else:
                interaction_section = """
[상호작용]
다른 캐릭터에게 하는 대사 10개 (줄바꿈 구분):
- 성격이 드러나는 대화"""

            # 기존 대사 중복 방지용 문구 생성 (대사가 많을수록 더 많이 샘플링)
            existing_dialogues_text = ""
            if existing_dialogues:
                existing_samples = []
                # 혼잣말에서 샘플링 (대사 수에 비례, 최대 25개)
                if existing_dialogues.get('solo'):
                    solo_list = existing_dialogues['solo']
                    solo_count = len(solo_list)
                    # 대사가 많을수록 더 많이 샘플링 (100개당 약 8개)
                    sample_count = min(25, max(10, solo_count // 12))
                    # 고르게 샘플링 (처음, 중간, 최근 대사 포함)
                    if solo_count <= sample_count:
                        solo_samples = [clean_text(d) for d in solo_list if d]
                    else:
                        import random
                        # 최근 5개는 반드시 포함
                        recent = solo_list[-5:]
                        # 나머지는 랜덤 샘플링
                        rest = solo_list[:-5]
                        sampled = random.sample(rest, min(sample_count - 5, len(rest)))
                        solo_samples = [clean_text(d) for d in (sampled + recent) if d]
                    existing_samples.extend(solo_samples)
                # 상호작용에서 캐릭터당 최대 5개씩
                if existing_dialogues.get('interaction'):
                    for char_dialogues in existing_dialogues['interaction'].values():
                        if isinstance(char_dialogues, list):
                            interaction_samples = [clean_text(d) for d in char_dialogues[-5:] if d]
                            existing_samples.extend(interaction_samples)
                if existing_samples:
                    # 최대 40개까지 전달
                    final_samples = existing_samples[:40]
                    existing_dialogues_text = f"\n[중복 금지] 아래 대사와 동일하거나 비슷한 대사(앞 4글자가 같은 것 포함)는 절대 생성하지 마세요:\n{', '.join(final_samples)}\n"
                    print(f"[AI] 중복 방지용 기존 대사 {len(final_samples)}개 포함")

            # 프롬프트 - 성격, 서사, 기본 대사 포함
            prompt = f"""데스크톱 펫 캐릭터의 대사를 생성하세요.

캐릭터: {char_name}
성격: {personality if personality else "친근하고 귀여운 성격"}
{bg_story_context}
{speech_style}
{interaction_targets}
{story_context}
{existing_dialogues_text}

아래 형식으로 대사를 생성하세요. 반드시 성격과 서사를 반영해주세요.

[혼자]
혼자 중얼거리는 대사 15개 (줄바꿈 구분):
- 성격이 드러나는 혼잣말, 감탄사
- 서사가 있다면 서사를 반영한 대사
- 예: "심심해.", "뭐하지…", "오늘도 평화롭네."
- 시간/날씨/계절/요일 언급 금지
{interaction_section}

규칙:
★ [최우선] 위에 제시된 참고 대사의 말투를 반드시 따를 것! 어미(-요, -야, -다, -음 등), 존댓말/반말, 어조를 똑같이 사용!
★ [최우선] 참고 대사가 반말이면 반말로, 존댓말이면 존댓말로, 특수한 어미가 있으면 그 어미를 사용!
- [절대 금지] 이모티콘, 이모지, 특수문자 이모지(😀💕🎵 등) 절대 사용하지 말 것
- [절대 금지] ㅎㅎ, ㅋㅋ, ㅋㅋㅋ, ㅎㅎㅎ 사용 금지
- 각 대사 15자 이내
- 자연스러운 구어체, 올바른 띄어쓰기
- 모든 대사 끝에 마침표(.) 또는 느낌표(!) 또는 물음표(?) 붙이기
- 성격과 배경 스토리를 잘 반영할 것
- 호칭은 적당한 빈도로만 사용 (매번 부르지 말 것)
- 번호 붙이지 말 것
- 대사만 작성 (설명 금지)
- 말줄임표는 반드시 '…' 또는 …로 작성 ('..' 사용 금지){ellipsis_rule}
- 한글과 기본 문장부호(.,!?)만 사용"""

            # API 키에서 제어 문자 제거 (안전 조치)
            cleaned_key = clean_api_key(_gemini_api_key)
            if not cleaned_key:
                print("[AI] API 키가 비어 있습니다.")
                callback([], {}, [])
                return
            
            if len(cleaned_key) != 39:
                print(f"[AI] API 키 길이 오류: {len(cleaned_key)}자 (39자 필요)")
                callback([], {}, [])
                return
            
            model = get_gemini_model()
            url = make_safe_url(f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent", cleaned_key)
            print(f"[AI] URL 생성 완료 (모델: {model}, 키 길이: {len(cleaned_key)})")
            
            data = {
                "contents": [{"parts": [{"text": prompt}]}],
                "generationConfig": {
                    "temperature": 0.9,
                    "maxOutputTokens": 8192
                }
            }
            
            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode('utf-8'),
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            
            with urllib.request.urlopen(req, timeout=30, context=_ssl_context) as response:
                result = json.loads(response.read().decode('utf-8'))
            
            # 디버깅: 응답 구조 출력
            print(f"[AI] 응답 키: {result.keys()}")
            
            if 'candidates' in result and result['candidates']:
                candidate = result['candidates'][0]
                print(f"[AI] candidate 키: {candidate.keys()}")
                
                # 텍스트 추출 (여러 형식 지원)
                text = ""
                if 'content' in candidate:
                    content = candidate['content']
                    if 'parts' in content and content['parts']:
                        text = content['parts'][0].get('text', '')
                    elif 'text' in content:
                        text = content['text']
                elif 'text' in candidate:
                    text = candidate['text']
                elif 'output' in candidate:
                    text = candidate['output']
                
                if not text:
                    print(f"[AI] 텍스트 추출 실패. candidate 내용: {str(candidate)[:300]}")
                    callback([], {}, [])
                    return
                
                print(f"[AI] 응답 텍스트 길이: {len(text)}")
                
                # 캐릭터 이름 목록 추출 (cleaned_other_chars에서 가져와야 AI 응답과 매칭됨)
                char_names_list = [info[0] for info in cleaned_other_chars] if cleaned_other_chars else []
                print(f"[AI] 상호작용 대상 캐릭터 목록: {char_names_list}")
                
                # 파싱
                solo_dialogues = []
                interaction_dialogues = {}  # {캐릭터이름: [대사들]}
                
                current_section = None
                current_char_name = None
                
                for line in text.split('\n'):
                    line = line.strip()
                    if not line:
                        continue
                    
                    # 섹션 감지
                    if '[혼자]' in line or '혼자' in line and ('중얼' in line or '대사' in line):
                        current_section = 'solo'
                        current_char_name = None
                        continue
                    elif '[상호작용]' in line:
                        current_section = 'interaction'
                        current_char_name = None
                        continue
                    elif '[기본]' in line:
                        current_section = 'solo'
                        current_char_name = None
                        continue
                    elif '[' in line and ']' in line:
                        # 캐릭터 이름 섹션인지 확인
                        bracket_content = line.split('[')[1].split(']')[0].strip()
                        
                        # 정확히 매칭되는 이름 찾기
                        matched_name = None
                        for char_name in char_names_list:
                            if bracket_content == char_name:
                                matched_name = char_name
                                break
                            # 부분 매칭 시도 (이름이 포함되어 있으면)
                            if char_name in bracket_content or bracket_content in char_name:
                                matched_name = char_name
                                break
                        
                        if matched_name:
                            current_section = 'char_interaction'
                            current_char_name = matched_name
                            if current_char_name not in interaction_dialogues:
                                interaction_dialogues[current_char_name] = []
                            print(f"[AI] 캐릭터 섹션 감지: {matched_name}")
                            continue
                        else:
                            # 다른 섹션은 무시
                            current_section = None
                            current_char_name = None
                            continue
                    
                    # "캐릭터이름에게" 또는 "캐릭터이름:" 형식 감지
                    for char_name in char_names_list:
                        if line.startswith(f"{char_name}에게") or line.startswith(f"{char_name}:") or f"## {char_name}" in line:
                            current_section = 'char_interaction'
                            current_char_name = char_name
                            if current_char_name not in interaction_dialogues:
                                interaction_dialogues[current_char_name] = []
                            print(f"[AI] 캐릭터 섹션 감지 (대체 형식): {char_name}")
                            continue
                    
                    # 대사 정리
                    dialogue = line.strip('- ').strip('"\'').strip()
                    # 숫자로 시작하는 경우 제거 (1. 2. 등)
                    if dialogue and dialogue[0].isdigit() and '.' in dialogue[:3]:
                        dialogue = dialogue.split('.', 1)[-1].strip()
                    
                    # 메타 정보 패턴 제거 (관계:, 호칭: 등)
                    dialogue = re.sub(r'\(관계:\s*[^,)]+,\s*호칭:\s*[^)]+\)', '', dialogue)
                    dialogue = re.sub(r'\(호칭:\s*[^,)]+,\s*관계:\s*[^)]+\)', '', dialogue)
                    dialogue = re.sub(r'\[관계:\s*[^\]]+\]', '', dialogue)
                    dialogue = re.sub(r'\[호칭:\s*[^\]]+\]', '', dialogue)
                    dialogue = dialogue.strip()
                    
                    # ㅎㅎ, ㅋㅋ 등 필터링
                    if dialogue in ['ㅎㅎ', 'ㅋㅋ', 'ㅋㅋㅋ', 'ㅎㅎㅎ']:
                        continue
                    
                    # 이모티콘/이모지 필터링 (유니코드 범위 체크)
                    has_emoji = False
                    for char in dialogue:
                        code = ord(char)
                        # 이모지 유니코드 범위
                        if (0x1F300 <= code <= 0x1F9FF or  # 다양한 심볼
                            0x2600 <= code <= 0x26FF or    # 기호
                            0x2700 <= code <= 0x27BF or    # 딩뱃
                            0x1F600 <= code <= 0x1F64F or  # 이모티콘
                            0x1F680 <= code <= 0x1F6FF):   # 교통/지도
                            has_emoji = True
                            break
                    if has_emoji:
                        continue
                    
                    if dialogue and len(dialogue) <= 20 and current_section:
                        if current_section == 'solo':
                            solo_dialogues.append(dialogue)
                        elif current_section == 'interaction':
                            # 일반 상호작용은 'default'에 저장
                            if 'default' not in interaction_dialogues:
                                interaction_dialogues['default'] = []
                            interaction_dialogues['default'].append(dialogue)
                        elif current_section == 'char_interaction' and current_char_name:
                            interaction_dialogues[current_char_name].append(dialogue)
                
                total_interaction = sum(len(d) for d in interaction_dialogues.values())
                interaction_detail = {k: len(v) for k, v in interaction_dialogues.items()}
                print(f"[AI] {char_name} 대사 생성 완료: 혼자 {len(solo_dialogues)}개, 상호작용 {total_interaction}개")
                print(f"[AI] 상호작용 상세: {interaction_detail}")
                callback(solo_dialogues, interaction_dialogues, [])
            else:
                print(f"[AI] 응답에 candidates 없음: {str(result)[:300]}")
                callback([], {}, [], True)  # 에러 플래그
                
        except urllib.error.HTTPError as e:
            error_body = e.read().decode('utf-8') if e.fp else ""
            print(f"[AI] HTTP 오류 {e.code}: {e.reason}")
            print(f"[AI] 상세: {error_body[:200]}")
            
            # 429 에러 시 재시도
            if e.code == 429 and retry_count < 2:
                wait_time = 120  # 2분 대기
                print(f"[AI] 429 에러 - {wait_time}초 후 재시도 ({retry_count + 1}/2)")
                import time as time_module
                time_module.sleep(wait_time)
                # 재귀 호출로 재시도
                generate_dialogues_batch(char_name_orig, personality_orig, sample_dialogues, other_chars_info, callback, background_story, retry_count + 1, existing_dialogues)
                return
            
            # 에러 발생 시 _error 플래그와 함께 빈 데이터 전달 (기존 캐시 보존)
            callback([], {}, [], True)  # 4번째 인자: is_error
        except ValueError as e:
            # URL 관련 오류 상세 출력
            print(f"[AI] ValueError - URL 또는 데이터 오류: {e}")
            print(f"[AI] API 키 길이: {len(cleaned_key) if cleaned_key else 0}")
            print(f"[AI] 캐릭터 이름: '{char_name}' (길이: {len(char_name)})")
            # 제어 문자 확인
            for i, c in enumerate(cleaned_key or ""):
                if ord(c) < 32 or ord(c) > 126:
                    print(f"[AI] API 키 비정상 문자 발견: 위치 {i}, 코드 {ord(c)}")
            callback([], {}, [], True)  # 에러 플래그
        except Exception as e:
            print(f"[AI] 대사 생성 실패: {type(e).__name__}: {e}")
            import traceback
            print(f"[AI] 스택 트레이스:\n{traceback.format_exc()}")
            callback([], {}, [], True)  # 에러 플래그
    
    # 비동기 실행
    thread = threading.Thread(target=api_call, daemon=True)
    thread.start()

def generate_time_weather_dialogue(char_id, char_name, personality, current_time, weather_info=None, callback=None):
    """시간/계절 기반 대사 생성 (임시 캐시에 저장)
    
    - 시간 대사: 삭제 안 함, 같은 시간대에만 출력
    - 날짜 대사: 날짜가 바뀌면 삭제
    - 월별 계절/기온 정보를 자동으로 추측해서 프롬프트에 포함
    """
    if not _gemini_api_key or not personality:
        if callback:
            callback(None)
        return
    
    # 현재 시간대 구하기
    hour = current_time.hour
    current_period = get_time_period(hour)
    
    # 월별 계절 정보 가져오기
    month = current_time.month
    season_name, season_desc = get_season_info(month)
    
    def api_call():
        try:
            import re
            # 제어 문자 제거
            clean_char_name = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', str(char_name)) if char_name else ''
            clean_personality = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', str(personality)) if personality else ''
            
            # 시간 정보 (6단계)
            if 0 <= hour < 6:
                time_desc = "새벽"
            elif 6 <= hour < 12:
                time_desc = "아침"
            elif 12 <= hour < 15:
                time_desc = "낮"
            elif 15 <= hour < 18:
                time_desc = "늦은 오후"
            elif 18 <= hour < 21:
                time_desc = "저녁"
            else:  # 21 <= hour < 24
                time_desc = "밤"
            
            weekday = ["월요일", "화요일", "수요일", "목요일", "금요일", "토요일", "일요일"][current_time.weekday()]
            date_str = current_time.strftime("%m월 %d일")
            
            # 날짜 관련 키워드 체크 (월요일, 금요일, 특별한 날 등)
            is_date_specific = weekday in ["월요일", "금요일", "토요일", "일요일"]
            
            prompt = f"""캐릭터: {clean_char_name}
성격: {clean_personality}

현재 시간: {time_desc} ({weekday}, {date_str})
계절: {season_name} ({season_desc})

이 캐릭터가 현재 시간/계절/요일에 맞게 할 법한 짧은 혼잣말 1개만 생성하세요.
15자 이내로 작성하세요. 이모지 사용하지 마세요."""

            data = {
                "contents": [{"parts": [{"text": prompt}]}],
                "generationConfig": {
                    "temperature": 0.9,
                    "maxOutputTokens": 50,
                    "topP": 0.95
                }
            }
            
            # API 키에서 제어 문자 제거 (안전 조치)
            cleaned_key = clean_api_key(_gemini_api_key)
            if not cleaned_key or len(cleaned_key) != 39:
                print(f"[AI] API 키 오류: 길이 {len(cleaned_key) if cleaned_key else 0}")
                if callback:
                    callback(None)
                return
            
            model = get_gemini_model()
            url = make_safe_url(f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent", cleaned_key)

            req = urllib.request.Request(
                url,
                data=json.dumps(data).encode('utf-8'),
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            
            with urllib.request.urlopen(req, timeout=15, context=_ssl_context) as response:
                result = json.loads(response.read().decode('utf-8'))
            
            if 'candidates' in result and result['candidates']:
                text = result['candidates'][0]['content']['parts'][0]['text']
                dialogue = text.strip().strip('"').strip("'").strip()
                
                # 임시 캐시에 저장
                if is_date_specific:
                    # 날짜 대사 (날짜 바뀌면 삭제)
                    add_temp_dialogue(char_id, 'date', dialogue)
                else:
                    # 시간 대사 (시간대별로 저장, 삭제 안 함)
                    add_temp_dialogue(char_id, 'time', dialogue, current_period)
                
                if callback:
                    callback(dialogue)
            else:
                if callback:
                    callback(None)
                    
        except urllib.error.HTTPError as e:
            # 429 오류 등은 조용히 실패
            print(f"[AI] 시간/계절 대사 생성 실패 (HTTP {e.code})")
            if callback:
                callback(None)
        except Exception as e:
            print(f"[AI] 시간/계절 대사 생성 실패: {e}")
            if callback:
                callback(None)
    
    # 비동기 실행
    thread = threading.Thread(target=api_call, daemon=True)
    thread.start()

def update_character_cache(char_id, char_name, personality, sample_dialogues, other_chars_info, background_story=""):
    """캐릭터의 대사 캐시 업데이트 (기존 대사에 추가)"""
    global _ai_dialogues_cache

    # 기존 대사 가져오기 (중복 방지용)
    existing = None
    if char_id in _ai_dialogues_cache:
        existing = _ai_dialogues_cache[char_id]

    def on_generated(solo, interaction, fallback):
        global _ai_dialogues_cache
        if char_id in _ai_dialogues_cache:
            # 기존 캐시가 있으면 추가 (중복 제거)
            cache = _ai_dialogues_cache[char_id]
            for d in solo:
                if d and d.strip() and d not in cache['solo']:
                    cache['solo'].append(d)
            for d in fallback:
                if d and d.strip() and d not in cache['fallback']:
                    cache['fallback'].append(d)
            if 'interaction' not in cache:
                cache['interaction'] = {}
            # interaction이 딕셔너리인 경우 각 키별로 추가 (중복 제거)
            if isinstance(interaction, dict):
                for key, dialogues in interaction.items():
                    if key not in cache['interaction']:
                        cache['interaction'][key] = []
                    for d in dialogues:
                        if d and d.strip() and d not in cache['interaction'][key]:
                            cache['interaction'][key].append(d)
            cache['generated_at'] = time.time()
            print(f"[AI] {char_name} 캐시에 대사 추가 (solo +{len(solo)})")
        else:
            # 새로 생성
            _ai_dialogues_cache[char_id] = {
                'solo': solo,
                'interaction': interaction if isinstance(interaction, dict) else {'default': interaction},
                'fallback': fallback,
                'reference': {},  # 참고용 수동 대사
                'generated_at': time.time()
            }
            print(f"[AI] {char_name} 캐시 새로 생성")

    generate_dialogues_batch(char_name, personality, sample_dialogues, other_chars_info, on_generated, background_story, 0, existing)

def clear_dialogue_cache():
    """대사 캐시 전체 삭제"""
    global _ai_dialogues_cache
    _ai_dialogues_cache = {}
    print("[AI] 대사 캐시 초기화")


class CharacterWidget(QWidget):
    collision_detected = pyqtSignal(object)
    
    def __init__(self, image_path, char_id, facing_direction='front', scale=100, bubble_color='#81C784', bubble_size=100):
        super().__init__()
        self.char_id = char_id
        self.image_path = image_path
        self.initial_facing = facing_direction
        self.scale = scale
        self.bubble_color = QColor(bubble_color)
        self.bubble_size = bubble_size  # 말풍선 크기 (%)
        self.relationships = {}  # {other_char_id: relationship_type}
        self.dialogues = {'기본': []}  # {'기본': [...], 'char_0': [...]}
        self.personality = ""  # 캐릭터 성격 설명
        self.background_story = ""  # 캐릭터 배경 스토리 (선택)
        self.nicknames = {}  # {other_char_id: "호칭"} - 다른 캐릭터를 부르는 호칭
        self.stories = {}  # {other_char_id: "서사"} - 다른 캐릭터와의 서사
        self.ai_auto_generate = True  # AI 대사 자동생성 활성화 여부
        self.char_name = f"캐릭터 {char_id + 1}"  # 캐릭터 이름
        self.catchphrase = ""  # 캐릭터 캐치프레이즈
        self.sample_dialogues = []  # 샘플 대사 목록
        self.generating_status = ""  # 대사 생성 중 표시
        self.is_previewing_bubble = False  # 말풍선 미리보기 중인지
        self.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground)
        # 투명 영역에서도 마우스 이벤트 받기
        self.setAttribute(Qt.WA_TransparentForMouseEvents, False)
        
        # 드래그 관련
        self.dragging = False
        self.drag_start_pos = None
        self.drag_start_widget_pos = None
        self.was_clicked = False
        
        # 시간 기반 상태
        self.is_sleepy = False
        self.time_dialogue_timer = 0
        self.check_time_status()
        
        # GIF 지원
        self.is_gif = image_path.lower().endswith('.gif')
        self.gif_movie = None
        
        # 이미지 로드
        try:
            if self.is_gif:
                # GIF 파일인 경우 QMovie 사용
                self.gif_movie = QMovie(image_path)
                if self.gif_movie.isValid():
                    self.gif_movie.setCacheMode(QMovie.CacheAll)
                    # 시그널 먼저 연결
                    self.gif_movie.frameChanged.connect(self.on_gif_frame_changed)
                    # 애니메이션 시작
                    self.gif_movie.start()
                    # 첫 프레임 가져오기 (start 후에)
                    self.original_pixmap = self.gif_movie.currentPixmap()
                    # pixmap이 유효하지 않으면 일반 이미지로 로드 시도
                    if self.original_pixmap.isNull():
                        print(f"[GIF] 첫 프레임 로드 실패, 일반 이미지로 시도: {image_path}")
                        self.original_pixmap = QPixmap(image_path)
                        self.is_gif = False
                        self.gif_movie.stop()
                        self.gif_movie = None
                    else:
                        print(f"[GIF] 로드 성공: {image_path}, 프레임 수: {self.gif_movie.frameCount()}, 상태: {self.gif_movie.state()}")
                else:
                    print(f"[GIF] 유효하지 않은 GIF, 일반 이미지로 시도: {image_path}")
                    self.original_pixmap = QPixmap(image_path)
                    self.is_gif = False
                    self.gif_movie = None
            else:
                self.original_pixmap = QPixmap(image_path)
            
            # pixmap이 여전히 유효하지 않으면 기본 이미지 생성
            if self.original_pixmap.isNull():
                print(f"[이미지] 로드 실패, 기본 이미지 생성: {image_path}")
                self.original_pixmap = QPixmap(100, 100)
                self.original_pixmap.fill(QColor(200, 200, 200))
        except Exception as e:
            print(f"[이미지] 로드 오류: {e}")
            self.original_pixmap = QPixmap(100, 100)
            self.original_pixmap.fill(QColor(200, 200, 200))
            self.is_gif = False
            self.gif_movie = None
        
        self.size = int(100 * (scale / 100))
        self.pixmap = self.original_pixmap.scaled(self.size, self.size, 
                                                   Qt.KeepAspectRatio, 
                                                   Qt.SmoothTransformation)
        
        # 투명 영역 분석하여 발 위치 계산
        self.foot_offset = self.calculate_foot_offset(self.pixmap)
        # 투명 영역 분석하여 머리 위치 계산
        self.head_offset = self.calculate_head_offset(self.pixmap)
        
        # 초기 방향에 따라 이미지 설정
        if self.initial_facing == 'right':
            self.pixmap_left = self.pixmap.transformed(QTransform().scale(-1, 1))
            self.pixmap_right = self.pixmap
        elif self.initial_facing == 'left':
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap.transformed(QTransform().scale(-1, 1))
        else:  # 'front'
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap
        
        self.setFixedSize(self.size + 120, self.size + 150)  # 높이 추가로 말풍선 + 점프 스케일 공간 확보
        
        # 이동 관련 변수
        self.velocity_x = random.choice([-2, -1.5, 1.5, 2])
        self.velocity_y = 0
        self.gravity = 0.8
        self.max_fall_speed = 15  # 최대 낙하 속도
        self.is_jumping = False
        self.on_ground = True
        self.facing_right = self.velocity_x > 0
        
        # 점프 관련
        self.jump_power = random.uniform(-8, -10)
        self.jump_cooldown = 0
        
        # 점프 스케일 애니메이션
        self.jump_scale = 1.0  # 현재 스케일 (1.0 = 100%)
        self.jump_scale_target = 1.0  # 목표 스케일
        
        # 멈춤/걷기 상태
        self.is_moving = True
        self.state_timer = random.randint(60, 180)
        
        # 상호작용 관련
        self.speech_bubble = None
        self.bubble_timer = 0
        self.interaction_cooldown = 0
        
        # 긴 이벤트 관련
        self.in_event = False
        self.event_type = None
        self.event_partner = None
        self.event_frame = 0
        self.event_duration = 0
        self.event_data = {}  # 이벤트별 추가 데이터
        
        # 화면 정보 (작업 표시줄 제외한 사용 가능 영역)
        screen = QApplication.desktop().availableGeometry()
        self.screen_geometry = screen  # 모니터 선택용
        self.screen_width = screen.width()
        self.screen_height = screen.height()
        self.screen_x = screen.x()  # 모니터 시작 X 좌표 (멀티모니터용)
        self.screen_y = screen.y()  # 모니터 시작 Y 좌표 (멀티모니터용)
        
        # foot_offset 제한 (캐릭터 높이의 1/2 이하로)
        max_foot_offset = self.pixmap.height() // 2
        self.foot_offset = min(self.foot_offset, max_foot_offset)
        
        # ground_level 계산 - 위젯 하단이 화면 하단(작업표시줄 위)에 딱 붙도록
        # 캐릭터 이미지는 위젯 하단에 그려지므로, 위젯 y = screen_bottom - widget_height
        self.ground_level = self.screen_y + self.screen_height - self.height()
        
        # 창 위에 있는지 체크
        self.on_window = False
        self.window_top = 0
        
        # 시작 위치 (바닥)
        start_x = self.screen_x + random.randint(0, max(0, self.screen_width - self.width()))
        self.move(start_x, self.ground_level)
        
        # 이동 타이머
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_position)
        self.timer.start(30)
        
        self.show()
    
    def calculate_foot_offset(self, pixmap):
        """이미지의 투명 영역을 분석하여 발 위치(하단 여백) 계산"""
        if pixmap.isNull():
            return 0
        
        # QPixmap을 QImage로 변환
        image = pixmap.toImage()
        width = image.width()
        height = image.height()
        
        # 아래에서 위로 스캔하여 불투명 픽셀이 있는 마지막 행 찾기
        last_opaque_row = height - 1
        
        for y in range(height - 1, -1, -1):
            has_opaque = False
            for x in range(width):
                # 알파값 확인 (0=투명, 255=불투명)
                pixel = image.pixel(x, y)
                alpha = (pixel >> 24) & 0xFF
                if alpha > 10:  # 거의 투명하지 않은 픽셀
                    has_opaque = True
                    break
            if has_opaque:
                last_opaque_row = y
                break
        
        # 발 위치 = 이미지 높이 - 마지막 불투명 행 - 1
        foot_offset = height - last_opaque_row - 1
        
        print(f"[투명도 분석] 이미지 높이: {height}, 마지막 불투명 행: {last_opaque_row}, foot_offset: {foot_offset}")
        
        return foot_offset
    
    def calculate_head_offset(self, pixmap):
        """이미지의 상단 투명 영역을 분석하여 머리 위치(상단 여백) 계산"""
        if pixmap.isNull():
            return 0
        
        # QPixmap을 QImage로 변환
        image = pixmap.toImage()
        width = image.width()
        height = image.height()
        
        # 위에서 아래로 스캔하여 불투명 픽셀이 있는 첫 행 찾기
        first_opaque_row = 0
        
        for y in range(height):
            has_opaque = False
            for x in range(width):
                pixel = image.pixel(x, y)
                alpha = (pixel >> 24) & 0xFF
                if alpha > 10:
                    has_opaque = True
                    break
            if has_opaque:
                first_opaque_row = y
                break
        
        print(f"[투명도 분석] 첫 불투명 행: {first_opaque_row}, head_offset: {first_opaque_row}")
        
        return first_opaque_row
    
    def get_current_ground_level(self, x=None):
        """현재 캐릭터 위치에 해당하는 모니터의 ground_level을 동적으로 계산"""
        if x is None:
            x = self.x()
        
        # 전체 모니터 모드가 아니면 기존 ground_level 사용
        if not getattr(self, 'use_all_monitors', False):
            return self.ground_level
        
        # 현재 위치가 어느 모니터에 있는지 찾기
        desktop = QApplication.desktop()
        char_center_x = x + self.width() // 2
        
        for i in range(desktop.screenCount()):
            screen_geo = desktop.screenGeometry(i)
            if screen_geo.x() <= char_center_x < screen_geo.x() + screen_geo.width():
                # 이 모니터의 availableGeometry (작업표시줄 제외)
                available_geo = desktop.availableGeometry(i)
                # 이 모니터의 ground_level 계산
                monitor_ground = available_geo.y() + available_geo.height() - self.height()
                return monitor_ground
        
        # 못 찾으면 기본 ground_level 반환
        return self.ground_level
    
    def show_dialogue(self, text, duration=180):
        """말풍선 표시"""
        self.speech_bubble = text
        self.bubble_timer = duration
        self.update()
    
    def hide_dialogue(self):
        """말풍선 숨기기"""
        self.speech_bubble = None
        self.bubble_timer = 0
        self.update()
    
    def update_scale(self, new_scale):
        """크기 업데이트"""
        self.scale = new_scale
        old_size = self.size
        self.size = int(100 * (new_scale / 100))
        
        # GIF인 경우 현재 프레임 기준으로, 아닌 경우 original_pixmap 기준
        if self.is_gif and self.gif_movie:
            current_pixmap = self.gif_movie.currentPixmap()
            if not current_pixmap.isNull():
                self.pixmap = current_pixmap.scaled(self.size, self.size, 
                                                     Qt.KeepAspectRatio, 
                                                     Qt.SmoothTransformation)
            else:
                self.pixmap = self.original_pixmap.scaled(self.size, self.size, 
                                                           Qt.KeepAspectRatio, 
                                                           Qt.SmoothTransformation)
        else:
            self.pixmap = self.original_pixmap.scaled(self.size, self.size, 
                                                       Qt.KeepAspectRatio, 
                                                       Qt.SmoothTransformation)
        
        # 투명 영역 다시 분석
        self.foot_offset = self.calculate_foot_offset(self.pixmap)
        self.head_offset = self.calculate_head_offset(self.pixmap)
        
        if self.initial_facing == 'right':
            self.pixmap_left = self.pixmap.transformed(QTransform().scale(-1, 1))
            self.pixmap_right = self.pixmap
        elif self.initial_facing == 'left':
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap.transformed(QTransform().scale(-1, 1))
        else:
            self.pixmap_left = self.pixmap
            self.pixmap_right = self.pixmap
        
        self.setFixedSize(self.size + 120, self.size + 150)  # 높이 추가로 말풍선 + 점프 스케일 공간 확보
        
        # foot_offset 제한 (캐릭터 높이의 1/2 이하로)
        max_foot_offset = self.pixmap.height() // 2
        self.foot_offset = min(self.foot_offset, max_foot_offset)
        
        # foot_offset 제한 및 ground_level 계산
        screen_y = getattr(self, 'screen_y', 0)
        # 위젯 하단이 화면 하단(작업표시줄 위)에 딱 붙도록
        self.ground_level = screen_y + self.screen_height - self.height()
        
        # 현재 y 위치가 ground_level 아래로 내려갔으면 ground_level로 재조정
        current_y = self.y()
        if current_y > self.ground_level:
            self.move(self.x(), self.ground_level)
        
        self.update()
    
    def on_gif_frame_changed(self, frame_number):
        """GIF 프레임 변경 시 호출"""
        try:
            if self.gif_movie and self.is_gif:
                current_pixmap = self.gif_movie.currentPixmap()
                if not current_pixmap.isNull():
                    # 현재 크기로 스케일
                    self.pixmap = current_pixmap.scaled(self.size, self.size, 
                                                        Qt.KeepAspectRatio, 
                                                        Qt.SmoothTransformation)
                    # 방향에 따라 pixmap 업데이트
                    if self.initial_facing == 'right':
                        self.pixmap_left = self.pixmap.transformed(QTransform().scale(-1, 1))
                        self.pixmap_right = self.pixmap
                    elif self.initial_facing == 'left':
                        self.pixmap_left = self.pixmap
                        self.pixmap_right = self.pixmap.transformed(QTransform().scale(-1, 1))
                    else:
                        self.pixmap_left = self.pixmap
                        self.pixmap_right = self.pixmap
                    self.update()
        except Exception as e:
            print(f"[GIF] 프레임 업데이트 오류: {e}")
    
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setRenderHint(QPainter.SmoothPixmapTransform)
            
            # pixmap_right가 없으면 리턴
            if not hasattr(self, 'pixmap_right') or self.pixmap_right is None:
                return
            
            # 캐릭터 그리기 - 위젯 하단에 배치 (말풍선 공간은 위에)
            char_x = 60
            # 캐릭터를 위젯 하단에 정확히 맞춤 + foot_offset 적용 (투명 영역만큼 아래로)
            foot_offset = getattr(self, 'foot_offset', 0)
            char_y = self.height() - self.pixmap_right.height() + foot_offset
            
            # 그릴 픽스맵 선택
            if self.initial_facing == 'front':
                current_pixmap = self.pixmap_right
            else:
                if getattr(self, 'facing_right', True):
                    current_pixmap = self.pixmap_right
                else:
                    current_pixmap = getattr(self, 'pixmap_left', self.pixmap_right)
            
            # 말풍선 그리기 (캐릭터 그리기 전에 먼저 - 캐릭터 머리 위에)
            if self.speech_bubble and self.bubble_timer > 0:
                self.draw_speech_bubble(painter, char_x, char_y, current_pixmap.width())
            
            # 캐릭터 그리기 (스케일 없이 단순하게)
            painter.drawPixmap(char_x, char_y, current_pixmap)
            
            # AI 대사 생성 중 표시
            if getattr(self, 'generating_status', ''):
                self.draw_generating_status(painter, char_y)
        except Exception as e:
            # 오류 시 기본 그리기 시도
            try:
                if hasattr(self, 'pixmap_right') and self.pixmap_right:
                    painter = QPainter(self)
                    painter.drawPixmap(60, 10, self.pixmap_right)
            except:
                pass
    
    def draw_generating_status(self, painter, char_y):
        """AI 대사 생성 중 상태 표시 (연한 글씨)"""
        if not hasattr(self, 'pixmap_right') or self.pixmap_right is None:
            return
        
        painter.save()
        
        font = QFont(KOREAN_FONT, 8)
        font.setWeight(QFont.Bold)
        painter.setFont(font)
        
        # 연한 회색
        painter.setPen(QColor(150, 150, 150, 180))
        
        # 캐릭터 바로 아래에 표시
        text = self.generating_status
        metrics = painter.fontMetrics()
        text_width = metrics.horizontalAdvance(text)
        
        # 캐릭터 이미지 위치 기준
        char_x = 60
        char_height = self.pixmap_right.height()
        
        x = char_x + self.pixmap_right.width() // 2 - text_width // 2
        y = char_y + char_height + 12  # 캐릭터 바로 아래
        
        painter.drawText(x, y, text)
        painter.restore()
    
    def draw_speech_bubble(self, painter, char_x, char_y, char_width):
        """말풍선 그리기 - 캐릭터 머리 위 중앙에서 위로 확장"""
        # painter 상태 저장
        painter.save()
        
        # 말풍선 크기 스케일 적용
        size_scale = self.bubble_size / 100.0
        
        # 이모티콘인지 체크 - 한글/영문이 없고 길이가 짧은 경우만
        def has_text(s):
            for c in s:
                if '\uAC00' <= c <= '\uD7A3':  # 한글
                    return True
                if 'a' <= c.lower() <= 'z':  # 영문
                    return True
            return False
        
        is_emoji = len(self.speech_bubble) <= 2 and not has_text(self.speech_bubble)
        
        # 텍스트 크기 - 크기 스케일 적용
        base_font_size = 12 if is_emoji else 10
        scaled_font_size = max(8, int(base_font_size * size_scale))
        
        font = QFont(KOREAN_FONT, scaled_font_size)
        # 이모티콘은 Medium, 텍스트는 Bold
        if is_emoji:
            font.setWeight(QFont.Medium)
        else:
            font.setWeight(QFont.Bold)
        painter.setFont(font)
        metrics = painter.fontMetrics()
        
        # 최대 너비 설정 (긴 텍스트 줄바꿈용) - 스케일 적용
        max_bubble_width = int(160 * size_scale)
        
        # 텍스트 줄바꿈 처리
        text = self.speech_bubble
        text_width = metrics.horizontalAdvance(text)
        
        # 패딩 스케일 적용
        base_padding_x = 6 if is_emoji else 12
        base_padding_y = 4 if is_emoji else 8
        padding_x = int(base_padding_x * size_scale)
        padding_y = int(base_padding_y * size_scale)
        
        lines = []
        if text_width > max_bubble_width - padding_x * 2:
            # 단어 단위로 줄바꿈 (띄어쓰기 기준)
            words = text.split(' ')
            current_line = ""
            
            for word in words:
                if not current_line:
                    test_line = word
                else:
                    test_line = current_line + ' ' + word
                
                if metrics.horizontalAdvance(test_line) > max_bubble_width - padding_x * 2:
                    # 현재 줄이 있으면 저장
                    if current_line:
                        lines.append(current_line)
                        current_line = word
                    else:
                        # 단어가 너무 길면 글자 단위로 나눔
                        for char in word:
                            test_char = current_line + char
                            if metrics.horizontalAdvance(test_char) > max_bubble_width - padding_x * 2:
                                if current_line:
                                    lines.append(current_line)
                                current_line = char
                            else:
                                current_line = test_char
                else:
                    current_line = test_line
            
            if current_line:
                lines.append(current_line)
        else:
            lines = [text]
        
        # 가장 긴 줄의 너비 계산
        max_line_width = max(metrics.horizontalAdvance(line) for line in lines)
        text_height = metrics.height()
        total_text_height = text_height * len(lines)
        
        # 말풍선 크기 계산
        bubble_width = max_line_width + padding_x * 2
        bubble_height = total_text_height + padding_y * 2
        
        # 꼬리 크기
        tail_size = int(6 * size_scale)
        tail_height = int(8 * size_scale)
        
        # 말풍선 위치 - 캐릭터 중앙 위에 배치
        char_center_x = char_x + char_width // 2
        bubble_x = char_center_x - bubble_width // 2
        
        # head_offset을 적용하여 실제 캐릭터 머리 바로 위에 말풍선 배치
        head_offset = getattr(self, 'head_offset', 0)
        actual_head_y = char_y + head_offset  # 실제 캐릭터 머리 위치
        
        bubble_bottom = actual_head_y - tail_height - 2  # 캐릭터 머리 위 (꼬리 공간 확보)
        bubble_y = bubble_bottom - bubble_height  # 위로 확장
        
        # 말풍선이 위젯 영역을 벗어나지 않도록 조정
        if bubble_y < 2:
            bubble_y = 2
            bubble_bottom = bubble_y + bubble_height
        if bubble_x < 2:
            bubble_x = 2
        if bubble_x + bubble_width > self.width() - 2:
            bubble_x = self.width() - bubble_width - 2
        
        # 색상 - 더 진하게
        base_color = self.bubble_color
        h, s, v, a = base_color.getHsv()
        darker_color = QColor.fromHsv(h, min(255, s + 40), max(0, v - 50))
        
        # 전체 말풍선 패스 (라운드 사각형 + 아래쪽 꼬리)
        full_path = QPainterPath()
        
        # 라운드 사각형 시작 - 스케일 적용
        radius = int(8 * size_scale)
        
        # 상단 왼쪽부터 시계방향으로 그리기
        full_path.moveTo(bubble_x + radius, bubble_y)
        
        # 상단 라인
        full_path.lineTo(bubble_x + bubble_width - radius, bubble_y)
        full_path.arcTo(bubble_x + bubble_width - radius * 2, bubble_y, 
                       radius * 2, radius * 2, 90, -90)
        
        # 오른쪽 라인
        full_path.lineTo(bubble_x + bubble_width, bubble_bottom - radius)
        full_path.arcTo(bubble_x + bubble_width - radius * 2, 
                       bubble_bottom - radius * 2, 
                       radius * 2, radius * 2, 0, -90)
        
        # 하단 라인 (꼬리 직전까지) - 꼬리가 아래쪽(캐릭터 쪽)을 향함
        tail_center_x = bubble_x + bubble_width // 2
        
        full_path.lineTo(tail_center_x + tail_size, bubble_bottom)
        
        # 꼬리 삼각형 (아래쪽으로)
        full_path.lineTo(tail_center_x, bubble_bottom + tail_height)
        full_path.lineTo(tail_center_x - tail_size, bubble_bottom)
        
        # 하단 라인 계속
        full_path.lineTo(bubble_x + radius, bubble_bottom)
        full_path.arcTo(bubble_x, bubble_bottom - radius * 2,
                       radius * 2, radius * 2, 270, -90)
        
        # 왼쪽 라인
        full_path.lineTo(bubble_x, bubble_y + radius)
        full_path.arcTo(bubble_x, bubble_y, radius * 2, radius * 2, 180, -90)
        
        full_path.closeSubpath()
        
        # 말풍선 그리기 - 테두리 두께도 스케일 적용
        border_width = max(1.5, 2.5 * size_scale)
        painter.setBrush(QColor(255, 255, 255, 240))
        painter.setPen(QPen(darker_color, border_width))
        painter.drawPath(full_path)
        
        # 텍스트 (진한 색상) - 여러 줄 지원
        painter.setPen(darker_color)
        for i, line in enumerate(lines):
            text_x = bubble_x + padding_x
            text_y = bubble_y + padding_y + metrics.ascent() + (i * text_height)
            painter.drawText(text_x, text_y, line)
        
        # painter 상태 복원
        painter.restore()
    
    def check_time_status(self):
        """시간대별 상태 체크"""
        from datetime import datetime
        current_hour = datetime.now().hour
        
        # 밤 시간 (22시~6시)
        if current_hour >= 22 or current_hour < 6:
            self.is_sleepy = True
        else:
            self.is_sleepy = False
    
    def update_position(self):
        """위치 업데이트 - 통통 뛰어다니기"""
        # 필수 속성 체크
        if not hasattr(self, 'pixmap_right') or self.pixmap_right is None:
            return
        
        if self.dragging:
            return
        
        # 긴 이벤트 진행 중
        if self.in_event:
            self.update_long_event()
            # 이벤트 중에도 중력과 위치 업데이트는 적용
            self._apply_physics()
            return
        
        # 기본 대사 랜덤 표시 (0.2% 확률, 혼자서도 말함)
        if random.random() < 0.002 and self.bubble_timer == 0:
            # 이모티콘 fallback
            solo_emojis = ["😊", "✨", "💭", "🎵", "😌", "🌸", "💫", "🍀"]
            
            # 캐시된 AI 대사가 있으면 API 꺼져도 표시
            ai_dialogue = get_cached_dialogue(self.char_id, 'solo') if getattr(self, 'personality', '') else None
            
            # AI 대사만 사용 (수동 대사는 말투 참고용으로만 사용)
            all_dialogues = []
            if ai_dialogue:
                all_dialogues.append(ai_dialogue)
            
            if all_dialogues:
                self.speech_bubble = random.choice(all_dialogues)
                self.bubble_timer = 120
            else:
                # 이모티콘
                self.speech_bubble = random.choice(solo_emojis)
                self.bubble_timer = 90
        
        # 시간/계절 대사 타이머 (1시간마다 체크)
        self.time_dialogue_timer += 1
        if self.time_dialogue_timer > 108000:  # 1시간마다 체크 (30fps * 60 * 60)
            if random.random() < 0.85 and self.bubble_timer == 0 and self.personality:
                try:
                    from datetime import datetime
                    current_time = datetime.now()
                    current_period = get_time_period(current_time.hour)
                    
                    # 1. 먼저 기존 시간대 대사가 있는지 확인
                    existing_dialogue = get_temp_dialogue(self.char_id, 'time', current_period)
                    
                    if existing_dialogue:
                        # 기존 대사 사용 (API 꺼져도 가능)
                        self.speech_bubble = existing_dialogue
                        self.bubble_timer = 120
                        print(f"[AI] 기존 시간대 대사 사용 ({current_period}): {existing_dialogue}")
                    elif is_ai_enabled():
                        # API 켜져있으면 새 대사 생성
                        def on_time_dialogue(dialogue):
                            if dialogue and self.bubble_timer == 0:
                                self.speech_bubble = dialogue
                                self.bubble_timer = 120
                        
                        generate_time_weather_dialogue(
                            self.char_id,
                            self.char_name,
                            self.personality,
                            current_time,
                            None,
                            on_time_dialogue
                        )
                except Exception as e:
                    print(f"[오류] 시간 대사 처리 오류: {e}")
            self.time_dialogue_timer = 0
            self.check_time_status()  # 시간 상태 업데이트
        
        x = self.x()
        y = self.y()
        
        # 창 위에서 활동 체크
        self.check_window_position()
        
        # 상태 전환 (걷기 <-> 멈춤)
        self.state_timer -= 1
        if self.state_timer <= 0:
            self.is_moving = not self.is_moving
            if self.is_moving:
                # 졸림 모드면 속도 느리게
                if hasattr(self, 'sleepy_mode') and self.sleepy_mode:
                    self.velocity_x = random.choice([-0.8, -0.6, 0.6, 0.8])
                else:
                    self.velocity_x = random.choice([-2, -1.5, 1.5, 2])
                self.state_timer = random.randint(60, 180)
            else:
                self.velocity_x = 0
                self.state_timer = random.randint(30, 90)
        
        # 점프 쿨다운
        if self.jump_cooldown > 0:
            self.jump_cooldown -= 1
        
        # 자동 점프 (바닥에 있고 움직이고 있을 때)
        if self.on_ground and self.is_moving and self.jump_cooldown == 0:
            if random.random() < 0.05:
                self.velocity_y = self.jump_power
                self.is_jumping = True
                self.on_ground = False
            self.jump_cooldown = random.randint(30, 60)
        
        # 중력 적용
        if not self.on_ground:
            self.velocity_y += self.gravity
        
        # 새 위치 계산
        new_x = x + self.velocity_x
        new_y = y + self.velocity_y
        
        # 좌우 벽 충돌 (멀티모니터 고려)
        screen_left = getattr(self, 'screen_x', 0)
        screen_right = screen_left + self.screen_width - self.width()
        if new_x <= screen_left or new_x >= screen_right:
            self.velocity_x = -self.velocity_x
            new_x = max(screen_left, min(new_x, screen_right))
        
        # 바닥 또는 윈도우 창 위 충돌
        # 현재 위치의 모니터에 맞는 ground_level 동적 계산
        ground = self.get_current_ground_level(new_x)
        
        # 낙하 중이면 윈도우 위 착지 감지
        if self.velocity_y > 0 and not self.on_window:
            window_top = self.detect_window_below(new_x, new_y)
            if window_top is not None and new_y >= window_top:
                # 윈도우 위에 착지
                self.on_window = True
                self.window_top = window_top
                ground = window_top
        
        if self.on_window:
            ground = self.window_top
        
        if new_y >= ground:
            new_y = ground
            self.velocity_y = 0
            self.on_ground = True
            self.is_jumping = False
        else:
            self.on_ground = False
        
        # 방향 업데이트 (이벤트 중에는 방향 유지 - 마주보기)
        if not self.in_event:
            if self.velocity_x > 0:
                self.facing_right = True
            elif self.velocity_x < 0:
                self.facing_right = False
        
        self.move(int(new_x), int(new_y))
        
        # 말풍선 타이머
        if self.bubble_timer > 0:
            self.bubble_timer -= 1
            if self.bubble_timer == 0:
                self.speech_bubble = None
        
        # 상호작용 쿨다운
        if self.interaction_cooldown > 0:
            self.interaction_cooldown -= 1
        
        self.update()
    
    def _apply_physics(self):
        """물리 적용 (이벤트 중에도 중력, 충돌 처리)"""
        x = self.x()
        y = self.y()
        
        # 중력 적용
        if not self.on_ground:
            self.velocity_y += self.gravity
            self.velocity_y = min(self.velocity_y, self.max_fall_speed)
        
        # 새 위치 계산
        new_x = x + self.velocity_x
        new_y = y + self.velocity_y
        
        # 이벤트 중 파트너와 최소 거리 유지
        if self.in_event and self.event_partner:
            partner = self.event_partner
            
            # 애정 관련 이벤트는 더 가깝게 허용
            if self.event_type in ['hug', 'heart', 'blush']:
                min_distance = self.size * 0.35  # 포옹/하트는 아주 가깝게
            elif self.event_type == 'dance' and self.event_data.get('relationship') == '연인':
                min_distance = self.size * 0.45  # 연인 춤도 가깝게
            else:
                min_distance = self.size * 0.6  # 기본 거리
            
            dx = new_x - partner.x()
            distance = abs(dx)
            
            if distance < min_distance:
                # 너무 가까우면 밀어내기
                push = (min_distance - distance) / 2
                if dx > 0:
                    new_x += push
                else:
                    new_x -= push
        
        # 좌우 벽 충돌 (멀티모니터 고려)
        screen_left = getattr(self, 'screen_x', 0)
        screen_right = screen_left + self.screen_width - self.width()
        if new_x <= screen_left or new_x >= screen_right:
            self.velocity_x = 0
            new_x = max(screen_left, min(new_x, screen_right))
        
        # 바닥 충돌 - 현재 위치의 모니터에 맞는 ground_level 동적 계산
        ground = self.get_current_ground_level(new_x)
        if self.on_window:
            ground = self.window_top
        
        if new_y >= ground:
            new_y = ground
            self.velocity_y = 0
            self.on_ground = True
            self.is_jumping = False
        else:
            self.on_ground = False
        
        # 방향 업데이트 (이벤트 중에는 방향 유지 - 마주보기)
        if not self.in_event:
            if self.velocity_x > 0:
                self.facing_right = True
            elif self.velocity_x < 0:
                self.facing_right = False
        
        self.move(int(new_x), int(new_y))
        
        # 말풍선 타이머
        if self.bubble_timer > 0:
            self.bubble_timer -= 1
            if self.bubble_timer == 0:
                self.speech_bubble = None
        
        # 상호작용 쿨다운
        if self.interaction_cooldown > 0:
            self.interaction_cooldown -= 1
        
        self.update()
    
    def apply_gravity_only(self):
        """중력만 적용 (이벤트 중에도 땅에 붙어있게)"""
        screen = QApplication.primaryScreen().geometry()
        ground = screen.height() - self.height() - 50
        
        y = self.y()
        
        if not self.on_ground:
            self.velocity_y += self.gravity
            self.velocity_y = min(self.velocity_y, self.max_fall_speed)
            y += self.velocity_y
        
        if y >= ground:
            y = ground
            self.velocity_y = 0
            self.on_ground = True
        
        self.move(self.x(), int(y))
        
        # 말풍선 타이머
        if self.bubble_timer > 0:
            self.bubble_timer -= 1
            if self.bubble_timer == 0:
                self.speech_bubble = None
        
        self.update()
    
    def check_window_position(self):
        """창 위에 있는지 확인하고 자동으로 떨어지기"""
        # 윈도우 위에 있다가 가장자리를 벗어나면 떨어지기
        if self.on_window:
            # 현재 위치에서 윈도우가 여전히 있는지 확인
            window_top = self.detect_window_below(self.x(), self.y())
            if window_top is None or abs(window_top - self.window_top) > 10:
                # 윈도우가 없거나 이동했으면 떨어지기
                self.on_window = False
                self.window_top = 0
                self.on_ground = False
    
    def detect_window_below(self, x, y):
        """현재 위치 아래에 윈도우가 있는지 감지"""
        if not _win32_available:
            return None
        
        try:
            windows = []
            
            def enum_callback(hwnd, results):
                if win32gui.IsWindowVisible(hwnd):
                    rect = win32gui.GetWindowRect(hwnd)
                    # rect = (left, top, right, bottom)
                    if rect[2] - rect[0] > 100 and rect[3] - rect[1] > 50:  # 최소 크기 필터
                        results.append((hwnd, rect))
                return True
            
            win32gui.EnumWindows(enum_callback, windows)
            
            # 캐릭터 위치 기준으로 아래에 있는 윈도우 찾기
            char_center_x = x + self.width() // 2
            char_bottom = y + self.height()
            
            best_window_top = None
            
            for hwnd, rect in windows:
                left, top, right, bottom = rect
                # 캐릭터가 윈도우의 x 범위 안에 있고, 윈도우 상단이 캐릭터 아래에 있을 때
                if left < char_center_x < right:
                    if top > char_bottom and top < self.ground_level:
                        if best_window_top is None or top < best_window_top:
                            best_window_top = top - self.height()  # 캐릭터 발 위치
            
            return best_window_top
        except:
            return None
    
    def mousePressEvent(self, event):
        """클릭 이벤트"""
        if event.button() == Qt.LeftButton:
            self.was_clicked = True
            self.dragging = False
            self.drag_start_pos = event.globalPos()
            self.drag_start_widget_pos = self.pos()
    
    def mouseMoveEvent(self, event):
        """드래그 이벤트"""
        if self.was_clicked and self.drag_start_pos:
            delta = event.globalPos() - self.drag_start_pos
            if delta.manhattanLength() > 5:  # 5픽셀 이상 이동하면 드래그로 간주
                self.dragging = True
                new_pos = self.drag_start_widget_pos + delta
                self.move(new_pos)
    
    def mouseReleaseEvent(self, event):
        """마우스 릴리즈 이벤트"""
        if event.button() == Qt.LeftButton:
            
            if self.dragging:
                # 드래그 종료 - 그냥 떨어지게
                self.dragging = False
                self.on_ground = False  # 낙하 시작
                self.velocity_y = 2  # 약간의 초기 낙하 속도
                self.on_window = False
                self.window_top = 0
            elif self.was_clicked:
                # 단순 클릭 - 혼잣말 대사 출력
                all_dialogues = []
                
                # AI 대사 수집
                if self.personality:
                    ai_dialogue = get_cached_dialogue(self.char_id, 'solo')
                    if ai_dialogue:
                        all_dialogues.append(ai_dialogue)
                
                # 수동 대사는 말투 참고용으로만 사용 (출력 안 함)
                
                # 대사 선택
                if all_dialogues:
                    dialogue = random.choice(all_dialogues)
                else:
                    # 이모티콘
                    reactions = ["❤️", "💕", "❗", "❓", "😊", "✨", "💫", "🎵"]
                    dialogue = random.choice(reactions)
                
                self.speech_bubble = dialogue
                self.bubble_timer = 90  # 3초
                
                # 클릭하면 점프
                if self.on_ground:
                    self.velocity_y = self.jump_power * 0.8
                    self.is_jumping = True
                    self.on_ground = False
                self.update()
            
            self.was_clicked = False
            self.drag_start_pos = None
    
    def check_collision_with(self, other_char):
        """다른 캐릭터와의 충돌 체크"""
        # 드래그 중이면 충돌 무시
        if self.dragging or other_char.dragging:
            return False
        
        if self.interaction_cooldown > 0 or other_char.interaction_cooldown > 0:
            return False
        
        distance = math.sqrt((self.x() - other_char.x())**2 + 
                           (self.y() - other_char.y())**2)
        
        if distance < self.size * 0.8:
            return True
        return False
    
    def interact_with(self, other_char):
        """다른 캐릭터와 상호작용 - 감정 기반 시스템"""
        if self.interaction_cooldown > 0 or other_char.interaction_cooldown > 0:
            return
        
        # 이미 이벤트 중이면 무시
        if self.in_event or other_char.in_event:
            return
        
        # 각자의 감정 확인 (새 시스템: 각 캐릭터가 상대에게 느끼는 감정)
        try:
            my_feeling = self.relationships.get(other_char.char_id, "무관심") if isinstance(self.relationships, dict) else "무관심"
            their_feeling = other_char.relationships.get(self.char_id, "무관심") if isinstance(other_char.relationships, dict) else "무관심"
            # 문자열이 아니면 기본값
            if not isinstance(my_feeling, str):
                my_feeling = "무관심"
            if not isinstance(their_feeling, str):
                their_feeling = "무관심"
        except Exception as e:
            print(f"[interact_with] 감정 확인 오류: {e}")
            my_feeling = "무관심"
            their_feeling = "무관심"
        
        # 50% 대사, 50% 이벤트 (이모티콘) - 5:5 비율
        use_dialogue = random.random() < 0.5
        
        # 캐시된 대사가 있으면 대사 상호작용 (API 꺼져도)
        has_cached_dialogue = (self.personality and get_cached_dialogue(self.char_id, 'interaction', other_char.char_id, other_char.char_name)) or \
                              (other_char.personality and get_cached_dialogue(other_char.char_id, 'interaction', self.char_id, self.char_name))
        
        if use_dialogue and has_cached_dialogue:
            # 대사 상호작용 (이벤트 없이 대사만)
            self.dialogue_interaction(other_char, my_feeling, their_feeling)
        else:
            # 이벤트 상호작용 (이모티콘만)
            if random.random() < 0.7:
                self.short_interaction(other_char, my_feeling, their_feeling)
            else:
                # 바닥에 있을 때만 긴 이벤트 시작
                if self.on_ground and other_char.on_ground:
                    self.start_long_event(other_char, my_feeling, their_feeling)
                else:
                    self.short_interaction(other_char, my_feeling, their_feeling)
    
    def dialogue_interaction(self, other_char, my_feeling, their_feeling):
        """대사 상호작용 - AI 대사와 수동 대사 표시"""
        my_dialogues = []
        other_dialogues = []
        
        # 내 대사 수집
        if self.personality:
            ai_dialogue = get_cached_dialogue(self.char_id, 'interaction', other_char.char_id, other_char.char_name)
            if ai_dialogue:
                my_dialogues.append(ai_dialogue)
        # 수동 대사는 말투 참고용으로만 사용 (출력 안 함)
        
        # 상대 대사 수집
        if other_char.personality:
            ai_dialogue = get_cached_dialogue(other_char.char_id, 'interaction', self.char_id, self.char_name)
            if ai_dialogue:
                other_dialogues.append(ai_dialogue)
        # 상대 수동 대사도 말투 참고용으로만 사용 (출력 안 함)
        
        # 대사가 하나라도 있으면 표시
        if my_dialogues or other_dialogues:
            if my_dialogues:
                self.speech_bubble = random.choice(my_dialogues)
                self.bubble_timer = random.randint(120, 180)
            if other_dialogues:
                other_char.speech_bubble = random.choice(other_dialogues)
                other_char.bubble_timer = random.randint(120, 180)
            
            # 쿨다운
            self.interaction_cooldown = 120
            other_char.interaction_cooldown = 120
            
            # 마주보기
            if self.x() < other_char.x():
                self.facing_right = True
                other_char.facing_right = False
            else:
                self.facing_right = False
                other_char.facing_right = True
        else:
            # 대사 없으면 이벤트로 대체
            self.short_interaction(other_char, my_feeling, their_feeling)
    
    def short_interaction(self, other_char, my_feeling, their_feeling):
        """짧은 상호작용 - 감정 기반 이모티콘 표시"""
        
        # 감정별 이모티콘 정의 (11가지 감정 x 12개) - 깨지는 이모티콘 대체됨
        feeling_emojis = {
            "사랑": ['💕', '🥰', '💖', '😍', '💗', '☺️', '💘', '❤️', '💝', '😊', '✨', '💓'],
            "우정": ['🤝', '😊', '🙌', '👋', '✨', '💫', '😄', '👍', '🎉', '😁', '🤗', '👊'],
            "동경": ['✨', '🤩', '🌟', '👏', '😊', '🙏', '⭐', '💫', '🤍', '😌', '🙏', '🏅'],
            "신뢰": ['🤗', '🤝', '💖', '😊', '✨', '💪', '👍', '😌', '🙏', '🙂', '👐', '🤍'],
            "장난": ['😜', '🤭', '😝', '🤪', '😏', '👻', '🎉', '😆', '🎭', '😈', '👅', '🤡'],
            "경쟁심": ['🔥', '💪', '😤', '⚡', '🏆', '💥', '😎', '🥇', '👊', '🎯', '⭐', '🏅'],
            "짜증": ['😤', '💢', '😒', '🙄', '😑', '💦', '😠', '😩', '😫', '🙁', '😩', '🤦'],
            "질투": ['😒', '🔥', '😤', '💢', '😠', '👀', '⚡', '😡', '🤨', '💥', '😾', '👁️'],
            "증오": ['😤', '💢', '😠', '👿', '😡', '🔥', '⚡', '💀', '💥', '🖤', '☠️', '👊'],
            "어색": ['😶', '😅', '💦', '🤔', '😬', '😐', '❓', '😳', '👀', '😳', '😅', '🙃'],
            "무관심": ['😐', '🙄', '😑', '💭', '😶', '🤷', '💤', '🥱', '😴', '😶', '😐', '😪']
        }
        
        # 각자의 이모티콘 선택
        my_emoji = random.choice(feeling_emojis.get(my_feeling, ['😐']))
        other_emoji = random.choice(feeling_emojis.get(their_feeling, ['😐']))
        
        # 점프 확률 (감정별로 다르게)
        jump_probs = {
            "사랑": 0.2, "우정": 0.3, "동경": 0.1, "신뢰": 0.2,
            "장난": 0.5, "경쟁심": 0.5, "짜증": 0.3, "질투": 0.4, "증오": 0.4,
            "어색": 0.1, "무관심": 0.0
        }
        my_jump = jump_probs.get(my_feeling, 0.1)
        other_jump = jump_probs.get(their_feeling, 0.1)
        
        # 이모티콘 표시
        self.speech_bubble = my_emoji
        other_char.speech_bubble = other_emoji
        self.bubble_timer = random.randint(60, 120)
        other_char.bubble_timer = random.randint(60, 120)
        
        # 쿨다운
        self.interaction_cooldown = 90
        other_char.interaction_cooldown = 90
        
        # 밀어내기 강도 (감정별로 다르게)
        push_strengths = {
            "사랑": 0.8, "우정": 1.2, "동경": 1.0, "신뢰": 1.0,
            "장난": 2.0, "경쟁심": 2.5, "짜증": 2.0, "질투": 2.0, "증오": 2.5,
            "어색": 1.5, "무관심": 1.5
        }
        dx = self.x() - other_char.x()
        my_push = push_strengths.get(my_feeling, 1.5)
        other_push = push_strengths.get(their_feeling, 1.5)
        
        if dx > 0:
            self.velocity_x = my_push
            other_char.velocity_x = -other_push
        else:
            self.velocity_x = -my_push
            other_char.velocity_x = other_push
        
        # 점프
        if random.random() < my_jump and self.on_ground:
            self.velocity_y = self.jump_power * 0.3
            self.on_ground = False
        if random.random() < other_jump and other_char.on_ground:
            other_char.velocity_y = other_char.jump_power * 0.3
            other_char.on_ground = False
    
    def start_long_event(self, other_char, my_feeling, their_feeling):
        """긴 이벤트 시작 - 감정 기반 시스템"""
        
        # 감정별 이모티콘 시퀀스 정의 (12개씩) - 깨지는 이모티콘 대체됨
        feeling_sequences = {
            "사랑": ['💕', '🥰', '💖', '😍', '💗', '☺️', '💝', '✨', '💓', '❤️', '😊', '💘'],
            "우정": ['🤝', '😊', '🙌', '👋', '✨', '💫', '😄', '🎉', '👍', '😁', '🤗', '👊'],
            "동경": ['✨', '🤩', '🌟', '👏', '😊', '🙏', '💫', '⭐', '🤍', '😌', '🙏', '🏅'],
            "신뢰": ['🤗', '🤝', '💖', '😊', '✨', '💪', '👍', '😌', '🙏', '🙂', '👐', '🤍'],
            "장난": ['😜', '🤭', '😝', '🤪', '😏', '👻', '🎭', '😆', '🎉', '😈', '👅', '🤡'],
            "경쟁심": ['🔥', '💪', '😤', '⚡', '🏆', '💥', '😎', '🥇', '👊', '🎯', '⭐', '🏅'],
            "짜증": ['😤', '💢', '😒', '🙄', '😑', '💦', '😫', '💢', '😩', '🙁', '😩', '🤦'],
            "질투": ['😒', '🔥', '😤', '💢', '😠', '👀', '😑', '⚡', '🤨', '💥', '😾', '👁️'],
            "증오": ['😤', '💢', '😠', '👿', '😡', '🔥', '⚡', '💀', '💥', '🖤', '☠️', '👊'],
            "어색": ['😶', '😅', '💦', '🤔', '😬', '...', '👀', '😳', '😅', '🙃', '😐', '❓'],
            "무관심": ['😐', '🙄', '...', '😑', '💭', '😶', '💤', '...', '🥱', '😴', '😶', '🤷']
        }
        
        # 감정 조합에 따른 이벤트 타입과 지속 시간 결정
        # 같은 감정끼리의 조합 (이모티콘 시퀀스 10개)
        same_feeling_events = {
            ("사랑", "사랑"): ('love_dance', 210, ['💕', '🎵', '💃', '🕺', '💖', '✨', '🎶', '💝', '❤️', '🥰']),
            ("우정", "우정"): ('friend_dance', 180, ['🎵', '💃', '🕺', '✨', '🎶', '⭐', '🤝', '🙌', '😄', '🎉']),
            ("동경", "동경"): ('mutual_respect', 150, ['✨', '🌟', '👏', '⭐', '💫', '🤩', '🙏', '🏅', '😊', '🤍']),
            ("신뢰", "신뢰"): ('partner_bond', 150, ['🤝', '💪', '✨', '👊', '🔥', '🙏', '👍', '😌', '🤍', '🤗']),
            ("장난", "장난"): ('play_together', 180, ['😜', '🤪', '😝', '👻', '🎉', '😆', '🎭', '😈', '👅', '🤡']),
            ("경쟁심", "경쟁심"): ('compete_battle', 180, ['🔥', '💪', '⚡', '🏆', '💥', '😤', '🥇', '👊', '🎯', '🏅']),
            ("짜증", "짜증"): ('mutual_annoy', 120, ['😤', '💢', '😒', '🙄', '😑', '😫', '😩', '🤦', '😩', '💦']),
            ("질투", "질투"): ('rival_battle', 180, ['🔥', '😤', '⚡', '💢', '💥', '😠', '👀', '🤨', '😾', '👁️']),
            ("증오", "증오"): ('enemy_fight', 180, ['😡', '💢', '😠', '💢', '😤', '👿', '💀', '☠️', '💥', '🖤']),
            ("어색", "어색"): ('awkward_meet', 90, ['😶', '...', '👀', '😳', '😅', '😅', '😬', '🙃', '❓', '💦']),
            ("무관심", "무관심"): ('ignore_each', 60, ['😐', '...', '🙄', '💤', '🥱', '😴', '😑', '😶', '🤷', '💭'])
        }
        
        # 비대칭 감정 조합 (각 감정별 이벤트 최소 6개)
        asymmetric_events = {
            # 사랑 관련 (6개)
            ("사랑", "증오"): ('unrequited_love', 150),
            ("사랑", "무관심"): ('one_sided_love', 120),
            ("사랑", "어색"): ('shy_love', 120),
            ("사랑", "우정"): ('friend_crush', 150),
            ("사랑", "질투"): ('passionate_love', 150),
            ("사랑", "경쟁심"): ('love_rivalry', 150),
            
            # 우정 관련 (6개)
            ("우정", "사랑"): ('friend_zone', 150),
            ("우정", "무관심"): ('trying_to_befriend', 120),
            ("우정", "짜증"): ('annoying_friend', 120),
            ("우정", "경쟁심"): ('friendly_competition', 150),
            ("우정", "어색"): ('new_friendship', 120),
            ("우정", "증오"): ('broken_friendship', 120),
            
            # 동경 관련 (6개)
            ("동경", "무관심"): ('one_sided_admire', 120),
            ("동경", "질투"): ('envied_idol', 150),
            ("동경", "사랑"): ('admire_to_love', 150),
            ("동경", "우정"): ('fan_meeting', 120),
            ("동경", "경쟁심"): ('aspiring_rival', 150),
            ("동경", "신뢰"): ('mentor_admire', 120),
            
            # 신뢰 관련 (6개)
            ("신뢰", "사랑"): ('trusted_love', 150),
            ("신뢰", "우정"): ('reliable_friend', 120),
            ("신뢰", "무관심"): ('unnoticed_trust', 90),
            ("신뢰", "어색"): ('building_trust', 120),
            ("신뢰", "경쟁심"): ('trusted_rival', 150),
            ("신뢰", "짜증"): ('testing_patience', 120),
            
            # 장난 관련 (6개)
            ("장난", "짜증"): ('teasing', 150),
            ("장난", "증오"): ('bullying', 120),
            ("장난", "어색"): ('awkward_prank', 90),
            ("장난", "우정"): ('playful_friend', 150),
            ("장난", "사랑"): ('flirty_tease', 150),
            ("장난", "무관심"): ('ignored_prank', 90),
            
            # 경쟁심 관련 (6개)
            ("경쟁심", "사랑"): ('competitive_crush', 150),
            ("경쟁심", "우정"): ('rival_friendship', 150),
            ("경쟁심", "질투"): ('intense_rivalry', 180),
            ("경쟁심", "무관심"): ('one_sided_rival', 120),
            ("경쟁심", "동경"): ('competitive_admire', 150),
            ("경쟁심", "증오"): ('bitter_rival', 180),
            
            # 짜증 관련 (6개)
            ("짜증", "사랑"): ('annoyed_by_love', 120),
            ("짜증", "우정"): ('annoyed_friend', 120),
            ("짜증", "장난"): ('annoyed_by_prank', 120),
            ("짜증", "무관심"): ('mutual_disinterest', 90),
            ("짜증", "경쟁심"): ('frustrated_rival', 150),
            ("짜증", "신뢰"): ('testing_trust', 120),
            
            # 질투 관련 (6개)
            ("질투", "사랑"): ('jealous_lover', 150),
            ("질투", "동경"): ('envious_admirer', 150),
            ("질투", "무관심"): ('ignored_rival', 120),
            ("질투", "우정"): ('jealous_friend', 150),
            ("질투", "경쟁심"): ('envious_competitor', 180),
            ("질투", "증오"): ('hateful_envy', 180),
            
            # 증오 관련 (6개)
            ("증오", "사랑"): ('rejecting_love', 150),
            ("증오", "우정"): ('hostile_friend', 120),
            ("증오", "무관심"): ('ignored_enemy', 90),
            ("증오", "장난"): ('hate_pranks', 120),
            ("증오", "경쟁심"): ('hateful_rival', 180),
            ("증오", "질투"): ('mutual_hatred', 180),
            
            # 어색 관련 (6개)
            ("어색", "사랑"): ('shy_crush', 120),
            ("어색", "우정"): ('awkward_friend', 90),
            ("어색", "장난"): ('confused_by_prank', 90),
            ("어색", "무관심"): ('mutual_awkward', 60),
            ("어색", "신뢰"): ('hesitant_trust', 90),
            ("어색", "경쟁심"): ('awkward_rival', 90),
            
            # 무관심 관련 (6개)
            ("무관심", "사랑"): ('cold_response', 90),
            ("무관심", "우정"): ('distant_friend', 90),
            ("무관심", "질투"): ('unbothered', 60),
            ("무관심", "증오"): ('apathetic', 60),
            ("무관심", "경쟁심"): ('uninterested_rival', 60),
            ("무관심", "장난"): ('ignoring_prank', 60),
        }
        
        # 이벤트 정보 결정
        feeling_pair = (my_feeling, their_feeling)
        reverse_pair = (their_feeling, my_feeling)
        
        if feeling_pair in same_feeling_events:
            event_type, duration, emojis = same_feeling_events[feeling_pair]
            is_asymmetric = False
        elif feeling_pair in asymmetric_events:
            event_type, duration = asymmetric_events[feeling_pair]
            emojis = feeling_sequences.get(my_feeling, ['😐'])
            is_asymmetric = True
        elif reverse_pair in asymmetric_events:
            event_type, duration = asymmetric_events[reverse_pair]
            emojis = feeling_sequences.get(my_feeling, ['😐'])
            is_asymmetric = True
        else:
            # 기본 이벤트
            event_type = 'interaction'
            duration = 120
            emojis = feeling_sequences.get(my_feeling, ['😐'])
            is_asymmetric = True
        
        print(f"[긴 이벤트] {event_type} 시작 ({self.char_id}:{my_feeling} ↔ {other_char.char_id}:{their_feeling})")
        
        # 각 캐릭터의 이모티콘 시퀀스 설정
        my_emojis = emojis if not is_asymmetric else feeling_sequences.get(my_feeling, ['😐'])
        other_emojis = emojis if not is_asymmetric else feeling_sequences.get(their_feeling, ['😐'])
        
        # 둘 다 이벤트 상태로
        self.in_event = True
        self.event_type = event_type
        self.event_partner = other_char
        self.event_frame = 0
        self.event_duration = duration
        self.event_data = {
            'emojis': my_emojis,
            'my_feeling': my_feeling,
            'their_feeling': their_feeling,
            'is_asymmetric': is_asymmetric
        }
        
        other_char.in_event = True
        other_char.event_type = event_type
        other_char.event_partner = self
        other_char.event_frame = 0
        other_char.event_duration = duration
        other_char.event_data = {
            'emojis': other_emojis,
            'my_feeling': their_feeling,
            'their_feeling': my_feeling,
            'is_asymmetric': is_asymmetric
        }
        
        # 쿨다운 설정 (이벤트 끝나고 적용)
        self.interaction_cooldown = duration + 150
        other_char.interaction_cooldown = duration + 150
        
        # 이동 멈춤
        self.velocity_x = 0
        other_char.velocity_x = 0
        
        # 마주보게
        if self.x() < other_char.x():
            self.facing_right = True
            other_char.facing_right = False
        else:
            self.facing_right = False
            other_char.facing_right = True
        
        # 첫 이모티콘
        self.speech_bubble = random.choice(my_emojis)
        other_char.speech_bubble = random.choice(other_emojis)
        self.bubble_timer = 60
        other_char.bubble_timer = 60
    
    def update_long_event(self):
        """긴 이벤트 업데이트 (매 프레임 호출) - 풍부한 모션"""
        if not self.in_event or not self.event_partner:
            return
        
        self.event_frame += 1
        partner = self.event_partner
        emojis = self.event_data.get('emojis', ['✨'])
        event_type = self.event_type
        duration = self.event_duration
        
        # 이모티콘 업데이트 헬퍼
        def update_emoji(interval=30):
            if self.event_frame % interval == 0:
                idx = (self.event_frame // interval) % len(emojis)
                self.speech_bubble = emojis[idx]
                self.bubble_timer = interval + 10
        
        # ========== 춤 이벤트 (가장 화려하게) ==========
        if event_type == 'dance' or event_type == 'love_dance' or event_type == 'friend_dance':
            update_emoji(25)
            relationship = self.event_data.get('relationship', '')
            # love_dance는 연인 춤으로 처리
            if event_type == 'love_dance':
                relationship = '연인'
            
            # 페이즈별 모션
            phase = self.event_frame % 90  # 3초 주기
            
            if phase < 15:
                # 좌우로 흔들기 (왼쪽)
                self.velocity_x = -1.5
            elif phase < 30:
                # 좌우로 흔들기 (오른쪽)
                self.velocity_x = 1.5
            elif phase < 45:
                # 점프!
                if self.on_ground:
                    self.velocity_y = self.jump_power * 0.5
                    self.on_ground = False
                self.velocity_x = 0
            elif phase < 60:
                # 다시 좌우 (오른쪽)
                self.velocity_x = 1.5
            elif phase < 75:
                # 다시 좌우 (왼쪽)
                self.velocity_x = -1.5
            else:
                # 제자리
                self.velocity_x = 0
                # 작은 점프
                if self.on_ground and phase == 80:
                    self.velocity_y = self.jump_power * 0.3
                    self.on_ground = False
            
            # 연인일 때 가끔 서로 가까워지기
            if relationship == '연인' and partner:
                dx = partner.x() - self.x()
                close_phase = self.event_frame % 120
                if 90 < close_phase < 110:
                    # 가까이 다가가기
                    if abs(dx) > self.size * 0.5:
                        self.velocity_x = 0.8 if dx > 0 else -0.8
            
            # 마지막에 동시 큰 점프
            if self.event_frame == duration - 30 and self.on_ground:
                self.velocity_y = self.jump_power * 0.7
                self.on_ground = False
                self.speech_bubble = '✨'
                self.bubble_timer = 40
        
        # ========== 하이파이브/주먹 인사 ==========
        elif event_type == 'high_five' or event_type == 'fist_bump':
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                if self.event_frame < 25:
                    # 1단계: 다가가기 (최소 거리까지만)
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.5 if dx > 0 else -1.5
                    else:
                        self.velocity_x = 0
                elif self.event_frame < 35:
                    # 2단계: 점프하며 터치!
                    self.velocity_x = 0
                    if self.event_frame == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.6
                        self.on_ground = False
                        self.speech_bubble = '🙌' if event_type == 'high_five' else '👊'
                        self.bubble_timer = 40
                elif self.event_frame < 60:
                    # 3단계: 물러나기
                    self.velocity_x = -1.2 if dx > 0 else 1.2
                else:
                    # 4단계: 마무리 (서로 마주보고 작은 점프)
                    self.velocity_x = 0
                    if self.event_frame == 70 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
        
        # ========== 수다 ==========
        elif event_type == 'chat':
            update_emoji(35)
            
            # 가끔 고개 끄덕이듯 작은 점프
            if self.event_frame % 50 == 0 and random.random() < 0.4 and self.on_ground:
                self.velocity_y = self.jump_power * 0.2
                self.on_ground = False
            
            # 가끔 좌우로 살짝 움직임
            if self.event_frame % 40 == 0:
                self.velocity_x = random.choice([-0.5, 0, 0.5])
            elif self.event_frame % 40 == 20:
                self.velocity_x = 0
        
        # ========== 같이 점프 ==========
        elif event_type == 'jump_together':
            update_emoji(30)
            
            # 동시에 점프 (파트너와 싱크)
            if self.event_frame % 35 == 0 and self.on_ground:
                self.velocity_y = self.jump_power * 0.6
                self.on_ground = False
            
            # 점프 사이에 살짝 다가갔다 멀어졌다
            phase = self.event_frame % 70
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                if phase < 20:
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.8 if dx > 0 else -0.8
                    else:
                        self.velocity_x = 0
                elif phase < 40:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    self.velocity_x = 0
        
        # ========== 하트/수줍 ==========
        elif event_type == 'heart' or event_type == 'blush':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                close_dist = self.size * 0.5  # 더 가까운 거리
                
                # 천천히 다가갔다 수줍게 물러남, 가끔 더 가까이
                cycle = self.event_frame % 100
                if cycle < 35:
                    # 살짝 다가가기
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.6 if dx > 0 else -0.6
                    else:
                        self.velocity_x = 0
                elif cycle < 50:
                    # 더 가까이 다가가기 (설레는 순간)
                    if abs(dx) > close_dist:
                        self.velocity_x = 0.3 if dx > 0 else -0.3
                    else:
                        self.velocity_x = 0
                    if cycle == 45 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.15  # 설레는 작은 점프
                        self.on_ground = False
                elif cycle < 70:
                    # 수줍게 물러나기
                    self.velocity_x = -0.4 if dx > 0 else 0.4
                else:
                    self.velocity_x = 0
                    # 설레는 작은 점프
                    if cycle == 85 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.2
                        self.on_ground = False
        
        # ========== 포옹 ==========
        elif event_type == 'hug':
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.6  # 포옹은 더 가깝게
                close_dist = self.size * 0.4  # 아주 가깝게
                
                if self.event_frame < 40:
                    # 1단계: 다가가기
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                    else:
                        self.velocity_x = 0
                elif self.event_frame < 60:
                    # 2단계: 더 가까이 (포옹)
                    if abs(dx) > close_dist:
                        self.velocity_x = 0.5 if dx > 0 else -0.5
                    else:
                        self.velocity_x = 0
                elif self.event_frame < duration - 30:
                    # 3단계: 가까이 유지하며 행복
                    self.velocity_x = 0
                    if abs(dx) > close_dist + 5:
                        self.velocity_x = 0.2 if dx > 0 else -0.2
                    # 가끔 행복한 작은 점프
                    if self.event_frame % 45 == 0 and random.random() < 0.4 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.12
                        self.on_ground = False
                else:
                    # 4단계: 살짝 물러나기
                    self.velocity_x = -0.5 if dx > 0 else 0.5
        
        # ========== 응원/훈련 ==========
        elif event_type == 'cheer' or event_type == 'training':
            update_emoji(25)
            
            # 힘찬 점프 + 좌우 움직임
            phase = self.event_frame % 50
            if phase < 15:
                self.velocity_x = -1.0
            elif phase < 30:
                self.velocity_x = 1.0
            else:
                self.velocity_x = 0
                if phase == 35 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.55
                    self.on_ground = False
        
        # ========== 배틀 ==========
        elif event_type == 'battle':
            update_emoji(20)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 공격적인 움직임
                phase = self.event_frame % 60
                if phase < 20:
                    # 돌진! (최소 거리까지만)
                    if abs(dx) > min_dist:
                        self.velocity_x = 2.0 if dx > 0 else -2.0
                    else:
                        self.velocity_x = 0
                    if phase == 15 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 40:
                    # 물러나기
                    self.velocity_x = -1.5 if dx > 0 else 1.5
                else:
                    # 대기
                    self.velocity_x = 0
                    if phase == 50 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
        
        # ========== 경주 ==========
        elif event_type == 'race':
            update_emoji(20)
            
            if partner:
                # 같은 방향으로 달리기!
                if 'race_direction' not in self.event_data:
                    self.event_data['race_direction'] = random.choice([-1, 1])
                
                direction = self.event_data['race_direction']
                
                if self.event_frame < duration - 40:
                    # 달리기
                    self.velocity_x = 2.5 * direction
                    
                    # 달리면서 점프
                    if self.event_frame % 25 == 0 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                    
                    # 벽에 닿으면 방향 전환
                    if self.x() <= 10 or self.x() >= self.screen_width - self.width() - 10:
                        self.event_data['race_direction'] = -direction
                else:
                    # 마무리 - 멈추기
                    self.velocity_x *= 0.8
                    if abs(self.velocity_x) < 0.1:
                        self.velocity_x = 0
        
        # ========== 눈싸움 ==========
        elif event_type == 'stare':
            update_emoji(40)
            
            # 가만히 서서 마주보기 (가끔 위협적 점프)
            self.velocity_x = 0
            if self.event_frame % 60 == 30 and self.on_ground:
                self.velocity_y = self.jump_power * 0.3
                self.on_ground = False
        
        # ========== 다툼 ==========
        elif event_type == 'argue':
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 화나서 펄쩍펄쩍
                phase = self.event_frame % 45
                if phase < 15:
                    self.velocity_x = 1.0 if dx > 0 else -1.0  # 다가감
                elif phase < 30:
                    self.velocity_x = -1.0 if dx > 0 else 1.0  # 물러남
                    if phase == 20 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                else:
                    self.velocity_x = 0
        
        # ========== 무시 ==========
        elif event_type == 'ignore':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                if self.event_frame == 25:
                    self.facing_right = not self.facing_right  # 등 돌림
                
                # 등 돌리고 멀어지기
                if self.event_frame > 30:
                    self.velocity_x = -0.8 if dx > 0 else 0.8
        
        # ========== 자랑 ==========
        elif event_type == 'showoff':
            update_emoji(25)
            
            # 뽐내듯이 높이 점프 + 좌우 어필
            phase = self.event_frame % 60
            if phase < 20:
                self.velocity_x = 1.5
            elif phase < 40:
                self.velocity_x = -1.5
            else:
                self.velocity_x = 0
                if phase == 45 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.6
                    self.on_ground = False
        
        # ========== 도발 ==========
        elif event_type == 'taunt':
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 다가갔다가 도발하고 물러남
                phase = self.event_frame % 50
                if phase < 15:
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.2 if dx > 0 else -1.2
                    else:
                        self.velocity_x = 0
                elif phase < 25:
                    self.velocity_x = 0
                    if phase == 18 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.35
                        self.on_ground = False
                elif phase < 40:
                    self.velocity_x = -1.0 if dx > 0 else 1.0
                else:
                    self.velocity_x = 0
        
        # ========== 경쟁 ==========
        elif event_type == 'compete':
            update_emoji(20)
            
            # 번갈아 높이 점프하며 경쟁
            if self.event_frame % 40 == 0 and self.on_ground:
                self.velocity_y = self.jump_power * 0.65
                self.on_ground = False
            
            # 좌우로 움직이며
            phase = self.event_frame % 40
            if phase < 10:
                self.velocity_x = 1.2
            elif phase < 20:
                self.velocity_x = -1.2
            else:
                self.velocity_x = 0
        
        # ========== 노려보기 ==========
        elif event_type == 'glare':
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 살금살금 다가갔다가 위협
                phase = self.event_frame % 70
                if phase < 30:
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.5 if dx > 0 else -0.5
                    else:
                        self.velocity_x = 0
                elif phase < 40:
                    self.velocity_x = 0
                    if phase == 35 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
                elif phase < 60:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    self.velocity_x = 0
        
        # ========== 냉담 ==========
        elif event_type == 'cold':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 시선 피하며 멀어지기
                if self.event_frame == 20:
                    self.facing_right = dx < 0  # 반대 방향 보기
                
                self.velocity_x = -0.4 if dx > 0 else 0.4
        
        # ========== 앙심 ==========
        elif event_type == 'spite':
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 분노로 펄쩍펄쩍
                phase = self.event_frame % 40
                if phase < 15:
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.8 if dx > 0 else -0.8
                    else:
                        self.velocity_x = 0
                    if phase == 10 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                elif phase < 30:
                    self.velocity_x = -0.8 if dx > 0 else 0.8
                else:
                    self.velocity_x = 0
        
        # ========== 긴장감 ==========
        elif event_type == 'tension':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 팽팽한 대치 - 가끔 위협
                phase = self.event_frame % 80
                if phase == 40 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.4
                    self.on_ground = False
                    self.velocity_x = 1.0 if dx > 0 else -1.0
                elif phase > 40 and phase < 55:
                    self.velocity_x = -0.8 if dx > 0 else 0.8
                else:
                    self.velocity_x = 0
        
        # ========== 어색/인사 ==========
        elif event_type == 'awkward' or event_type == 'wave':
            update_emoji(35)
            
            # 어색하게 손 흔들기 (작은 점프)
            if self.event_frame == 20 and self.on_ground:
                self.velocity_y = self.jump_power * 0.15
                self.on_ground = False
        
        # ========== 호기심 ==========
        elif event_type == 'curious':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                phase = self.event_frame % 80
                if phase < 30:
                    # 살금살금 다가가기 (최소 거리까지만)
                    if abs(dx) > min_dist:
                        self.velocity_x = 0.6 if dx > 0 else -0.6
                    else:
                        self.velocity_x = 0
                elif phase < 50:
                    # 깜짝 놀라 물러남
                    self.velocity_x = -1.0 if dx > 0 else 1.0
                    if phase == 35 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.2
                        self.on_ground = False
                else:
                    self.velocity_x = 0
        
        # ========== 긴장 ==========
        elif event_type == 'nervous':
            update_emoji(40)
            
            # 서성임
            phase = self.event_frame % 50
            if phase < 15:
                self.velocity_x = 0.6
            elif phase < 30:
                self.velocity_x = -0.6
            else:
                self.velocity_x = 0
                if phase == 40 and self.on_ground and random.random() < 0.4:
                    self.velocity_y = self.jump_power * 0.15
                    self.on_ground = False
        
        # ========== 예의 ==========
        elif event_type == 'polite':
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 공손히 인사
                if self.event_frame == 30 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.2  # 인사
                    self.on_ground = False
                
                if self.event_frame == 70 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.15  # 다시 인사
                    self.on_ground = False
        
        # ========== 관찰 ==========
        elif event_type == 'observe':
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.9  # 관찰은 더 멀리서
                
                # 거리 유지하며 관찰
                if abs(dx) < min_dist:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                elif abs(dx) > self.size * 1.5:
                    self.velocity_x = 0.3 if dx > 0 else -0.3
                else:
                    self.velocity_x = 0
        
        # ========== 경쟁심 관련 이벤트 ==========
        elif event_type in ['compete_battle', 'intense_rivalry', 'envious_competitor', 'bitter_rival', 'hateful_rival']:
            # 치열한 경쟁 - 번갈아 점프하며 대결
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.6
                
                phase = self.event_frame % 60
                if phase < 15:
                    # 다가가기
                    if abs(dx) > min_dist:
                        self.velocity_x = 2.0 if dx > 0 else -2.0
                    else:
                        self.velocity_x = 0
                elif phase < 25:
                    # 점프 공격
                    self.velocity_x = 0
                    if phase == 15 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.7
                        self.on_ground = False
                elif phase < 40:
                    # 물러나기
                    self.velocity_x = -1.5 if dx > 0 else 1.5
                else:
                    # 대치
                    self.velocity_x = 0
                    if phase == 50 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
        
        elif event_type in ['love_rivalry', 'passionate_love', 'competitive_crush', 'jealous_lover']:
            # 사랑+경쟁 혼합 - 다가갔다 부끄러워서 물러남
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                phase = self.event_frame % 80
                
                if phase < 25:
                    # 열정적으로 다가가기
                    self.velocity_x = 1.8 if dx > 0 else -1.8
                elif phase < 35:
                    # 점프
                    self.velocity_x = 0
                    if phase == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 55:
                    # 수줍게 물러나기
                    self.velocity_x = -1.2 if dx > 0 else 1.2
                else:
                    self.velocity_x = 0
        
        elif event_type in ['friendly_competition', 'rival_friendship', 'trusted_rival', 'aspiring_rival']:
            # 우호적 경쟁 - 같이 뛰며 경쟁
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                phase = self.event_frame % 50
                
                if phase < 20:
                    # 나란히 달리기
                    self.velocity_x = 2.0 if dx > 0 else -2.0
                elif phase < 30:
                    # 동시 점프
                    self.velocity_x = 0
                    if phase == 20 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.6
                        self.on_ground = False
                else:
                    # 제자리
                    self.velocity_x = 0
        
        elif event_type in ['one_sided_rival', 'uninterested_rival', 'ignored_rival', 'one_sided_admire', 'one_sided_love']:
            # 일방적 관심 - 한쪽만 다가가기
            update_emoji(35)
            
            my_feeling = self.event_data.get('my_feeling', '')
            if partner:
                dx = partner.x() - self.x()
                
                # 관심 있는 쪽만 다가감
                if my_feeling in ['경쟁심', '동경', '사랑', '질투']:
                    phase = self.event_frame % 60
                    if phase < 25:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                    elif phase < 40:
                        self.velocity_x = 0
                    else:
                        self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    # 무관심한 쪽은 거리 유지
                    self.velocity_x = 0
                    if self.event_frame % 40 == 0:
                        self.velocity_x = random.choice([-0.5, 0.5])
        
        elif event_type in ['frustrated_rival', 'awkward_rival', 'annoyed_by_prank', 'annoyed_friend', 'annoyed_by_love']:
            # 짜증+불편 - 펄쩍펄쩍 뛰며 짜증
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 가끔 짜증내며 점프
                if self.event_frame % 35 == 0 and self.on_ground:
                    self.velocity_y = self.jump_power * 0.4
                    self.on_ground = False
                
                # 거리 유지
                phase = self.event_frame % 50
                if phase < 20:
                    self.velocity_x = -1.0 if dx > 0 else 1.0
                else:
                    self.velocity_x = 0
        
        elif event_type in ['trusted_love', 'reliable_friend', 'playful_friend', 'fan_meeting', 'admire_to_love']:
            # 긍정적 관계 - 가까이 다가가서 함께
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.6
                
                phase = self.event_frame % 60
                if phase < 30:
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.2 if dx > 0 else -1.2
                    else:
                        self.velocity_x = 0
                        if phase == 20 and self.on_ground:
                            self.velocity_y = self.jump_power * 0.4
                            self.on_ground = False
                else:
                    self.velocity_x = 0
        
        elif event_type in ['shy_crush', 'building_trust', 'hesitant_trust', 'new_friendship', 'awkward_friend']:
            # 어색한 긍정 - 조심스럽게 다가감
            update_emoji(40)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 80
                if phase < 30:
                    # 살금살금 다가가기
                    self.velocity_x = 0.5 if dx > 0 else -0.5
                elif phase < 50:
                    # 멈추고 어색
                    self.velocity_x = 0
                else:
                    # 조금 물러남
                    self.velocity_x = -0.3 if dx > 0 else 0.3
        
        elif event_type in ['cold_response', 'distant_friend', 'unbothered', 'apathetic', 'ignoring_prank', 'mutual_disinterest']:
            # 냉담한 반응 - 거의 움직이지 않음
            update_emoji(50)
            
            if partner:
                dx = partner.x() - self.x()
                
                # 가끔 등 돌리듯 멀어지기
                if self.event_frame % 60 < 20:
                    self.velocity_x = -0.3 if dx > 0 else 0.3
                else:
                    self.velocity_x = 0
        
        elif event_type in ['broken_friendship', 'hostile_friend', 'hate_pranks', 'mutual_hatred', 'hateful_envy']:
            # 적대적 관계 - 서로 대치하며 위협
            update_emoji(25)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 70
                if phase < 20:
                    # 위협적으로 다가가기
                    self.velocity_x = 1.5 if dx > 0 else -1.5
                elif phase < 30:
                    # 위협 점프
                    self.velocity_x = 0
                    if phase == 20 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 50:
                    # 물러나기
                    self.velocity_x = -1.2 if dx > 0 else 1.2
                else:
                    self.velocity_x = 0
        
        elif event_type in ['flirty_tease', 'confused_by_prank', 'testing_patience', 'testing_trust']:
            # 장난+반응 - 장난치고 반응 보기
            update_emoji(30)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 60
                if phase < 20:
                    # 장난치러 다가가기
                    self.velocity_x = 1.5 if dx > 0 else -1.5
                elif phase < 35:
                    # 장난 점프
                    self.velocity_x = 0
                    if phase == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.5
                        self.on_ground = False
                elif phase < 50:
                    # 도망
                    self.velocity_x = -2.0 if dx > 0 else 2.0
                else:
                    self.velocity_x = 0
        
        elif event_type in ['mentor_admire', 'unnoticed_trust', 'jealous_friend', 'competitive_admire']:
            # 복합 감정 - 다양한 모션 혼합
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                
                phase = self.event_frame % 90
                if phase < 30:
                    # 다가가기
                    if abs(dx) > self.size * 0.7:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                elif phase < 45:
                    self.velocity_x = 0
                    if phase == 35 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.4
                        self.on_ground = False
                elif phase < 70:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
                else:
                    self.velocity_x = 0
        
        # ========== 기본 이벤트 (매칭되지 않는 경우) ==========
        else:
            update_emoji(35)
            
            if partner:
                dx = partner.x() - self.x()
                min_dist = self.size * 0.7
                
                # 기본 상호작용: 다가갔다 물러나기
                phase = self.event_frame % 60
                if phase < 25:
                    if abs(dx) > min_dist:
                        self.velocity_x = 1.0 if dx > 0 else -1.0
                    else:
                        self.velocity_x = 0
                elif phase < 35:
                    self.velocity_x = 0
                    if phase == 25 and self.on_ground:
                        self.velocity_y = self.jump_power * 0.3
                        self.on_ground = False
                else:
                    self.velocity_x = -0.5 if dx > 0 else 0.5
        
        # 이벤트 종료 체크
        if self.event_frame >= self.event_duration:
            self.end_long_event()
    
    def end_long_event(self):
        """긴 이벤트 종료"""
        if not self.in_event:
            return
            
        print(f"[긴 이벤트] {self.event_type} 종료 ({self.char_id})")
        
        self.in_event = False
        self.event_type = None
        self.event_partner = None
        self.event_frame = 0
        self.event_duration = 0
        self.event_data = {}
        
        # 랜덤 방향으로 이동 재개
        self.velocity_x = random.choice([-2, -1.5, 1.5, 2])
        self.facing_right = self.velocity_x > 0
    
    def closeEvent(self, event):
        self.timer.stop()
        # GIF movie 정리
        if self.gif_movie:
            self.gif_movie.stop()
            self.gif_movie = None
        event.accept()


class CharacterCard(QFrame):
    """캐릭터 카드 위젯 - CSS 스펙 기반"""
    remove_clicked = pyqtSignal(int)
    change_image_clicked = pyqtSignal(int)
    change_scale_clicked = pyqtSignal(int)
    change_bubble_color_clicked = pyqtSignal(int)
    change_relationships_clicked = pyqtSignal(int)
    change_dialogues_clicked = pyqtSignal(int)
    change_personality_clicked = pyqtSignal(int)
    name_changed = pyqtSignal(int, str)
    catchphrase_changed = pyqtSignal(int, str)
    toggle_active = pyqtSignal(int, bool)
    batch_toggle_clicked = pyqtSignal()  # 토글 우클릭 시 다중 활성화 관리
    
    def __init__(self, char_id, image_path, name="", is_active=True, catchphrase=""):
        super().__init__()
        self.char_id = char_id
        self.image_path = image_path
        self.char_name = name if name else f"캐릭터 {char_id + 1}"
        self.is_active = is_active
        self.catchphrase = catchphrase if catchphrase else "캐치프레이즈를 입력하세요"
        
        self.setFrameStyle(QFrame.NoFrame)
        self.setStyleSheet("""
            CharacterCard {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 16px;
                margin: 5px;
            }
        """)
        
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(14, 14, 14, 14)
        main_layout.setSpacing(12)
        
        # ===== 상단: 이미지 영역 + 정보 영역 =====
        top_section = QHBoxLayout()
        top_section.setSpacing(14)
        top_section.setAlignment(Qt.AlignBottom)  # 하단 정렬
        
        # --- 왼쪽: 이미지 컨테이너 (165x156) ---
        self.image_container = QFrame()
        self.image_container.setFixedSize(165, 156)
        self.image_container.setStyleSheet("""
            QFrame {
                background-color: #E8F5EE;
                border: none;
                border-radius: 10px;
            }
        """)
        
        # 이미지 컨테이너 내부 레이아웃
        img_layout = QVBoxLayout(self.image_container)
        img_layout.setContentsMargins(10, 10, 10, 10)
        img_layout.setSpacing(6)
        
        # 토글 + 이미지 변경 버튼 행 (라벨 없음)
        toggle_row = QHBoxLayout()
        toggle_row.setSpacing(8)
        
        # 토글 스위치
        self.active_toggle = ToggleSwitch(checked=self.is_active)
        self.active_toggle.toggled.connect(self.on_toggle)
        self.active_toggle.rightClicked.connect(self.batch_toggle_clicked.emit)  # 우클릭 연결
        
        # OFF 라벨 (토글 옆에 배경 없이)
        self.toggle_label = QLabel("ON" if self.is_active else "OFF")
        self.toggle_label.setStyleSheet(f"""
            background: transparent;
            color: {'#5A9C85' if self.is_active else '#536E6C'};
            font-size: 12px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        
        toggle_row.addWidget(self.active_toggle)
        toggle_row.addWidget(self.toggle_label)
        toggle_row.addStretch()
        
        # 이미지 변경 버튼 (25x25, 원형, 흰색 배경, 그림자)
        change_img_btn = QPushButton()
        change_img_btn.setFixedSize(25, 25)
        change_img_btn.setCursor(Qt.PointingHandCursor)
        change_img_btn.clicked.connect(lambda: self.change_image_clicked.emit(self.char_id))
        change_img_btn.setStyleSheet("""
            QPushButton {
                background-color: #FFFFFF;
                border: none;
                border-radius: 12px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
        """)
        # 그림자 효과
        shadow = QGraphicsDropShadowEffect()
        shadow.setBlurRadius(4)
        shadow.setOffset(0, 1)
        shadow.setColor(QColor("#BFC8C4"))
        change_img_btn.setGraphicsEffect(shadow)
        self._set_svg_icon(change_img_btn, SVG_IMAGE_CHANGE, 14)
        toggle_row.addWidget(change_img_btn)
        
        img_layout.addLayout(toggle_row)
        
        # 캐릭터 이미지 (배경 투명)
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setStyleSheet("background: transparent;")
        
        if image_path.lower().endswith('.gif'):
            # GIF인 경우 PIL로 첫 프레임 추출
            try:
                from PIL import Image as PILImage
                from io import BytesIO
                gif = PILImage.open(image_path)
                gif.seek(0)
                frame = gif.convert('RGBA')
                data = BytesIO()
                frame.save(data, format='PNG')
                data.seek(0)
                pixmap = QPixmap()
                pixmap.loadFromData(data.read())
            except Exception as e:
                print(f"[GIF 로드 실패] {e}")
                pixmap = QPixmap(image_path)
        else:
            pixmap = QPixmap(image_path)
        
        if not pixmap.isNull():
            pixmap = pixmap.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.image_label.setPixmap(pixmap)
        
        img_layout.addWidget(self.image_label, 1)
        
        # 비활성화 오버레이 (전체 덮음)
        self.inactive_overlay = QFrame(self.image_container)
        self.inactive_overlay.setGeometry(0, 0, 165, 156)
        self.inactive_overlay.setStyleSheet("""
            background-color: rgba(165, 181, 175, 0.88);
            border-radius: 9px;
        """)
        self.inactive_overlay.setVisible(not self.is_active)
        self.inactive_overlay.raise_()
        # 토글은 오버레이 위에
        self.active_toggle.raise_()
        
        top_section.addWidget(self.image_container)
        
        # --- 오른쪽: 정보 + 버튼 영역 ---
        info_layout = QVBoxLayout()
        info_layout.setSpacing(6)
        
        # 캐치프레이즈 (클릭 가능)
        self.catchphrase_label = QLabel(self.catchphrase)
        self.catchphrase_label.setStyleSheet(f"""
            background: transparent;
            color: #7BAF9A;
            font-size: 13px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        self.catchphrase_label.setCursor(Qt.PointingHandCursor)
        self.catchphrase_label.mousePressEvent = self.edit_catchphrase
        info_layout.addWidget(self.catchphrase_label)
        
        # 이름 + 펜 아이콘
        name_row = QHBoxLayout()
        name_row.setSpacing(6)
        
        self.name_label = QLabel(self.char_name)
        self.name_label.setStyleSheet(f"""
            background: transparent;
            color: #3D7A5F;
            font-size: 20px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        
        # 펜 아이콘 버튼
        edit_btn = QPushButton()
        edit_btn.setFixedSize(22, 22)
        edit_btn.setCursor(Qt.PointingHandCursor)
        edit_btn.clicked.connect(self.edit_name)
        edit_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(101, 202, 162, 0.2);
                border-radius: 4px;
            }
        """)
        self._set_svg_icon(edit_btn, SVG_PEN, 18)
        
        name_row.addWidget(self.name_label)
        name_row.addWidget(edit_btn)
        name_row.addStretch()
        info_layout.addLayout(name_row)
        
        info_layout.addStretch()
        
        # 대사&성격 설정 버튼 (관계 설정 5px 위)
        personality_btn = QPushButton("캐릭터 대사&&성격 설정")
        personality_btn.setFixedHeight(40)
        personality_btn.setCursor(Qt.PointingHandCursor)
        personality_btn.clicked.connect(lambda: self.change_personality_clicked.emit(self.char_id))
        personality_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #349971;
                border: none;
                border-radius: 12px;
                padding: 6px 10px;
                font-size: 13px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        info_layout.addWidget(personality_btn)
        
        info_layout.addSpacing(5)  # 관계 설정 버튼과 5px 간격
        
        # 관계 설정 버튼 (이미지 박스와 아래 정렬)
        relation_btn = QPushButton("캐릭터 간 감정 설정")
        relation_btn.setFixedHeight(40)
        relation_btn.setCursor(Qt.PointingHandCursor)
        relation_btn.clicked.connect(lambda: self.change_relationships_clicked.emit(self.char_id))
        relation_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #8ECFB5;
                color: #FFFFFF;
                border: none;
                border-radius: 12px;
                padding: 6px 10px;
                font-size: 13px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #7BC4A8;
            }}
        """)
        info_layout.addWidget(relation_btn)
        
        top_section.addLayout(info_layout, 1)
        main_layout.addLayout(top_section)
        
        # ===== 하단: 버튼 행 (말풍선, 크기, 삭제) =====
        bottom_row = QHBoxLayout()
        bottom_row.setSpacing(5)
        
        # 말풍선 버튼
        bubble_btn = QPushButton(" 말풍선")
        bubble_btn.setFixedHeight(28)
        bubble_btn.setFixedWidth(80)
        bubble_btn.setCursor(Qt.PointingHandCursor)
        bubble_btn.clicked.connect(lambda: self.change_bubble_color_clicked.emit(self.char_id))
        bubble_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #349971;
                border: 1px solid #C5E8D8;
                border-radius: 14px;
                padding: 4px 8px;
                font-size: 14px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #E8F5EE;
            }}
        """)
        self._set_button_icon_with_text(bubble_btn, SVG_BUBBLE_SETTING, " 말풍선")
        bottom_row.addWidget(bubble_btn)
        
        # 크기 조절 버튼
        self.scale_btn = QPushButton(" 100%")
        self.scale_btn.setFixedHeight(28)
        self.scale_btn.setFixedWidth(80)
        self.scale_btn.setCursor(Qt.PointingHandCursor)
        self.scale_btn.clicked.connect(lambda: self.change_scale_clicked.emit(self.char_id))
        self.scale_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: transparent;
                color: #349971;
                border: 1px solid #C5E8D8;
                border-radius: 14px;
                padding: 4px 8px;
                font-size: 14px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #E8F5EE;
            }}
        """)
        self._set_button_icon_with_text(self.scale_btn, SVG_SCALE, " 100%")
        bottom_row.addWidget(self.scale_btn)
        
        bottom_row.addStretch()
        
        # 캐릭터 삭제 버튼 (초록색, 호버시 빨간색)
        delete_btn = QPushButton(" 캐릭터 삭제")
        delete_btn.setFixedHeight(28)
        delete_btn.setCursor(Qt.PointingHandCursor)
        delete_btn.clicked.connect(lambda: self.remove_clicked.emit(self.char_id))
        delete_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: white;
                color: #349971;
                border: 1px solid #349971;
                border-radius: 14px;
                padding: 4px 14px;
                font-size: 14px;
                font-weight: 700;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #FFF0F0;
                border-color: #E57373;
                color: #E57373;
            }}
        """)
        self._set_svg_icon(delete_btn, SVG_TRASH, 11)
        bottom_row.addWidget(delete_btn)
        
        main_layout.addLayout(bottom_row)
        self.setLayout(main_layout)
    
    def _set_svg_icon(self, button, svg_data, size):
        """SVG 데이터로 버튼 아이콘 설정 (비율 유지)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 원본 크기 가져오기
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 비율 유지하면서 size에 맞게 스케일
            if orig_w >= orig_h:
                scale = size / orig_w
                new_w = size
                new_h = int(orig_h * scale)
            else:
                scale = size / orig_h
                new_h = size
                new_w = int(orig_w * scale)
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
    
    def _set_button_icon_with_text(self, button, svg_data, text):
        """SVG 아이콘 + 텍스트 버튼 설정 (비율 유지)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 원본 크기 가져오기
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 높이 12px 기준으로 스케일
            target_size = 12
            if orig_w >= orig_h:
                scale = target_size / orig_w
                new_w = target_size
                new_h = max(1, int(orig_h * scale))
            else:
                scale = target_size / orig_h
                new_h = target_size
                new_w = max(1, int(orig_w * scale))
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
        button.setText(text)
    
    def update_scale_display(self, scale_percent):
        """크기 표시 업데이트"""
        text = f" {scale_percent}%"
        self.scale_btn.setText(text)
        self._set_button_icon_with_text(self.scale_btn, SVG_SCALE, text)
        self.scale_btn.update()  # 화면 갱신 강제
        print(f"[CharacterCard] 크기 버튼 텍스트 변경: {text}")
    
    def on_toggle(self, checked):
        """토글 상태 변경"""
        self.is_active = checked
        self.toggle_label.setText("ON" if checked else "OFF")
        self.toggle_label.setStyleSheet(f"""
            background: transparent;
            color: {'#5A9C85' if checked else '#536E6C'};
            font-size: 12px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        # 오버레이 표시/숨기기
        self.inactive_overlay.setVisible(not checked)
        self.toggle_active.emit(self.char_id, checked)
    
    def set_active(self, active):
        """외부에서 활성화 상태 설정"""
        self.is_active = active
        self.active_toggle.setChecked(active)
        self.toggle_label.setText("ON" if active else "OFF")
        self.toggle_label.setStyleSheet(f"""
            background: transparent;
            color: {'#5A9C85' if active else '#536E6C'};
            font-size: 12px;
            font-weight: 700;
            font-family: {KOREAN_FONT};
        """)
        # 오버레이 표시/숨기기
        self.inactive_overlay.setVisible(not active)
    
    def edit_name(self):
        """이름 수정 다이얼로그"""
        dialog = NameEditDialog(self.char_name, self)
        if dialog.exec_() == QDialog.Accepted:
            text = dialog.get_name()
            if text:
                self.char_name = text
                self.name_label.setText(text)
                self.name_changed.emit(self.char_id, text)
    
    def edit_catchphrase(self, event):
        """캐치프레이즈 수정 다이얼로그"""
        from PyQt5.QtWidgets import QInputDialog
        text, ok = QInputDialog.getText(self, '캐치프레이즈 수정', '캐치프레이즈를 입력하세요:', 
                                       text=self.catchphrase if self.catchphrase != "캐치프레이즈를 입력하세요" else "")
        if ok:
            self.catchphrase = text if text else "캐치프레이즈를 입력하세요"
            self.catchphrase_label.setText(self.catchphrase)
            self.catchphrase_changed.emit(self.char_id, self.catchphrase)
    
    def update_image(self, image_path):
        """이미지 업데이트 (GIF인 경우 첫 프레임 표시)"""
        self.image_path = image_path
        
        if image_path.lower().endswith('.gif'):
            # GIF인 경우 PIL로 첫 프레임 추출
            try:
                from PIL import Image as PILImage
                from io import BytesIO
                gif = PILImage.open(image_path)
                gif.seek(0)
                frame = gif.convert('RGBA')
                data = BytesIO()
                frame.save(data, format='PNG')
                data.seek(0)
                pixmap = QPixmap()
                pixmap.loadFromData(data.read())
            except Exception as e:
                print(f"[GIF 로드 실패] {e}")
                pixmap = QPixmap(image_path)
        else:
            pixmap = QPixmap(image_path)
        
        if not pixmap.isNull():
            pixmap = pixmap.scaled(100, 100, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.image_label.setPixmap(pixmap)


class AIDialogueViewDialog(QDialog):
    """생성된 대사 열람/삭제 다이얼로그"""
    def __init__(self, char_id, char_name, char_names=None, parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.char_names = char_names or {}  # {char_id: name}
        
        # MainWindow 참조 찾기
        self.main_window = None
        p = self.parent()
        while p:
            if hasattr(p, 'dialogues') and hasattr(p, 'character_data'):
                self.main_window = p
                break
            p = p.parent()
        
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}의 생성된 대사")
        self.setMinimumSize(500, 500)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 10px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(10)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # 타이틀
        title = QLabel(f"{self.char_name}의 생성된 대사 목록")
        title.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 18px; font-weight: 700; font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # 스크롤 영역
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                background-color: white;
            }
        """)
        
        self.scroll_content = QWidget()
        self.scroll_content.setStyleSheet("background-color: white;")
        self.scroll_layout = QVBoxLayout()
        self.scroll_layout.setSpacing(5)
        self.scroll_layout.setContentsMargins(10, 10, 10, 10)
        
        self.load_dialogues()
        
        self.scroll_content.setLayout(self.scroll_layout)
        scroll.setWidget(self.scroll_content)
        layout.addWidget(scroll, 1)
        
        # 버튼 영역
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        # 대사 추가 버튼
        add_btn = QPushButton("대사 추가")
        add_btn.clicked.connect(self.add_dialogue)
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 10px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
        """)
        btn_layout.addWidget(add_btn)
        
        # 닫기 버튼
        close_btn = QPushButton("닫기")
        close_btn.clicked.connect(self.accept)
        btn_layout.addWidget(close_btn)
        
        layout.addLayout(btn_layout)
        
        self.setLayout(layout)
    
    def load_dialogues(self):
        """대사 목록 로드"""
        # 기존 위젯 제거
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                self.clear_layout(item.layout())
        
        global _ai_dialogues_cache
        cache = _ai_dialogues_cache.get(self.char_id, {})
        
        if not cache:
            empty_label = QLabel("생성된 대사가 없습니다.")
            empty_label.setStyleSheet("color: #888; font-style: italic; font-weight: 700; padding: 20px;")
            empty_label.setAlignment(Qt.AlignCenter)
            self.scroll_layout.addWidget(empty_label)
            self.scroll_layout.addStretch()
            return
        
        # 기본 대사 (solo + fallback 합침)
        solo = cache.get('solo', [])
        fallback = cache.get('fallback', [])
        basic_dialogues = solo + fallback
        if basic_dialogues:
            self.add_section("기본 대사", basic_dialogues, 'solo')
        
        # 상호작용 대사 (캐릭터별로 분리)
        interaction = cache.get('interaction', {})
        if interaction and isinstance(interaction, dict):
            for other_key, dialogues in interaction.items():
                if isinstance(dialogues, list) and dialogues:
                    # 키에 따라 섹션 타이틀 결정
                    if other_key == 'default':
                        section_title = "상호작용 대사 (일반)"
                    else:
                        # 캐릭터 이름이 키인 경우 (새 형식)
                        # 또는 캐릭터 ID가 키인 경우 (구 형식)
                        try:
                            other_char_id = int(other_key)
                            other_name = self.char_names.get(other_char_id, f"캐릭터 {other_char_id + 1}")
                        except (ValueError, TypeError):
                            # 숫자가 아니면 캐릭터 이름으로 간주
                            other_name = str(other_key)
                        section_title = f"↔ {other_name}"
                    
                    self.add_section(section_title, dialogues, f'interaction_{other_key}')
        
        self.scroll_layout.addStretch()
    
    def add_section(self, title, dialogues, section_key):
        """섹션 추가"""
        # 섹션 헤더
        header = QLabel(f"▸ {title} ({len(dialogues)}개)")
        header.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif; color: #5A9C85; margin-top: 10px;")
        self.scroll_layout.addWidget(header)
        
        # 대사 목록
        for i, dialogue in enumerate(dialogues):
            row = QHBoxLayout()
            row.setSpacing(5)
            
            # 대사 텍스트 (인라인 편집 가능)
            text_edit = QLineEdit(dialogue)
            text_edit.setStyleSheet("""
                QLineEdit {
                    background-color: #F5F5F5;
                    padding: 8px 12px;
                    border-radius: 10px;
                    color: #333;
                    font-size: 13px;
                    font-weight: 700;
                    border: 1px solid transparent;
                }
                QLineEdit:focus {
                    background-color: white;
                    border: 1px solid #8ECFB5;
                }
            """)
            # 포커스 잃으면 자동 저장
            text_edit.editingFinished.connect(
                lambda s=section_key, idx=i, edit=text_edit: self.save_dialogue_inline(s, idx, edit)
            )
            row.addWidget(text_edit, 1)
            
            # 삭제 버튼
            del_btn = QPushButton("✕")
            del_btn.setFixedSize(28, 28)
            del_btn.setStyleSheet("""
                QPushButton {
                    background-color: #FFB5BA;
                    color: white;
                    font-size: 13px;
                    font-weight: 700;
                    padding: 0px;
                    border-radius: 10px;
                }
                QPushButton:hover {
                    background-color: #FFA5AB;
                }
            """)
            del_btn.clicked.connect(lambda checked, s=section_key, idx=i: self.delete_dialogue(s, idx))
            row.addWidget(del_btn)
            
            self.scroll_layout.addLayout(row)
    
    def add_dialogue(self):
        """대사 수동 추가 - 종류 선택 다이얼로그"""
        # 대사 추가 다이얼로그
        add_dialog = QDialog(self)
        add_dialog.setWindowTitle("대사 추가")
        add_dialog.setFixedWidth(400)
        add_dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
            }
            QLabel {
                color: #5A9C85;
                font-weight: 700;
            }
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 8px;
                padding: 8px 12px;
                font-size: 13px;
            }
            QComboBox:hover {
                border-color: #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #D4F4DD;
            }
            QTextEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 8px;
                padding: 8px;
                font-size: 13px;
            }
            QTextEdit:focus {
                border-color: #8ECFB5;
            }
        """)
        
        layout = QVBoxLayout(add_dialog)
        layout.setSpacing(12)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # 대사 종류 선택
        type_label = QLabel("대사 종류")
        layout.addWidget(type_label)
        
        type_combo = QComboBox()
        type_combo.addItem("기본 대사", "solo")
        
        # 다른 캐릭터 목록 추가
        if self.char_names:
            for other_id, other_name in self.char_names.items():
                if other_id != self.char_id:
                    type_combo.addItem(f"↔ {other_name}", f"interaction_{other_id}")
        
        layout.addWidget(type_combo)
        
        # 대사 입력
        text_label = QLabel("대사 내용")
        layout.addWidget(text_label)
        
        text_edit = QTextEdit()
        text_edit.setPlaceholderText("대사를 입력하세요...")
        text_edit.setMinimumHeight(100)
        text_edit.setMaximumHeight(150)
        layout.addWidget(text_edit)
        
        # 버튼
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        cancel_btn = QPushButton("취소")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #D0D0D0;
            }
        """)
        cancel_btn.clicked.connect(add_dialog.reject)
        btn_layout.addWidget(cancel_btn)
        
        save_btn = QPushButton("추가")
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 8px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
        """)
        btn_layout.addWidget(save_btn)
        
        layout.addLayout(btn_layout)
        
        def do_save():
            text = text_edit.toPlainText().strip()
            if not text:
                QMessageBox.warning(add_dialog, "입력 필요", "대사 내용을 입력해주세요.")
                return
            
            dialogue_type = type_combo.currentData()
            
            # MainWindow의 dialogues에 추가 (수동 대사 목록)
            # DialogueDialog와 동일한 'char_X' 형식 사용
            if self.main_window:
                if self.char_id not in self.main_window.dialogues:
                    self.main_window.dialogues[self.char_id] = {'기본': []}
                
                char_dialogues = self.main_window.dialogues[self.char_id]
                
                if dialogue_type == "solo":
                    # 기본 대사에 추가
                    if '기본' not in char_dialogues:
                        char_dialogues['기본'] = []
                    char_dialogues['기본'].append(text)
                elif dialogue_type.startswith("interaction_"):
                    # 상호작용 대사에 추가 - 'char_X' 형식으로 저장
                    other_id = dialogue_type.replace("interaction_", "")
                    try:
                        other_id_int = int(other_id)
                        other_key = f'char_{other_id_int}'
                    except ValueError:
                        other_key = other_id
                    
                    if other_key not in char_dialogues:
                        char_dialogues[other_key] = []
                    char_dialogues[other_key].append(text)
                
                # CharacterWidget의 dialogues도 동기화
                for char in self.main_window.characters:
                    if char.char_id == self.char_id:
                        char.dialogues = char_dialogues.copy()
                        break
            
            # AI 캐시에도 추가 (호환성 유지 + 대사 표시용)
            # AI 캐시는 int 키 사용
            global _ai_dialogues_cache
            
            if self.char_id not in _ai_dialogues_cache:
                _ai_dialogues_cache[self.char_id] = {
                    'solo': [],
                    'interaction': {},
                    'fallback': [],
                    'generated_at': time.time()
                }
            
            cache = _ai_dialogues_cache[self.char_id]
            
            if dialogue_type == "solo":
                if 'solo' not in cache:
                    cache['solo'] = []
                cache['solo'].append(text)
            elif dialogue_type.startswith("interaction_"):
                other_key = dialogue_type.replace("interaction_", "")
                try:
                    other_key = int(other_key)
                except ValueError:
                    pass
                
                if 'interaction' not in cache:
                    cache['interaction'] = {}
                if other_key not in cache['interaction']:
                    cache['interaction'][other_key] = []
                cache['interaction'][other_key].append(text)
            
            cache['generated_at'] = time.time()
            
            # 목록 새로고침
            self.load_dialogues()
            
            # 부모 창에서 저장 호출
            if self.parent():
                try:
                    self.parent().save_characters()
                except:
                    pass
            
            add_dialog.accept()
        
        save_btn.clicked.connect(do_save)
        
        add_dialog.exec_()
    
    def delete_dialogue(self, section_key, index):
        """대사 삭제"""
        global _ai_dialogues_cache
        cache = _ai_dialogues_cache.get(self.char_id, {})
        
        if section_key.startswith('interaction_'):
            # 상호작용 대사 (interaction_default, interaction_0 등)
            other_id_str = section_key.replace('interaction_', '')
            interaction = cache.get('interaction', {})
            
            # 키 매칭 시도 (문자열 → int 변환)
            actual_key = None
            if other_id_str == 'default':
                actual_key = 'default'
            else:
                try:
                    int_key = int(other_id_str)
                    if int_key in interaction:
                        actual_key = int_key
                    elif other_id_str in interaction:
                        actual_key = other_id_str
                except ValueError:
                    if other_id_str in interaction:
                        actual_key = other_id_str
            
            if actual_key is not None and actual_key in interaction:
                dialogues = interaction[actual_key]
                if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                    dialogues.pop(index)
                    print(f"[대사 삭제] char_id={self.char_id}, key={actual_key}, index={index}")
        elif section_key == 'solo':
            # 기본 대사 (solo + fallback)
            solo = cache.get('solo', [])
            fallback = cache.get('fallback', [])
            
            if index < len(solo):
                solo.pop(index)
            else:
                fallback_idx = index - len(solo)
                if 0 <= fallback_idx < len(fallback):
                    fallback.pop(fallback_idx)
        else:
            # 그 외
            dialogues = cache.get(section_key, [])
            if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                dialogues.pop(index)
        
        # UI 새로고침
        self.load_dialogues()
    
    def save_dialogue_inline(self, section_key, index, line_edit):
        """인라인 편집 저장 (포커스 잃으면 자동 저장)"""
        new_text = line_edit.text().strip()
        if not new_text:
            return
        
        global _ai_dialogues_cache
        cache = _ai_dialogues_cache.get(self.char_id, {})
        
        if section_key.startswith('interaction_'):
            # 상호작용 대사 (interaction_default, interaction_0 등)
            other_id_str = section_key.replace('interaction_', '')
            interaction = cache.get('interaction', {})
            
            # 키 매칭 시도 (문자열 → int 변환)
            actual_key = None
            if other_id_str == 'default':
                actual_key = 'default'
            else:
                try:
                    int_key = int(other_id_str)
                    if int_key in interaction:
                        actual_key = int_key
                    elif other_id_str in interaction:
                        actual_key = other_id_str
                except ValueError:
                    if other_id_str in interaction:
                        actual_key = other_id_str
            
            if actual_key is not None and actual_key in interaction:
                dialogues = interaction[actual_key]
                if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                    dialogues[index] = new_text
                    print(f"[대사 수정] char_id={self.char_id}, key={actual_key}, index={index}, text={new_text}")
        elif section_key == 'solo':
            # 기본 대사 (solo + fallback)
            solo = cache.get('solo', [])
            fallback = cache.get('fallback', [])
            
            if index < len(solo):
                solo[index] = new_text
            else:
                fallback_idx = index - len(solo)
                if 0 <= fallback_idx < len(fallback):
                    fallback[fallback_idx] = new_text
        else:
            # 그 외
            dialogues = cache.get(section_key, [])
            if isinstance(dialogues, list) and 0 <= index < len(dialogues):
                dialogues[index] = new_text
    
    def clear_layout(self, layout):
        """레이아웃 내부 위젯 모두 제거"""
        while layout.count():
            item = layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
            elif item.layout():
                self.clear_layout(item.layout())


class PersonalityDialog(QDialog):
    """캐릭터 성격 설정 다이얼로그 (대사 + AI 성격 + 서사 통합)"""
    def __init__(self, char_id, char_name, all_characters, current_personality, current_nicknames, current_dialogues, current_stories=None, current_background_story="", parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.all_characters = all_characters  # {char_id: name}
        self.personality = current_personality
        self.background_story = current_background_story  # 캐릭터 배경 스토리
        self.nicknames = current_nicknames.copy() if current_nicknames else {}
        self.dialogues = current_dialogues.copy() if current_dialogues else ['', '', '']
        self.stories = current_stories.copy() if current_stories else {}
        self.nickname_edits = {}
        self.story_edits = {}
        self.dialogue_edits = []
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}의 대사&성격")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setMinimumSize(500, 700)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        from PyQt5.QtGui import QPainterPath, QRegion
        
        # 메인 컨테이너 (흰색 배경, 테두리)
        self.container = QWidget(self)
        self.container.setObjectName("mainContainer")
        self.container.setStyleSheet("""
            #mainContainer {
                background-color: white;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                background: transparent;
            }
            QLineEdit, QTextEdit {
                background-color: white;
                border: 1px solid #9DD4BA;
                border-radius: 12px;
                padding: 10px 12px;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                color: #317C75;
            }
            QLineEdit::placeholder, QTextEdit::placeholder {
                color: #9DD4BA;
            }
            QLineEdit:focus, QTextEdit:focus {
                border: 2px solid #8ECFB5;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 12px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QScrollBar:vertical {
                background: transparent;
                width: 8px;
                margin: 0;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 4px;
                min-height: 30px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0;
            }
        """)
        
        # 메인 레이아웃 (컨테이너용)
        main_layout = QVBoxLayout(self.container)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(self.container)
        
        # === 헤더 (타이틀 + X버튼) ===
        header_widget = QWidget()
        header_widget.setStyleSheet("background-color: transparent;")
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(25, 20, 20, 10)
        
        header_layout.addStretch()
        
        # 타이틀
        title = QLabel(f"{self.char_name}의 대사&성격")
        title.setStyleSheet("""
            font-size: 20px; 
            font-weight: 700; 
            color: #317C75;
            background: transparent;
        """)
        title.setAlignment(Qt.AlignCenter)
        header_layout.addWidget(title)
        
        header_layout.addStretch()
        
        # X 버튼 (크레딧과 동일한 SVG)
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        header_layout.addWidget(close_btn)
        
        main_layout.addWidget(header_widget)
        
        # 스크롤 영역
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("QScrollArea { border: none; background-color: transparent; }")
        
        content = QWidget()
        content.setStyleSheet("background-color: transparent;")
        layout = QVBoxLayout(content)
        layout.setSpacing(8)
        layout.setContentsMargins(25, 10, 25, 25)
        
        # === 기본 대사 섹션 ===
        dialogue_label = QLabel("기본 대사")
        dialogue_label.setStyleSheet("""
            font-size: 15px; 
            font-weight: 700; 
            color: #317C75;
            margin-top: 5px;
        """)
        layout.addWidget(dialogue_label)
        
        dialogue_info = QLabel("입력해주신 대사를 기반으로 캐릭터의 말투를 파악합니다.(수동 입력 필요)")
        dialogue_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
        layout.addWidget(dialogue_info)
        
        # 대사 입력 (3개)
        for i in range(3):
            edit = QLineEdit()
            edit.setPlaceholderText(f"대사 {i+1}")
            edit.setMinimumHeight(40)
            if i < len(self.dialogues):
                text = self.dialogues[i]
                if text and text != '(선택)':
                    edit.setText(text)
            self.dialogue_edits.append(edit)
            layout.addWidget(edit)
        
        # === 성격 섹션 ===
        ai_label = QLabel("성격")
        ai_label.setStyleSheet("""
            font-size: 15px; 
            font-weight: 700; 
            color: #317C75;
            margin-top: 12px;
        """)
        layout.addWidget(ai_label)
        
        ai_info = QLabel("성격에 대해서 설명을 입력하면 캐릭터에 맞는 대사가 자동 생성됩니다.")
        ai_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
        layout.addWidget(ai_info)
        
        self.personality_edit = QTextEdit()
        self.personality_edit.setPlaceholderText("대사 1")
        self.personality_edit.setText(self.personality)
        self.personality_edit.setFixedHeight(100)
        layout.addWidget(self.personality_edit)
        
        # === 배경 스토리 섹션 ===
        story_label = QLabel("배경 스토리(선택)")
        story_label.setStyleSheet("""
            font-size: 15px; 
            font-weight: 700; 
            color: #317C75;
            margin-top: 12px;
        """)
        layout.addWidget(story_label)
        
        story_info = QLabel("캐릭터의 배경이나 이야기를 입력하면 대사에 반영됩니다.")
        story_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
        layout.addWidget(story_info)
        
        self.background_story_edit = QTextEdit()
        self.background_story_edit.setPlaceholderText("예: 요리사를 꿈꾸는 학생, 비 오는 날을 좋아함")
        self.background_story_edit.setText(self.background_story)
        self.background_story_edit.setFixedHeight(70)
        layout.addWidget(self.background_story_edit)
        
        # === 호칭 & 서사 섹션 ===
        other_chars = [(cid, name) for cid, name in self.all_characters.items() if cid != self.char_id]
        
        if other_chars:
            nickname_section_label = QLabel("다른 캐릭터와의 호칭과 서사")
            nickname_section_label.setStyleSheet("""
                font-size: 15px; 
                font-weight: 700; 
                color: #317C75;
                margin-top: 12px;
            """)
            layout.addWidget(nickname_section_label)
            
            nickname_info = QLabel("호칭은 쉼표(,)로 구분하여 여러 개 입력 가능합니다.")
            nickname_info.setStyleSheet("font-size: 12px; font-weight: 700; color: #5A9C85;")
            layout.addWidget(nickname_info)
            
            for other_id, other_name in other_chars:
                # 캐릭터 이름 라벨
                char_header = QLabel(f"캐릭터이름{other_id + 1}" if other_name == f"캐릭터 {other_id + 1}" else other_name)
                char_header.setStyleSheet("""
                    font-size: 13px; 
                    font-weight: 700; 
                    color: #317C75;
                    margin-top: 10px;
                """)
                layout.addWidget(char_header)
                
                # 호칭 입력
                nickname_row = QHBoxLayout()
                nickname_row.setSpacing(10)
                nickname_label_small = QLabel("호칭:")
                nickname_label_small.setFixedWidth(35)
                nickname_label_small.setStyleSheet("font-size: 13px; font-weight: 700; color: #5A9C85;")
                nickname_row.addWidget(nickname_label_small)
                
                nickname_edit = QLineEdit()
                nickname_edit.setMinimumHeight(38)
                nickname_edit.setText(self.nicknames.get(other_id, ""))
                self.nickname_edits[other_id] = nickname_edit
                nickname_row.addWidget(nickname_edit)
                layout.addLayout(nickname_row)
                
                # 서사 입력 (선택)
                story_row = QHBoxLayout()
                story_row.setSpacing(10)
                story_label_small = QLabel("서사:")
                story_label_small.setFixedWidth(35)
                story_label_small.setStyleSheet("font-size: 13px; font-weight: 700; color: #5A9C85;")
                story_row.addWidget(story_label_small)
                
                story_edit = QLineEdit()
                story_edit.setMinimumHeight(38)
                story_edit.setText(self.stories.get(other_id, ""))
                self.story_edits[other_id] = story_edit
                story_row.addWidget(story_edit)
                layout.addLayout(story_row)
        
        # === 대사 열람/초기화 버튼 (스크롤 내부 하단) ===
        layout.addSpacing(20)
        
        manage_btn_layout = QHBoxLayout()
        manage_btn_layout.setSpacing(10)
        
        view_btn = QPushButton("생성된 대사 열람")
        view_btn.setStyleSheet("""
            QPushButton { 
                background-color: #C5E8D8; 
                color: #317C75; 
                font-weight: 700;
                padding: 10px 16px;
                border-radius: 12px;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #B5DBC8; }
        """)
        view_btn.clicked.connect(self.view_ai_dialogues)
        manage_btn_layout.addWidget(view_btn)
        
        reset_btn = QPushButton("대사 초기화")
        reset_btn.setStyleSheet("""
            QPushButton { 
                background-color: #FFD4D4; 
                color: #D35F5F; 
                font-weight: 700;
                padding: 10px 16px;
                border-radius: 12px;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #FFC4C4; }
        """)
        reset_btn.clicked.connect(self.reset_ai_dialogues)
        manage_btn_layout.addWidget(reset_btn)
        
        layout.addLayout(manage_btn_layout)
        
        layout.addStretch()
        
        scroll.setWidget(content)
        scroll.viewport().setStyleSheet("background-color: transparent;")
        main_layout.addWidget(scroll)
        
        # === 하단 버튼 영역 (창 닫기 / 저장하기만) ===
        btn_container = QWidget()
        btn_container.setStyleSheet("background-color: transparent;")
        btn_main_layout = QVBoxLayout(btn_container)
        btn_main_layout.setContentsMargins(25, 10, 25, 20)
        btn_main_layout.setSpacing(10)
        
        # 창 닫기 / 저장하기 버튼
        action_btn_layout = QHBoxLayout()
        action_btn_layout.setSpacing(10)
        
        cancel_btn = QPushButton("창 닫기")
        cancel_btn.setStyleSheet("""
            QPushButton { 
                background-color: #E8F5F0; 
                color: #5A9C85; 
                border: 1px solid #C5E8D8;
                font-weight: 700;
                padding: 14px 24px;
            }
            QPushButton:hover { background-color: #D8EBE4; }
        """)
        cancel_btn.clicked.connect(self.reject)
        
        save_btn = QPushButton("저장하기")
        save_btn.setStyleSheet("""
            QPushButton { 
                background-color: #5A9C85; 
                color: white; 
                font-weight: 700;
                padding: 14px 24px;
            }
            QPushButton:hover { background-color: #4A8C75; }
        """)
        save_btn.clicked.connect(self.accept)
        
        action_btn_layout.addWidget(cancel_btn)
        action_btn_layout.addWidget(save_btn)
        btn_main_layout.addLayout(action_btn_layout)
        
        main_layout.addWidget(btn_container)
    
    def reset_ai_dialogues(self):
        """AI 대사 캐시 초기화"""
        from PyQt5.QtWidgets import QMessageBox
        
        # 확인 다이얼로그
        reply = QMessageBox.question(
            self, 
            "생성된 대사 초기화", 
            f"정말 {self.char_name}의 생성된 대사를 초기화하시겠습니까?\n이 작업은 되돌릴 수 없습니다.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            global _ai_dialogues_cache
            if self.char_id in _ai_dialogues_cache:
                del _ai_dialogues_cache[self.char_id]
            
            QMessageBox.information(self, "초기화 완료", f"{self.char_name}의 생성된 대사가 초기화되었습니다.")
    
    def export_character(self):
        """캐릭터 데이터 백업 (JSON 파일로 내보내기)"""
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        import base64
        
        # 저장 경로 선택
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "캐릭터 백업",
            f"{self.char_name}_backup.json",
            "JSON 파일 (*.json)"
        )
        
        if not file_path:
            return
        
        try:
            # 이미지를 base64로 인코딩
            image_data = ""
            image_ext = ".png"
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'character_data'):
                main_window = main_window.parent()
            
            image_path = ""
            if main_window and self.char_id in main_window.character_data:
                char_data = main_window.character_data[self.char_id]
                image_path = char_data.get('image_path', '')
                if image_path and os.path.exists(image_path):
                    with open(image_path, 'rb') as f:
                        image_data = base64.b64encode(f.read()).decode('utf-8')
                    image_ext = os.path.splitext(image_path)[1]
                else:
                    print(f"[백업] 이미지 경로 없음 또는 파일 없음: {image_path}")
            
            # 이미지가 없으면 직접 선택 옵션 제공
            if not image_data:
                reply = QMessageBox.question(
                    self,
                    "이미지 없음",
                    "이미지 파일을 찾을 수 없습니다.\n\n직접 이미지를 선택하시겠습니까?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                if reply == QMessageBox.Yes:
                    selected_path, _ = QFileDialog.getOpenFileName(
                        self,
                        f"{self.char_name} 이미지 선택",
                        "",
                        "이미지 파일 (*.png *.jpg *.jpeg *.gif *.bmp)"
                    )
                    if selected_path and os.path.exists(selected_path):
                        with open(selected_path, 'rb') as f:
                            image_data = base64.b64encode(f.read()).decode('utf-8')
                        image_ext = os.path.splitext(selected_path)[1]
                    else:
                        # 이미지 없이 백업할지 확인
                        reply2 = QMessageBox.question(
                            self,
                            "이미지 없음",
                            "이미지 없이 백업하시겠습니까?\n\n(불러올 때 이미지를 다시 선택해야 합니다)",
                            QMessageBox.Yes | QMessageBox.No,
                            QMessageBox.No
                        )
                        if reply2 != QMessageBox.Yes:
                            return
                else:
                    # 이미지 없이 백업할지 확인
                    reply2 = QMessageBox.question(
                        self,
                        "이미지 없음",
                        "이미지 없이 백업하시겠습니까?\n\n(불러올 때 이미지를 다시 선택해야 합니다)",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.No
                    )
                    if reply2 != QMessageBox.Yes:
                        return
            
            # 현재 다이얼로그에서 편집 중인 값 포함
            backup_data = {
                'version': '2.0',
                'backup_type': 'single_character',
                'char_name': self.char_name,
                'personality': self.personality_edit.toPlainText().strip(),
                'background_story': self.background_story_edit.toPlainText().strip(),
                'nicknames': self.get_nicknames(),
                'stories': self.get_stories(),
                'dialogues': self.get_dialogues(),
                'sample_dialogues': getattr(self, 'sample_dialogues', []),
                'image_data': image_data,
                'image_ext': image_ext,
            }
            
            # AI 대사 캐시도 포함
            global _ai_dialogues_cache
            if self.char_id in _ai_dialogues_cache:
                cache = _ai_dialogues_cache[self.char_id]
                backup_data['ai_cache'] = {
                    'solo': cache.get('solo', []),
                    'interaction': cache.get('interaction', {}),
                    'fallback': cache.get('fallback', [])
                }
            
            # MainWindow에서 추가 정보 가져오기
            if main_window and self.char_id in main_window.character_data:
                char_data = main_window.character_data[self.char_id]
                backup_data['scale'] = char_data.get('scale', 100)
                backup_data['bubble_color'] = char_data.get('bubble_color', '#81C784')
                backup_data['bubble_size'] = char_data.get('bubble_size', 100)
                backup_data['facing_direction'] = char_data.get('facing_direction', 'front')
                backup_data['is_active'] = char_data.get('is_active', True)
                backup_data['catchphrase'] = char_data.get('catchphrase', '')
            
            # JSON 파일로 저장
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(backup_data, f, ensure_ascii=False, indent=2)
            
            # 상세 완료 메시지
            has_image = "✅" if image_data else "❌"
            has_ai = "✅" if backup_data.get('ai_cache') else "❌"
            
            QMessageBox.information(self, "백업 완료", 
                f"✅ '{self.char_name}' 백업 완료!\n\n"
                f"📦 포함된 데이터:\n"
                f"• 이미지: {has_image}\n"
                f"• 이름/캐치프레이즈\n"
                f"• 성격/배경 스토리\n"
                f"• AI 생성 대사: {has_ai}\n"
                f"• 수동 대사 목록\n"
                f"• 크기/말풍선/방향 설정\n\n"
                f"📁 저장 위치:\n{file_path}")
            
        except Exception as e:
            QMessageBox.critical(self, "백업 실패", f"백업 중 오류가 발생했습니다.\n\n{str(e)}")
    
    def import_character(self):
        """캐릭터 데이터 불러오기 (JSON 파일에서 가져오기)"""
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        import base64
        
        # 파일 선택
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "캐릭터 불러오기",
            "",
            "JSON 파일 (*.json)"
        )
        
        if not file_path:
            return
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            # 버전 체크
            version = backup_data.get('version', '1.0')
            
            # 확인 팝업
            backup_name = backup_data.get('char_name', '알 수 없음')
            reply = QMessageBox.question(
                self,
                "캐릭터 불러오기",
                f"'{backup_name}' 캐릭터 데이터를 현재 캐릭터에 적용하시겠습니까?\n\n현재 캐릭터의 데이터가 덮어쓰여집니다.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # UI에 데이터 적용
            self.personality_edit.setPlainText(backup_data.get('personality', ''))
            self.background_story_edit.setPlainText(backup_data.get('background_story', ''))
            
            # 호칭 적용
            nicknames = backup_data.get('nicknames', {})
            for char_id_str, nickname in nicknames.items():
                try:
                    char_id = int(char_id_str)
                    if char_id in self.nickname_edits:
                        self.nickname_edits[char_id].setText(nickname)
                except (ValueError, KeyError):
                    pass
            
            # 서사 적용
            stories = backup_data.get('stories', {})
            for char_id_str, story in stories.items():
                try:
                    char_id = int(char_id_str)
                    if char_id in self.story_edits:
                        self.story_edits[char_id].setText(story)
                except (ValueError, KeyError):
                    pass
            
            # 대사 적용
            dialogues = backup_data.get('dialogues', [])
            for i, edit in enumerate(self.dialogue_edits):
                if i < len(dialogues):
                    edit.setText(dialogues[i])
            
            # AI 캐시 적용 (interaction 키를 int로 변환)
            if 'ai_cache' in backup_data:
                global _ai_dialogues_cache
                raw_interaction = backup_data['ai_cache'].get('interaction', {})
                converted_interaction = {}
                for k, v in raw_interaction.items():
                    try:
                        converted_interaction[int(k)] = v
                    except (ValueError, TypeError):
                        converted_interaction[k] = v
                
                _ai_dialogues_cache[self.char_id] = {
                    'solo': backup_data['ai_cache'].get('solo', []),
                    'interaction': converted_interaction,
                    'fallback': backup_data['ai_cache'].get('fallback', []),
                    'generated_at': time.time()
                }
            
            # 수동 대사를 AI 캐시에 동기화
            dialogues_for_sync = backup_data.get('dialogues', [])
            if isinstance(dialogues_for_sync, list):
                sync_dialogues_to_ai_cache(self.char_id, {'기본': dialogues_for_sync})
            elif isinstance(dialogues_for_sync, dict):
                sync_dialogues_to_ai_cache(self.char_id, dialogues_for_sync)
            
            # MainWindow에 추가 데이터 적용
            main_window = self.parent()
            while main_window and not hasattr(main_window, 'character_data'):
                main_window = main_window.parent()
            
            if main_window and self.char_id in main_window.character_data:
                char_data = main_window.character_data[self.char_id]
                
                # 이미지 복원
                if backup_data.get('image_data'):
                    try:
                        image_ext = backup_data.get('image_ext', '.png')
                        # 새 이미지 파일 저장
                        image_dir = os.path.join(os.path.expanduser("~"), ".kiwipet_images")
                        os.makedirs(image_dir, exist_ok=True)
                        new_image_path = os.path.join(image_dir, f"char_{self.char_id}_restored{image_ext}")
                        
                        image_bytes = base64.b64decode(backup_data['image_data'])
                        with open(new_image_path, 'wb') as f:
                            f.write(image_bytes)
                        
                        char_data['image_path'] = new_image_path
                    except Exception as e:
                        print(f"[백업] 이미지 복원 실패: {e}")
                
                # 기타 설정 적용
                if 'scale' in backup_data:
                    char_data['scale'] = backup_data['scale']
                if 'bubble_color' in backup_data:
                    char_data['bubble_color'] = backup_data['bubble_color']
                if 'bubble_size' in backup_data:
                    char_data['bubble_size'] = backup_data['bubble_size']
                if 'facing_direction' in backup_data:
                    char_data['facing_direction'] = backup_data['facing_direction']
                if 'catchphrase' in backup_data:
                    char_data['catchphrase'] = backup_data['catchphrase']
            
            # 상세 완료 메시지
            has_image = "✅" if backup_data.get('image_data') else "❌"
            has_ai = "✅" if backup_data.get('ai_cache') else "❌"
            
            QMessageBox.information(self, "불러오기 완료", 
                f"'{backup_name}' 데이터를 불러왔습니다.\n\n"
                f"💡 저장 버튼을 눌러 적용하세요.")
            
        except json.JSONDecodeError:
            QMessageBox.critical(self, "불러오기 실패", "올바른 JSON 파일이 아닙니다.")
        except Exception as e:
            QMessageBox.critical(self, "불러오기 실패", f"불러오기 중 오류가 발생했습니다.\n\n{str(e)}")
    
    def view_ai_dialogues(self):
        """생성된 대사 열람 다이얼로그 열기"""
        dialog = AIDialogueViewDialog(self.char_id, self.char_name, self.all_characters, self)
        dialog.exec_()
    
    def get_personality(self):
        return self.personality_edit.toPlainText().strip()
    
    def get_background_story(self):
        return self.background_story_edit.toPlainText().strip()
    
    def get_nicknames(self):
        result = {}
        for char_id, edit in self.nickname_edits.items():
            nickname = edit.text().strip()
            if nickname:
                result[char_id] = nickname
        return result
    
    def get_stories(self):
        result = {}
        for char_id, edit in self.story_edits.items():
            story = edit.text().strip()
            if story:
                result[char_id] = story
        return result
    
    def get_dialogues(self):
        result = []
        for edit in self.dialogue_edits:
            text = edit.text().strip()
            result.append(text if text else '')
        return result


class DialogueDialog(QDialog):
    """대사 설정 다이얼로그"""
    def __init__(self, char_id, char_name, all_characters, current_dialogues, parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.all_characters = all_characters  # {char_id: name}
        self.all_dialogues = current_dialogues  # 전체 대사 딕셔너리
        self.dialogues = current_dialogues.get(char_id, {'기본': ['(선택)', '(선택)', '(선택)']})
        self.dialogue_inputs = {}
        self.current_target = '기본'  # 현재 선택된 대상 추적
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}의 대사 설정")
        self.setMinimumSize(550, 500)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                border: none;
            }
            QComboBox, QLineEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 8px;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                color: #5A9C85;
            }
            QComboBox:hover, QLineEdit:focus {
                border: 2px solid #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 4px solid transparent;
                border-right: 4px solid transparent;
                border-top: 6px solid #8ECFB5;
                width: 0px;
                height: 0px;
                margin-right: 8px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                selection-background-color: #E8F5EE;
                selection-color: #5A9C85;
                color: #5A9C85;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                padding: 10px;
                font-size: 14px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # 타이틀
        title = QLabel(f"{self.char_name}의 대사")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 22px;
            font-weight: 700;
            color: #5A9C85;
            padding: 10px;
            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
        """)
        
        # 대상 선택
        target_layout = QHBoxLayout()
        target_label = QLabel("대상:")
        target_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700; color: #5A9C85;")
        
        self.target_combo = QComboBox()
        self.target_combo.addItem("기본")
        for cid, cname in self.all_characters.items():
            if cid != self.char_id:
                # 캐릭터 이름으로 표시
                self.target_combo.addItem(cname, cid)
        self.target_combo.currentIndexChanged.connect(self.on_target_changed)
        
        target_layout.addWidget(target_label)
        target_layout.addWidget(self.target_combo, 1)
        
        # 스크롤 영역 - 깨끗한 흰색 배경
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                background-color: white;
                border-radius: 12px;
            }
        """)
        
        self.scroll_content = QWidget()
        self.scroll_content.setStyleSheet("background-color: white;")
        self.scroll_layout = QVBoxLayout()
        self.scroll_layout.setSpacing(10)
        self.scroll_layout.setContentsMargins(15, 15, 15, 15)
        
        self.scroll_content.setLayout(self.scroll_layout)
        scroll.setWidget(self.scroll_content)
        
        # 초기 대사 입력칸 생성
        self.load_dialogue_inputs('기본')
        
        # 버튼 레이아웃
        button_layout = QHBoxLayout()
        
        # 저장 버튼
        save_button = QPushButton("저장")
        save_button.clicked.connect(self.save_and_stay)
        save_button.setMinimumHeight(45)
        
        # 닫기 버튼
        close_button = QPushButton("닫기")
        close_button.clicked.connect(self.accept)
        close_button.setMinimumHeight(45)
        close_button.setStyleSheet("""
            QPushButton {
                background-color: #B8E6D0;
                color: white;
            }
            QPushButton:hover {
                background-color: #A5DBC3;
            }
        """)
        
        button_layout.addWidget(save_button)
        button_layout.addWidget(close_button)
        
        layout.addWidget(title)
        layout.addLayout(target_layout)
        layout.addWidget(scroll, 1)
        layout.addLayout(button_layout)
        
        self.setLayout(layout)
    
    def on_target_changed(self, index):
        """대상 변경 시 대사 입력칸 업데이트"""
        # 이전 대상의 대사 저장
        old_target = self.current_target
        dialogues = []
        for input_widget in self.dialogue_inputs.get(old_target, []):
            text = input_widget.text().strip()
            dialogues.append(text if text else '(선택)')
        if dialogues:
            self.dialogues[old_target] = dialogues
        
        # 새 대상 설정
        if index == 0:
            self.current_target = '기본'
        else:
            target_data = self.target_combo.currentData()
            if target_data is not None:
                self.current_target = f'char_{target_data}'
            else:
                # currentData가 None이면 인덱스로 계산
                self.current_target = '기본'
        
        # 새 대상의 대사 로드
        self.load_dialogue_inputs(self.current_target)
    
    def save_current_dialogues(self):
        """현재 입력된 대사 저장"""
        current_index = self.target_combo.currentIndex()
        if current_index == 0:
            target_key = '기본'
        else:
            target_data = self.target_combo.currentData()
            if target_data is not None:
                target_key = f'char_{target_data}'
            else:
                target_key = '기본'
        
        dialogues = []
        for input_widget in self.dialogue_inputs.get(target_key, []):
            text = input_widget.text().strip()
            # 빈 칸이면 (선택)으로 저장
            dialogues.append(text if text else '(선택)')
        
        self.dialogues[target_key] = dialogues
    
    def load_dialogue_inputs(self, target_key):
        """대사 입력칸 로드"""
        # 기존 위젯 제거
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # 대사 가져오기
        dialogues = self.dialogues.get(target_key, ['(선택)', '(선택)', '(선택)'])
        
        self.dialogue_inputs[target_key] = []
        
        for i, dialogue in enumerate(dialogues):
            row = QHBoxLayout()
            
            label = QLabel(f"대사 {i+1}:")
            label.setMinimumWidth(60)
            label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700;")
            
            input_field = QLineEdit()
            
            # (선택)이면 빈 칸으로, 아니면 내용 표시
            if dialogue == '(선택)':
                input_field.setText('')
                input_field.setPlaceholderText('(선택)')
            else:
                input_field.setText(dialogue)
            
            # 텍스트 변경 시 색상 업데이트
            def update_color(text, field=input_field):
                if text.strip():
                    field.setStyleSheet("""
                        QLineEdit {
                            background-color: white;
                            border: 1px solid #C5E8D8;
                            border-radius: 12px;
                            padding: 6px;
                            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                            color: #5A9C85;
                        }
                        QLineEdit:focus {
                            border: 2px solid #8ECFB5;
                        }
                    """)
                else:
                    field.setStyleSheet("""
                        QLineEdit {
                            background-color: white;
                            border: 1px solid #C5E8D8;
                            border-radius: 12px;
                            padding: 6px;
                            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                            color: #BDBDBD;
                        }
                        QLineEdit:focus {
                            border: 2px solid #8ECFB5;
                        }
                    """)
            
            input_field.textChanged.connect(update_color)
            
            # 초기 색상 설정
            if dialogue and dialogue != '(선택)':
                input_field.setStyleSheet("""
                    QLineEdit {
                        background-color: white;
                        border: 1px solid #C5E8D8;
                        border-radius: 12px;
                        padding: 6px;
                        font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                        color: #5A9C85;
                    }
                    QLineEdit:focus {
                        border: 2px solid #8ECFB5;
                    }
                """)
            else:
                input_field.setStyleSheet("""
                    QLineEdit {
                        background-color: white;
                        border: 1px solid #C5E8D8;
                        border-radius: 12px;
                        padding: 6px;
                        font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                        color: #BDBDBD;
                    }
                    QLineEdit:focus {
                        border: 2px solid #8ECFB5;
                    }
                """)
            
            row.addWidget(label)
            row.addWidget(input_field, 1)
            
            # 삭제 버튼 (기본 3개 이상일 때만)
            if i >= 3:
                delete_btn = QPushButton("✕")
                delete_btn.setFixedSize(30, 30)
                delete_btn.setStyleSheet("""
                    QPushButton {
                        background-color: #FFB5BA;
                        font-size: 15px;
                        padding: 0px;
                        border-radius: 12px;
                    }
                    QPushButton:hover {
                        background-color: #FFA5AB;
                    }
                """)
                delete_btn.clicked.connect(lambda checked, idx=i: self.delete_dialogue(target_key, idx))
                row.addWidget(delete_btn)
            
            self.dialogue_inputs[target_key].append(input_field)
            self.scroll_layout.addLayout(row)
        
        # 스페이서 추가
        self.scroll_layout.addStretch()
        
        # 추가 버튼 (제일 하단)
        add_btn = QPushButton("대사 추가")  # 이모티콘 제거
        add_btn.clicked.connect(lambda: self.add_dialogue(target_key))
        add_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                font-weight: 700;
                border-radius: 12px;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        self.scroll_layout.addWidget(add_btn)
    
    def add_dialogue(self, target_key):
        """대사 추가"""
        self.save_current_dialogues()
        if target_key not in self.dialogues:
            self.dialogues[target_key] = []
        self.dialogues[target_key].append('(선택)')
        self.load_dialogue_inputs(target_key)
    
    def delete_dialogue(self, target_key, index):
        """대사 삭제"""
        self.save_current_dialogues()
        if target_key in self.dialogues and len(self.dialogues[target_key]) > index:
            self.dialogues[target_key].pop(index)
        self.load_dialogue_inputs(target_key)
    
    def save_and_stay(self):
        """저장하고 창은 유지"""
        # 현재 대상의 대사 저장
        dialogues = []
        for input_widget in self.dialogue_inputs.get(self.current_target, []):
            text = input_widget.text().strip()
            dialogues.append(text if text else '(선택)')
        if dialogues:
            self.dialogues[self.current_target] = dialogues
        
        # 전체 대사 딕셔너리 업데이트
        self.all_dialogues[self.char_id] = self.dialogues
        
        print(f"[대사 저장] 캐릭터 {self.char_id}, 대상 {self.current_target}: {len(dialogues)}개")
        

        # 수동 대사를 AI 캐시에 동기화
        sync_dialogues_to_ai_cache(self.char_id, self.dialogues)

        # 캐릭터 위젯 업데이트 및 파일 저장 (부모가 MainWindow인 경우)
        if self.parent() and hasattr(self.parent(), 'update_character_dialogues'):
            self.parent().update_character_dialogues()
            self.parent().save_characters()
        # 저장 팝업 - 위치 조정
        msg = QMessageBox(self)
        msg.setWindowTitle("저장 완료")
        msg.setText("대사가 저장되었습니다!")
        msg.setIcon(QMessageBox.Information)
        
        # 팝업 크기 조정 (오른쪽 여유 추가)
        msg.setStyleSheet("""
            QMessageBox {
                min-width: 280px;
            }
            QLabel {
                min-width: 220px;
                padding-right: 20px;
            }
        """)
        
        msg.exec_()
    
    def get_dialogues(self):
        """설정된 대사 반환"""
        # 현재 보고 있던 대상의 대사 저장
        dialogues = []
        for input_widget in self.dialogue_inputs.get(self.current_target, []):
            text = input_widget.text().strip()
            dialogues.append(text if text else '(선택)')
        if dialogues:
            self.dialogues[self.current_target] = dialogues
        
        # 전체 대사 딕셔너리 업데이트
        self.all_dialogues[self.char_id] = self.dialogues
        
        return self.dialogues


class RelationshipDialog(QDialog):
    """감정 기반 관계 설정 다이얼로그"""
    
    # 감정 목록 (10개)
    FEELINGS = ["사랑", "우정", "동경", "신뢰", "장난", "짜증", "질투", "증오", "어색", "무관심"]
    
    # 감정별 이모티콘
    FEELING_EMOJIS = {
        "사랑": "💕", "우정": "🤝", "동경": "✨", "신뢰": "🤗",
        "장난": "😜", "짜증": "😤", "질투": "🔥", "증오": "💢",
        "어색": "😶", "무관심": "😐"
    }
    
    def __init__(self, char_id, char_name, all_characters, current_relationships, parent=None):
        super().__init__(parent)
        self.char_id = char_id
        self.char_name = char_name
        self.all_characters = all_characters  # {char_id: name}
        
        print(f"[RelationshipDialog] 초기화 - char_id: {char_id}, char_name: {char_name}")
        print(f"[RelationshipDialog] current_relationships: {current_relationships}")
        
        # 현재 감정 설정 복사 (새 형식: {other_id: {"my_feeling": "감정", "their_feeling": "감정"}})
        self.feelings = {}
        for key, value in current_relationships.items():
            if char_id in key:
                other_id = key[0] if key[1] == char_id else key[1]
                print(f"[RelationshipDialog] key={key}, other_id={other_id}, value={value}")
                if isinstance(value, dict):
                    # 새 형식
                    my_feeling = value.get(char_id, "무관심")
                    their_feeling = value.get(other_id, "무관심")
                    print(f"[RelationshipDialog] char_id={char_id} 감정: {my_feeling}, other_id={other_id} 감정: {their_feeling}")
                    self.feelings[other_id] = {
                        "my_feeling": my_feeling,
                        "their_feeling": their_feeling
                    }
                else:
                    # 구 형식 호환 - 변환
                    my_f, their_f = self._convert_old_relationship(value, key, char_id)
                    self.feelings[other_id] = {"my_feeling": my_f, "their_feeling": their_f}
        
        print(f"[RelationshipDialog] self.feelings: {self.feelings}")
        
        self.combo_boxes = {}  # {other_id: combo}
        self.init_ui()
    
    def _convert_old_relationship(self, old_rel, key, char_id):
        """구 형식 관계를 새 감정 형식으로 변환"""
        other_id = key[0] if key[1] == char_id else key[1]
        
        # 비대칭 관계 처리 (예: "애정/증오:me")
        if ":" in str(old_rel):
            base_rel, who = old_rel.rsplit(":", 1)
            parts = base_rel.split("/")
            if len(parts) == 2:
                if who == 'me':
                    return self._map_old_feeling(parts[0]), self._map_old_feeling(parts[1])
                else:
                    return self._map_old_feeling(parts[1]), self._map_old_feeling(parts[0])
        
        # 일반 관계 매핑
        rel_to_feelings = {
            "친구": ("우정", "우정"),
            "파트너": ("신뢰", "신뢰"),
            "연인": ("사랑", "사랑"),
            "라이벌": ("질투", "질투"),
            "적": ("증오", "증오"),
            "낯선 사이": ("무관심", "무관심"),
        }
        return rel_to_feelings.get(old_rel, ("무관심", "무관심"))
    
    def _map_old_feeling(self, old_feeling):
        """구 감정명을 새 감정명으로 매핑"""
        mapping = {
            "애정": "사랑", "증오": "증오", "무관심": "무관심",
            "장난": "장난", "짜증": "짜증", "존경": "동경",
            "질투": "질투", "집착": "사랑", "두려움": "어색",
            "친근": "우정", "경계": "어색", "신뢰": "신뢰", "의심": "어색"
        }
        return mapping.get(old_feeling, "무관심")
    
    def init_ui(self):
        self.setWindowTitle(f"{self.char_name}의 관계")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setMinimumSize(500, 500)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # 메인 컨테이너 (흰색 배경, 테두리)
        container = QWidget(self)
        container.setObjectName("relationContainer")
        container.setStyleSheet("""
            #relationContainer {
                background-color: white;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                border: none;
                background: transparent;
            }
            QComboBox {
                background-color: white;
                border: 1px solid #9DD4BA;
                border-radius: 10px;
                padding: 8px 12px;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                color: #5A9C85;
                min-height: 20px;
            }
            QComboBox:hover {
                border: 2px solid #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                width: 20px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 6px solid #9DD4BA;
                margin-right: 8px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #9DD4BA;
                selection-background-color: #E8F5EE;
                selection-color: #5A9C85;
                color: #5A9C85;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                padding: 14px;
                font-size: 15px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
            QScrollArea {
                border: none;
                background-color: transparent;
            }
            QScrollBar:vertical {
                background: transparent;
                width: 8px;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 4px;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0;
            }
        """)
        
        main_layout = QVBoxLayout(container)
        main_layout.setContentsMargins(20, 16, 20, 20)
        main_layout.setSpacing(20)
        
        # 헤더 (X버튼)
        header = QHBoxLayout()
        header.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        header.addWidget(close_btn)
        main_layout.addLayout(header)
        
        # 타이틀
        title = QLabel(f"{self.char_name}의 관계")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 20px;
            font-weight: 700;
            color: #317C75;
        """)
        main_layout.addWidget(title)
        
        # 스크롤 영역
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        
        scroll_content = QWidget()
        scroll_content.setStyleSheet("background: transparent;")
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setSpacing(32)
        scroll_layout.setContentsMargins(0, 0, 10, 0)
        
        # 다른 캐릭터들에 대한 감정 설정
        for other_id, other_name in self.all_characters.items():
            if other_id == self.char_id:
                continue
            
            char_section = QWidget()
            char_section.setStyleSheet("background: transparent;")
            section_layout = QVBoxLayout(char_section)
            section_layout.setSpacing(8)
            section_layout.setContentsMargins(0, 0, 0, 0)
            
            # "to" 태그 + 캐릭터 이름
            name_row = QHBoxLayout()
            name_row.setSpacing(8)
            
            to_label = QLabel("to")
            to_label.setFixedSize(24, 20)
            to_label.setAlignment(Qt.AlignCenter)
            to_label.setStyleSheet("""
                background-color: #8ECFB5;
                color: white;
                border-radius: 4px;
                font-size: 11px;
                font-weight: 700;
            """)
            name_row.addWidget(to_label)
            
            char_name_label = QLabel(other_name)
            char_name_label.setStyleSheet("""
                font-size: 15px;
                font-weight: 700;
                color: #317C75;
            """)
            name_row.addWidget(char_name_label)
            name_row.addStretch()
            section_layout.addLayout(name_row)
            
            # 관계 콤보박스
            combo = QComboBox()
            combo.view().setStyleSheet("""
                QAbstractItemView {
                    background-color: white;
                    border: 1px solid #9DD4BA;
                    selection-background-color: #E8F5EE;
                    selection-color: #5A9C85;
                    color: #5A9C85;
                    outline: none;
                }
                QAbstractItemView::item {
                    padding: 8px;
                    background-color: white;
                    color: #5A9C85;
                }
                QAbstractItemView::item:hover {
                    background-color: #E8F5EE;
                }
            """)
            for feeling in self.FEELINGS:
                emoji = self.FEELING_EMOJIS.get(feeling, "")
                combo.addItem(f"{feeling}", feeling)
            
            # 현재 감정 설정
            current_feeling = self.feelings.get(other_id, {}).get("my_feeling", "무관심")
            index = self.FEELINGS.index(current_feeling) if current_feeling in self.FEELINGS else 9
            combo.setCurrentIndex(index)
            self.combo_boxes[other_id] = combo
            section_layout.addWidget(combo)
            
            scroll_layout.addWidget(char_section)
        
        scroll_layout.addStretch()
        scroll.setWidget(scroll_content)
        main_layout.addWidget(scroll, 1)
        
        # 저장 버튼
        save_btn = QPushButton("저장")
        save_btn.setMinimumHeight(45)
        save_btn.clicked.connect(self.accept)
        main_layout.addWidget(save_btn)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
    
    def get_relationships(self):
        """설정된 감정 반환 (새 형식: my_feeling만)"""
        result = {}
        for other_id, combo in self.combo_boxes.items():
            my_feeling = combo.currentData()
            # currentData가 None이면 currentText 사용
            if my_feeling is None:
                my_feeling = combo.currentText().strip()
            # 여전히 빈 값이면 기본값
            if not my_feeling:
                my_feeling = "무관심"
            result[other_id] = my_feeling
            print(f"[get_relationships] other_id={other_id}, feeling={my_feeling}")
        return result


class BubbleColorDialog(QDialog):
    """말풍선 색상 및 크기 선택 다이얼로그"""
    # 실시간 변경 시그널
    preview_changed = pyqtSignal(str, int)  # color, size
    
    def __init__(self, current_color='#81C784', current_size=100, parent=None):
        super().__init__(parent)
        self.selected_color = current_color
        self.selected_size = current_size
        self.color_buttons = []
        self.custom_btn = None
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle("말풍선 설정")
        self.setFixedSize(420, 450)
        
        self.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton {
                border: none;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(30, 25, 30, 25)
        
        # ===== 색상 섹션 =====
        color_label = QLabel("말풍선 색상")
        color_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700; color: #3D7A5F;")
        layout.addWidget(color_label)
        
        # 색상 팔레트 (흰색 배경)
        color_container = QWidget()
        color_container.setStyleSheet("""
            background-color: white;
            border-radius: 15px;
            border: 1px solid #C5E8D8;
        """)
        
        color_layout = QVBoxLayout()
        color_layout.setSpacing(8)
        color_layout.setContentsMargins(15, 15, 15, 15)
        
        colors = [
            "#FFB5BA", "#FFCDD2", "#F8BBD9", "#E1BEE7", "#D1C4E9",
            "#BBDEFB", "#B2EBF2", "#B2DFDB", "#C8E6C9", "#8ECFB5",
            "#FFF9C4", "#FFE0B2", "#FFCCBC", "#CFD8DC",
        ]
        
        for row in range(3):
            row_layout = QHBoxLayout()
            row_layout.setSpacing(6)
            row_layout.addStretch()
            
            for col in range(5):
                idx = row * 5 + col
                
                if row == 2 and col == 4:
                    self.custom_btn = QPushButton("+")
                    self.custom_btn.setFixedSize(42, 42)
                    self.custom_btn.setStyleSheet("""
                        QPushButton {
                            background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                                stop:0 #FFB5BA, stop:0.2 #FFE0B2, 
                                stop:0.4 #FFF9C4, stop:0.6 #C8E6C9, 
                                stop:0.8 #BBDEFB, stop:1 #E1BEE7);
                            border-radius: 21px;
                            border: 3px solid transparent;
                            font-size: 20px;
                            font-weight: 700; font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                            color: #666;
                        }
                        QPushButton:hover {
                            border: 3px solid #5A9C85;
                        }
                    """)
                    self.custom_btn.clicked.connect(self.open_color_picker)
                    row_layout.addWidget(self.custom_btn)
                elif idx < len(colors):
                    color_hex = colors[idx]
                    
                    btn = QPushButton()
                    btn.setFixedSize(42, 42)
                    btn.color_value = color_hex
                    
                    if color_hex.upper() == self.selected_color.upper():
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background-color: {color_hex};
                                border-radius: 21px;
                                border: 4px solid #5A9C85;
                            }}
                        """)
                    else:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background-color: {color_hex};
                                border-radius: 21px;
                                border: 3px solid transparent;
                            }}
                            QPushButton:hover {{
                                border: 3px solid #5A9C85;
                            }}
                        """)
                    
                    btn.clicked.connect(lambda checked, c=color_hex, b=btn: self.select_color(c, b))
                    self.color_buttons.append(btn)
                    row_layout.addWidget(btn)
            
            row_layout.addStretch()
            color_layout.addLayout(row_layout)
        
        color_container.setLayout(color_layout)
        layout.addWidget(color_container)
        
        # ===== 크기 섹션 =====
        size_label = QLabel("말풍선 크기")
        size_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700; color: #3D7A5F;")
        layout.addWidget(size_label)
        
        # 크기 컨테이너
        size_container = QWidget()
        size_container.setStyleSheet("""
            background-color: white;
            border-radius: 15px;
            border: 1px solid #C5E8D8;
        """)
        
        size_layout = QVBoxLayout()
        size_layout.setSpacing(10)
        size_layout.setContentsMargins(20, 15, 20, 15)
        
        # 슬라이더 + 값 표시
        slider_row = QHBoxLayout()
        slider_row.setSpacing(15)
        
        self.size_slider = QSlider(Qt.Horizontal)
        self.size_slider.setMinimum(50)
        self.size_slider.setMaximum(200)
        self.size_slider.setValue(self.selected_size)
        self.size_slider.setStyleSheet("""
            QSlider {
                background: transparent;
                border: none;
            }
            QSlider::groove:horizontal {
                background: #E0E0E0;
                height: 8px;
                border-radius: 4px;
                border: none;
            }
            QSlider::handle:horizontal {
                background: #8ECFB5;
                border: 2px solid #5A9C85;
                width: 20px;
                height: 20px;
                margin: -6px 0;
                border-radius: 10px;
            }
            QSlider::handle:horizontal:hover {
                background: #7BC4A8;
            }
            QSlider::sub-page:horizontal {
                background: #8ECFB5;
                border-radius: 4px;
                border: none;
            }
        """)
        self.size_slider.valueChanged.connect(self.on_size_changed)
        
        self.size_value_label = QLabel(f"{self.selected_size}%")
        self.size_value_label.setFixedWidth(65)
        self.size_value_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.size_value_label.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #5A9C85;
            background: transparent;
            border: none;
            padding-right: 5px;
        """)
        
        slider_row.addWidget(self.size_slider)
        slider_row.addWidget(self.size_value_label)
        
        size_layout.addLayout(slider_row)
        
        # 프리셋 버튼들
        preset_row = QHBoxLayout()
        preset_row.setSpacing(8)
        preset_row.addStretch()
        
        for size in [75, 100, 125, 150]:
            preset_btn = QPushButton(f"{size}%")
            preset_btn.setFixedSize(58, 36)
            preset_btn.setCursor(Qt.PointingHandCursor)
            preset_btn.setStyleSheet("""
                QPushButton {
                    background-color: #F0FAF5;
                    color: #5A9C85;
                    border: 1px solid #C5E8D8;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 700;
                    font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                    padding: 0px;
                }
                QPushButton:hover {
                    background-color: #D4EDE1;
                }
            """)
            preset_btn.clicked.connect(lambda checked, s=size: self.set_size_preset(s))
            preset_row.addWidget(preset_btn)
        
        preset_row.addStretch()
        size_layout.addLayout(preset_row)
        
        size_container.setLayout(size_layout)
        layout.addWidget(size_container)
        
        # 확인 버튼
        ok_button = QPushButton("적용")
        ok_button.clicked.connect(self.accept)
        ok_button.setMinimumHeight(45)
        ok_button.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                padding: 12px;
                border-radius: 12px;
                font-size: 15px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        layout.addWidget(ok_button)
        self.setLayout(layout)
    
    def on_size_changed(self, value):
        self.selected_size = value
        self.size_value_label.setText(f"{value}%")
        self.preview_changed.emit(self.selected_color, self.selected_size)
    
    def set_size_preset(self, size):
        self.size_slider.setValue(size)
    
    def select_color(self, color, clicked_btn):
        self.selected_color = color
        
        for btn in self.color_buttons:
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {btn.color_value};
                    border-radius: 21px;
                    border: 3px solid transparent;
                }}
                QPushButton:hover {{
                    border: 3px solid #5A9C85;
                }}
            """)
        
        if self.custom_btn:
            self.custom_btn.setStyleSheet("""
                QPushButton {
                    background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                        stop:0 #FFB5BA, stop:0.2 #FFE0B2, 
                        stop:0.4 #FFF9C4, stop:0.6 #C8E6C9, 
                        stop:0.8 #BBDEFB, stop:1 #E1BEE7);
                    border-radius: 21px;
                    border: 3px solid transparent;
                    font-size: 18px;
                }
                QPushButton:hover {
                    border: 3px solid #5A9C85;
                }
            """)
        
        clicked_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: {color};
                border-radius: 21px;
                border: 4px solid #5A9C85;
            }}
        """)
        self.preview_changed.emit(self.selected_color, self.selected_size)
    
    def open_color_picker(self):
        color = QColorDialog.getColor(QColor(self.selected_color), self, "색상 선택")
        if color.isValid():
            self.selected_color = color.name()
            
            for btn in self.color_buttons:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background-color: {btn.color_value};
                        border-radius: 21px;
                        border: 3px solid transparent;
                    }}
                    QPushButton:hover {{
                        border: 3px solid #5A9C85;
                    }}
                """)
            
            self.custom_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {self.selected_color};
                    border-radius: 21px;
                    border: 4px solid #5A9C85;
                    font-size: 18px;
                }}
            """)
            self.preview_changed.emit(self.selected_color, self.selected_size)
    
    def get_color(self):
        return self.selected_color
    
    def get_size(self):
        return self.selected_size


class ScaleDialog(QDialog):
    """캐릭터 크기 조정 다이얼로그 (미리보기 지원)"""
    def __init__(self, current_scale=100, parent=None, character=None):
        super().__init__(parent)
        self.selected_scale = current_scale
        self.original_scale = current_scale  # 취소 시 복원용
        self.character = character  # 미리보기용 캐릭터
        self.init_ui()
    
    def init_ui(self):
        self.setWindowTitle("크기 조정")
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(360, 260)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        # 메인 컨테이너
        container = QWidget(self)
        container.setGeometry(0, 0, 360, 260)
        container.setObjectName("scaleContainer")
        container.setStyleSheet("""
            #scaleContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X 버튼 (크레딧 다이얼로그와 동일)
        from PyQt5.QtSvg import QSvgRenderer
        self.close_btn = QPushButton(container)
        self.close_btn.setGeometry(320, 10, 28, 28)
        self.close_btn.setCursor(Qt.PointingHandCursor)
        self.close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            self.close_btn.setIcon(QIcon(pixmap))
            self.close_btn.setIconSize(QSize(20, 20))
        self.close_btn.clicked.connect(self.on_cancel)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(12)
        
        # 타이틀
        title = QLabel("캐릭터 크기")
        title.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #3D7A5F;
            font-family: 'Pretendard', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # 크기 컨테이너
        size_container = QWidget()
        size_container.setStyleSheet("""
            background-color: #E8F5EE;
            border-radius: 15px;
            border: none;
        """)
        
        size_layout = QVBoxLayout()
        size_layout.setSpacing(10)
        size_layout.setContentsMargins(15, 12, 15, 12)
        
        # 슬라이더 + 값 표시
        slider_row = QHBoxLayout()
        slider_row.setSpacing(12)
        
        self.scale_slider = QSlider(Qt.Horizontal)
        self.scale_slider.setMinimum(50)
        self.scale_slider.setMaximum(1000)
        self.scale_slider.setValue(self.selected_scale)
        self.scale_slider.setStyleSheet("""
            QSlider {
                background: transparent;
                border: none;
            }
            QSlider::groove:horizontal {
                background: #D0D0D0;
                height: 8px;
                border-radius: 4px;
                border: none;
            }
            QSlider::handle:horizontal {
                background: #8ECFB5;
                border: 2px solid #5A9C85;
                width: 20px;
                height: 20px;
                margin: -6px 0;
                border-radius: 10px;
            }
            QSlider::handle:horizontal:hover {
                background: #7BC4A8;
            }
            QSlider::sub-page:horizontal {
                background: #8ECFB5;
                border-radius: 4px;
                border: none;
            }
        """)
        self.scale_slider.valueChanged.connect(self.on_scale_changed)
        
        self.scale_value_label = QLabel(f"{self.selected_scale}%")
        self.scale_value_label.setFixedWidth(60)
        self.scale_value_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.scale_value_label.setStyleSheet("""
            font-size: 15px;
            font-weight: 700;
            color: #5A9C85;
            background: transparent;
            border: none;
        """)
        
        slider_row.addWidget(self.scale_slider)
        slider_row.addWidget(self.scale_value_label)
        
        size_layout.addLayout(slider_row)
        
        # 버튼 줄 사이 간격
        size_layout.addSpacing(5)
        
        # 프리셋 버튼들 - 첫 번째 줄
        preset_row1 = QHBoxLayout()
        preset_row1.setSpacing(10)
        preset_row1.addStretch()
        
        for scale in [100, 150, 200]:
            preset_btn = QPushButton(f"{scale}%")
            preset_btn.setFixedSize(90, 38)
            preset_btn.setCursor(Qt.PointingHandCursor)
            preset_btn.setStyleSheet("""
                QPushButton {
                    background-color: #F0FAF5;
                    color: #5A9C85;
                    border: 1px solid #C5E8D8;
                    border-radius: 10px;
                    font-size: 12px;
                    font-weight: 700;
                    font-family: 'Pretendard', sans-serif;
                }
                QPushButton:hover {
                    background-color: #D4F4DD;
                    border-color: #8ECFB5;
                }
            """)
            preset_btn.clicked.connect(lambda checked, s=scale: self.set_scale_preset(s))
            preset_row1.addWidget(preset_btn)
        
        preset_row1.addStretch()
        size_layout.addLayout(preset_row1)
        
        # 프리셋 버튼들 - 두 번째 줄
        preset_row2 = QHBoxLayout()
        preset_row2.setSpacing(10)
        preset_row2.addStretch()
        
        for scale in [300, 500, 1000]:
            preset_btn = QPushButton(f"{scale}%")
            preset_btn.setFixedSize(90, 38)
            preset_btn.setCursor(Qt.PointingHandCursor)
            preset_btn.setStyleSheet("""
                QPushButton {
                    background-color: #F0FAF5;
                    color: #5A9C85;
                    border: 1px solid #C5E8D8;
                    border-radius: 10px;
                    font-size: 12px;
                    font-weight: 700;
                    font-family: 'Pretendard', sans-serif;
                }
                QPushButton:hover {
                    background-color: #D4F4DD;
                    border-color: #8ECFB5;
                }
            """)
            preset_btn.clicked.connect(lambda checked, s=scale: self.set_scale_preset(s))
            preset_row2.addWidget(preset_btn)
        
        preset_row2.addStretch()
        size_layout.addLayout(preset_row2)
        
        size_container.setLayout(size_layout)
        layout.addWidget(size_container)
        
        # 적용 버튼
        apply_btn = QPushButton("적용")
        apply_btn.setMinimumHeight(42)
        apply_btn.setCursor(Qt.PointingHandCursor)
        apply_btn.setStyleSheet("""
            QPushButton {
                background: #8ECFB5;
                border-radius: 12px;
                color: white;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #7BC4A8;
            }
        """)
        apply_btn.clicked.connect(self.accept)
        layout.addWidget(apply_btn)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(self)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        # X 버튼을 맨 위로 올림
        self.close_btn.raise_()
    
    def on_scale_changed(self, value):
        """슬라이더 값 변경 시 - 미리보기"""
        self.selected_scale = value
        self.scale_value_label.setText(f"{value}%")
        
        # 미리보기: 실시간으로 캐릭터 크기 변경
        if self.character:
            self.character.update_scale(value)
    
    def set_scale_preset(self, scale):
        """프리셋 버튼 클릭 시"""
        self.selected_scale = scale
        self.scale_slider.setValue(scale)
        self.scale_value_label.setText(f"{scale}%")
        
        # 미리보기
        if self.character:
            self.character.update_scale(scale)
    
    def on_cancel(self):
        """취소 시 원래 크기로 복원"""
        if self.character:
            self.character.update_scale(self.original_scale)
        self.reject()
    
    def get_scale(self):
        """선택된 크기 반환"""
        return self.selected_scale


class NameEditDialog(QDialog):
    """이름 수정 커스텀 다이얼로그"""
    def __init__(self, current_name="", parent=None):
        super().__init__(parent)
        self.current_name = current_name
        self.new_name = current_name
        self.init_ui()
    
    def init_ui(self):
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(320, 170)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # 메인 컨테이너 (라운드 모서리)
        container = QWidget(self)
        container.setGeometry(0, 0, 320, 170)
        container.setStyleSheet("""
            QWidget {
                background-color: #E8F5EE;
                border-radius: 16px;
            }
        """)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(15)
        
        # 헤더 (타이틀 + X버튼)
        header = QHBoxLayout()
        title = QLabel("이름 수정")
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
        """)
        header.addWidget(title)
        header.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        header.addWidget(close_btn)
        layout.addLayout(header)
        
        # 입력 필드
        self.name_edit = QLineEdit()
        self.name_edit.setText(self.current_name)
        self.name_edit.setMinimumHeight(40)
        self.name_edit.returnPressed.connect(self.accept)  # 엔터 키로 입력 완료
        self.name_edit.setStyleSheet("""
            QLineEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 10px 15px;
                font-size: 14px;
                font-weight: 700;
                color: #317C75;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLineEdit:focus {
                border: 2px solid #8ECFB5;
            }
        """)
        layout.addWidget(self.name_edit)
        
        # 입력하기 버튼
        ok_btn = QPushButton("입력하기")
        ok_btn.setMinimumHeight(42)
        ok_btn.setCursor(Qt.PointingHandCursor)
        ok_btn.clicked.connect(self.accept)
        ok_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        layout.addWidget(ok_btn)
    
    def get_name(self):
        return self.name_edit.text()


class DeleteConfirmDialog(QDialog):
    """캐릭터 삭제 확인 커스텀 다이얼로그"""
    def __init__(self, char_name, parent=None):
        super().__init__(parent)
        self.char_name = char_name
        self.result = False
        self.init_ui()
    
    def init_ui(self):
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(320, 180)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # 메인 컨테이너 (흰색 배경, 테두리)
        container = QWidget(self)
        container.setGeometry(0, 0, 320, 180)
        container.setObjectName("deleteContainer")
        container.setStyleSheet("""
            QWidget#deleteContainer {
                background-color: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(15)
        
        # 헤더 (타이틀 + X버튼)
        header = QHBoxLayout()
        title = QLabel("캐릭터 삭제")
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            border: none;
            background: transparent;
        """)
        header.addWidget(title)
        header.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        header.addWidget(close_btn)
        layout.addLayout(header)
        
        # 메시지
        msg = QLabel(f'"{self.char_name}"을(를) 정말 삭제하시겠습니까?\n관련된 모든 데이터가 삭제됩니다.')
        msg.setAlignment(Qt.AlignCenter)
        msg.setWordWrap(True)
        msg.setStyleSheet("""
            font-size: 14px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            line-height: 1.5;
            border: none;
            background: transparent;
        """)
        layout.addWidget(msg)
        
        # 버튼들
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(10)
        
        yes_btn = QPushButton("Yes")
        yes_btn.setMinimumHeight(38)
        yes_btn.setCursor(Qt.PointingHandCursor)
        yes_btn.clicked.connect(self.on_yes)
        yes_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 30px;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        no_btn = QPushButton("No")
        no_btn.setMinimumHeight(38)
        no_btn.setCursor(Qt.PointingHandCursor)
        no_btn.clicked.connect(self.reject)
        no_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                color: #8ECFB5;
                border: 1px solid #8ECFB5;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 30px;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #FFE5E8;
                border-color: #E57373;
                color: #E57373;
            }
        """)
        
        btn_layout.addWidget(yes_btn)
        btn_layout.addWidget(no_btn)
        layout.addLayout(btn_layout)
    
    def on_yes(self):
        self.result = True
        self.accept()


class DirectionDialog(QDialog):
    """캐릭터 방향 선택 다이얼로그"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.selected_direction = 'front'
        self.init_ui()
    
    def init_ui(self):
        self.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        self.setFixedSize(340, 400)
        self.setAttribute(Qt.WA_TranslucentBackground)
        
        from PyQt5.QtSvg import QSvgRenderer
        
        # 메인 컨테이너 (라운드 모서리, 청록색 테두리)
        container = QWidget(self)
        container.setGeometry(0, 0, 340, 400)
        container.setStyleSheet("""
            QWidget {
                background-color: #E8F5EE;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        layout = QVBoxLayout(container)
        layout.setSpacing(10)
        layout.setContentsMargins(25, 15, 25, 20)
        
        # X 버튼 (오른쪽 상단)
        close_layout = QHBoxLayout()
        close_layout.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(self.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        close_layout.addWidget(close_btn)
        layout.addLayout(close_layout)
        
        # 타이틀
        title = QLabel("캐릭터가 어느 쪽을\n바라보고 있나요?")
        title.setAlignment(Qt.AlignCenter)
        title.setMinimumHeight(60)
        title.setStyleSheet("""
            font-size: 20px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            line-height: 1.5;
            border: none;
            background: transparent;
            padding: 8px 0px;
        """)
        layout.addWidget(title)
        
        # 설명
        desc = QLabel("(보는 사람 기준)")
        desc.setAlignment(Qt.AlignCenter)
        desc.setStyleSheet("""
            font-size: 13px; 
            font-weight: 700;
            color: #8ECFB5;
            font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(desc)
        
        layout.addSpacing(5)
        
        # 라디오 버튼 그룹 (흰색 배경, 테두리 없음)
        self.button_group = QButtonGroup()
        
        radio_container = QWidget()
        radio_container.setStyleSheet("""
            QWidget {
                background-color: white;
                border-radius: 12px;
                border: none;
            }
        """)
        radio_layout = QVBoxLayout(radio_container)
        radio_layout.setSpacing(8)
        radio_layout.setContentsMargins(15, 15, 15, 15)
        
        radio_style = """
            QRadioButton {
                font-size: 14px;
                font-weight: 700;
                color: #317C75;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                padding: 10px 8px;
                border: none;
                background: transparent;
                min-height: 28px;
            }
            QRadioButton::indicator {
                width: 18px;
                height: 18px;
            }
            QRadioButton::indicator:unchecked {
                border: 1px solid #C5E8D8;
                border-radius: 9px;
                background: white;
            }
            QRadioButton::indicator:checked {
                border: 2px solid #8ECFB5;
                border-radius: 9px;
                background-color: #8ECFB5;
            }
        """
        
        self.left_radio = QRadioButton("왼쪽을 바라보고 있어요")
        self.right_radio = QRadioButton("오른쪽을 바라보고 있어요")
        self.front_radio = QRadioButton("정면을 바라보고 있어요")
        
        self.left_radio.setStyleSheet(radio_style)
        self.right_radio.setStyleSheet(radio_style)
        self.front_radio.setStyleSheet(radio_style)
        
        self.left_radio.setMinimumHeight(44)
        self.right_radio.setMinimumHeight(44)
        self.front_radio.setMinimumHeight(44)
        
        self.front_radio.setChecked(True)
        
        self.button_group.addButton(self.left_radio, 0)
        self.button_group.addButton(self.right_radio, 1)
        self.button_group.addButton(self.front_radio, 2)
        
        radio_layout.addWidget(self.left_radio)
        radio_layout.addWidget(self.right_radio)
        radio_layout.addWidget(self.front_radio)
        
        layout.addWidget(radio_container)
        
        layout.addSpacing(5)
        
        # 확인 버튼
        ok_button = QPushButton("확인")
        ok_button.setMinimumHeight(45)
        ok_button.setCursor(Qt.PointingHandCursor)
        ok_button.clicked.connect(self.accept)
        ok_button.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                font-size: 15px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        layout.addWidget(ok_button)
    
    def get_direction(self):
        """선택된 방향 반환"""
        if self.left_radio.isChecked():
            return 'left'
        elif self.right_radio.isChecked():
            return 'right'
        else:
            return 'front'


class MainWindow(QMainWindow):
    """메인 윈도우"""
    def __init__(self):
        super().__init__()
        self.characters = []
        self.char_id_counter = 0
        self.character_data = {}  # {char_id: {'name': '', 'scale': 100, 'bubble_color': '#81C784'}}
        self.relationships = {}  # {(char_id1, char_id2): 'relationship_type'}
        self.dialogues = {}  # {char_id: {'기본': [...], 'char_0': [...], ...}}
        self.gemini_api_key = ""  # Gemini API 키
        self.gemini_model = "gemini-2.5-flash-lite"  # Gemini 모델
        self.ai_enabled = False  # AI 활성화 상태

        # 자동 백업 설정
        self.auto_backup_enabled = True  # 기본: 켜짐
        self.max_backups = 12  # 기본: 12개 유지

        # AI 대사 생성 완료 큐 (스레드 안전)
        self._ai_complete_queue = []
        self._current_ai_mode = None  # 'generate_now', 'uncached', 'cache', 'single', 'add'
        
        # 설정 파일 경로 (exe 옆에 저장)
        if getattr(sys, 'frozen', False):
            # PyInstaller로 빌드된 경우 - exe 옆
            self.app_dir = os.path.dirname(sys.executable)
        else:
            # Python 스크립트로 실행되는 경우 - py 옆
            self.app_dir = os.path.dirname(os.path.abspath(__file__))
        
        self.config_file = os.path.join(self.app_dir, 'kiwipet_config.json')
        print(f"[초기화] 설정 파일 경로: {self.config_file}")
        
        self.is_minimized = False  # 최소화 상태
        self.normal_size = (550, 700)  # 기본 크기
        
        # 드래그 앤 드롭 활성화
        self.setAcceptDrops(True)
        
        self.init_ui()
        
        # 저장된 캐릭터 로드
        self.load_characters()
        
        # API 키/모델 활성화
        if self.gemini_api_key:
            set_gemini_api_key(self.gemini_api_key)
        if self.gemini_model:
            set_gemini_model(self.gemini_model)
        if self.ai_enabled:
            set_ai_enabled(True)
            # AI 대사 캐시 생성 - 5초 후 시작
            QTimer.singleShot(5000, self.generate_ai_cache)
            print("[AI] 대사 생성 5초 후 시작 예정")
        
        # 충돌 감지 타이머
        self.collision_timer = QTimer()
        self.collision_timer.timeout.connect(self.check_collisions)
        self.collision_timer.start(100)
        
        # AI 완료 큐 처리 타이머 (100ms마다 체크)
        self.ai_queue_timer = QTimer()
        self.ai_queue_timer.timeout.connect(self._process_ai_complete_queue)
        self.ai_queue_timer.start(100)
        
        # AI 캐시 타이머 (캐시 유무에 따라 10분/2시간)
        self.ai_cache_timer = QTimer()
        self.ai_cache_timer.timeout.connect(self.regenerate_ai_cache)
        self.update_ai_timer_interval()  # 초기 간격 설정
        
        # 임시 대사 정리 타이머 (1분마다 체크)
        self.temp_cleanup_timer = QTimer()
        self.temp_cleanup_timer.timeout.connect(self.cleanup_temp_dialogues)
        self.temp_cleanup_timer.start(60 * 1000)  # 1분

        # 자동 백업 타이머 (1시간마다)
        self.auto_backup_timer = QTimer()
        self.auto_backup_timer.timeout.connect(self.create_auto_backup)
        if self.auto_backup_enabled:
            self.auto_backup_timer.start(60 * 60 * 1000)  # 1시간

    def update_ai_timer_interval(self):
        """타이머 간격 설정 (1시간마다)"""
        interval = 1 * 60 * 60 * 1000  # 1시간
        print("[AI 타이머] 1시간 간격")
        self.ai_cache_timer.start(interval)
    
    def cleanup_temp_dialogues(self):
        """임시 대사 정리"""
        cleanup_temp_dialogues()
    
    def init_ui(self):
        self.setWindowTitle("Kiwipet")

        self.setGeometry(100, 100, 650, 750)
        
        # 윈도우 아이콘 설정
        self.set_window_icon()
        
        # 귀여운 파스텔 민트 테마 🍀
        self.setStyleSheet("""
            QMainWindow {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QWidget {
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                padding: 12px 24px;
                font-size: 14px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
            QPushButton:pressed {
                background-color: #6BB89B;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLineEdit {
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
        """)
        
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        
        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(25, 8, 25, 25)
        main_layout.setSpacing(12)
        
        # 상단 헤더 (i 버튼, 로고, ? 버튼)
        header_layout = QVBoxLayout()
        header_layout.setSpacing(15)
        
        # ===== 1행: i 버튼 (왼쪽) - 로고 (중앙) - ? 버튼 (오른쪽) =====
        top_row = QHBoxLayout()
        top_row.setContentsMargins(0, 0, 0, 0)
        top_row.setAlignment(Qt.AlignTop)
        
        # i 버튼 (크레딧) - 28x28, 원형, 흰색 배경, 그림자
        info_btn = QPushButton()
        info_btn.setFixedSize(28, 28)
        info_btn.setCursor(Qt.PointingHandCursor)
        info_btn.clicked.connect(self.show_credit_dialog)
        info_btn.setStyleSheet("""
            QPushButton {
                background-color: #FFFFFF;
                border: none;
                border-radius: 14px;
                padding: 1px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
        """)
        # 그림자 효과
        info_shadow = QGraphicsDropShadowEffect()
        info_shadow.setBlurRadius(4)
        info_shadow.setOffset(0, 1)
        info_shadow.setColor(QColor("#BFC8C4"))
        info_btn.setGraphicsEffect(info_shadow)
        self._set_svg_icon(info_btn, SVG_INFO, 20)
        
        top_row.addWidget(info_btn)
        top_row.addStretch()
        
        # Kiwipet 로고 (중앙) - SVG 사용 (150x75px)
        title_label = QLabel()
        title_label.setAlignment(Qt.AlignCenter)
        
        # SVG로 타이틀 이미지 생성
        from PyQt5.QtSvg import QSvgRenderer
        svg_renderer = QSvgRenderer(SVG_KIWIPET_TITLE.encode('utf-8'))
        if svg_renderer.isValid():
            # 150x75px 크기
            target_width = 150
            target_height = 75
            
            title_pixmap = QPixmap(target_width, target_height)
            title_pixmap.fill(Qt.transparent)
            painter = QPainter(title_pixmap)
            svg_renderer.render(painter)
            painter.end()
            
            title_label.setPixmap(title_pixmap)
        else:
            title_label.setText("Kiwipet")
            title_label.setStyleSheet("""
                font-size: 28px;
                font-weight: 700; font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                font-style: italic;
                color: #4FB98F;
                font-family: 'Pretendard', sans-serif;
            """)
        
        top_row.addWidget(title_label)
        
        top_row.addStretch()
        
        # ? 버튼 (튜토리얼) - 28x28, 원형, 흰색 배경, 그림자
        # ? 버튼 (튜토리얼) - 28x28, 원형, 흰색 배경, 그림자
        help_btn = QPushButton()
        help_btn.setFixedSize(28, 28)
        help_btn.setCursor(Qt.PointingHandCursor)
        help_btn.clicked.connect(self.show_tutorial)
        help_btn.setStyleSheet("""
            QPushButton {
                background-color: #FFFFFF;
                border: none;
                border-radius: 14px;
                padding: 1px;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
            }
        """)
        # 그림자 효과
        help_shadow = QGraphicsDropShadowEffect()
        help_shadow.setBlurRadius(4)
        help_shadow.setOffset(0, 1)
        help_shadow.setColor(QColor("#BFC8C4"))
        help_btn.setGraphicsEffect(help_shadow)
        self._set_svg_icon(help_btn, SVG_QUESTION, 14)
        
        top_row.addWidget(help_btn)
        header_layout.addLayout(top_row)
        
        # ===== 2행: 설명 텍스트 박스 =====
        desc_box = QLabel(
            "1. 캐릭터를 추가하고 성격을 입력한 후, API를 활성화하세요.\n"
            "2. 1시간마다 자동으로 새로운 대사를 생성합니다.\n"
            "3. 캐릭터들의 관계에 따라 다양한 상호작용이 발생합니다.\n"
            "4. 생성된 대사는 성격 란에서 열람/삭제할 수 있습니다.\n"
            "5. 주기적으로 데이터를 백업하는 것을 권장합니다."
        )
        desc_box.setAlignment(Qt.AlignCenter)
        desc_box.setWordWrap(True)
        desc_box.setStyleSheet(f"""
            QLabel {{
                background-color: white;
                color: #317C75;
                font-size: 14px;
                font-weight: 700;
                padding: 15px 20px;
                border: 1px solid #C5E8D8;
                border-radius: 16px;
                font-family: {KOREAN_FONT};
                line-height: 19px;
                letter-spacing: -0.39px;
            }}
        """)
        header_layout.addWidget(desc_box)
        
        # ===== 3행: 상단 버튼들 (모니터, API KEY, 백업) =====
        btn_row = QHBoxLayout()
        btn_row.setSpacing(10)
        
        # 환경설정 버튼
        monitor_btn = QPushButton(" 환경설정")
        monitor_btn.setFixedHeight(36)
        monitor_btn.setCursor(Qt.PointingHandCursor)
        monitor_btn.clicked.connect(self.show_settings)
        monitor_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #317C75;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 10px;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        self._set_button_icon(monitor_btn, SVG_MONITOR, 16)
        
        # API KEY 버튼
        self.api_btn = QPushButton("API KEY")
        self.api_btn.setFixedHeight(36)
        self.api_btn.setCursor(Qt.PointingHandCursor)
        self.api_btn.clicked.connect(self.show_api_settings)
        self.api_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #317C75;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 10px;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        self._set_button_icon(self.api_btn, SVG_KEY, 16)
        
        # 캐릭터 백업 버튼
        backup_btn = QPushButton(" 캐릭터 백업")
        backup_btn.setFixedHeight(36)
        backup_btn.setCursor(Qt.PointingHandCursor)
        backup_btn.clicked.connect(self.backup_all_characters)
        backup_btn.setStyleSheet(f"""
            QPushButton {{
                background-color: #C5E8D8;
                color: #317C75;
                border: none;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 700;
                padding: 8px 10px;
                font-family: {KOREAN_FONT};
            }}
            QPushButton:hover {{
                background-color: #B0DBC8;
            }}
        """)
        self._set_button_icon(backup_btn, SVG_BACKUP, 16)
        
        btn_row.addWidget(monitor_btn)
        btn_row.addWidget(self.api_btn)
        btn_row.addWidget(backup_btn)
        header_layout.addLayout(btn_row)
        
        # 캐릭터 추가 버튼
        add_btn = QPushButton("캐릭터 추가하기")
        add_btn.clicked.connect(self.add_character)
        add_btn.setMinimumHeight(50)
        
        # 캐릭터 목록 스크롤 영역 - 깨끗한 흰색 배경, 더 둥글게
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 20px;
                background-color: white;
            }
            QScrollBar:vertical {
                background-color: #F0FAF5;
                width: 8px;
                border-radius: 4px;
                margin: 8px 4px;
            }
            QScrollBar::handle:vertical {
                background-color: #B8E6D0;
                border-radius: 4px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background-color: #8ECFB5;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        scroll.viewport().setStyleSheet("background-color: white; border-radius: 18px;")
        
        self.scroll_content = QWidget()
        self.scroll_content.setStyleSheet("background-color: white; border-radius: 18px;")
        self.scroll_layout = QVBoxLayout()
        self.scroll_layout.setSpacing(12)
        self.scroll_layout.setContentsMargins(18, 18, 18, 18)
        self.scroll_layout.addStretch()
        self.scroll_content.setLayout(self.scroll_layout)
        scroll.setWidget(self.scroll_content)
        
        # 레이아웃 구성
        main_layout.addLayout(header_layout)
        main_layout.addWidget(add_btn)
        main_layout.addWidget(scroll, 1)
        
        central_widget.setLayout(main_layout)
        
        # 나중에 최소화할 때 사용할 위젯 저장
        self.add_btn = add_btn
        self.scroll = scroll
        self.header_layout_widget = header_layout
    
    def add_character(self):
        """캐릭터 추가 - 선택 다이얼로그"""
        # 선택 다이얼로그 생성
        dialog = QDialog(self)
        dialog.setWindowTitle("캐릭터 추가")
        dialog.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        dialog.setFixedSize(280, 175)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        
        # 메인 컨테이너
        container = QWidget(dialog)
        container.setGeometry(0, 0, 280, 175)
        container.setObjectName("addCharContainer")
        container.setStyleSheet("""
            #addCharContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X 버튼 (오른쪽 상단)
        from PyQt5.QtSvg import QSvgRenderer
        close_btn = QPushButton(container)
        close_btn.setGeometry(242, 10, 28, 28)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        # X 아이콘 SVG
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        close_btn.clicked.connect(dialog.reject)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(10)
        
        # 타이틀
        title = QLabel("캐릭터 추가")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # 신규 캐릭터 만들기 버튼
        new_btn = QPushButton("신규 캐릭터 만들기")
        new_btn.setMinimumHeight(42)
        new_btn.setCursor(Qt.PointingHandCursor)
        new_btn.setStyleSheet("""
            QPushButton {
                background: #C5E8D8;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #B5DEC8;
            }
        """)
        new_btn.clicked.connect(lambda: self._on_add_choice(dialog, 'new'))
        layout.addWidget(new_btn)
        
        # 기존 캐릭터 불러오기 버튼
        load_btn = QPushButton("기존 캐릭터 불러오기")
        load_btn.setMinimumHeight(42)
        load_btn.setCursor(Qt.PointingHandCursor)
        load_btn.setStyleSheet("""
            QPushButton {
                background: #A8D5BA;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #98C5AA;
            }
        """)
        load_btn.clicked.connect(lambda: self._on_add_choice(dialog, 'load'))
        layout.addWidget(load_btn)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        # X 버튼을 맨 위로
        close_btn.raise_()
        
        dialog.exec_()
    
    def _show_app_backup_dialog(self, parent_dialog):
        """앱 전체 백업/불러오기 선택 다이얼로그"""
        parent_dialog.accept()
        
        dialog = QDialog(self)
        dialog.setWindowTitle("앱 전체 백업")
        dialog.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        dialog.setFixedSize(280, 180)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        
        # 메인 컨테이너
        container = QWidget(dialog)
        container.setGeometry(0, 0, 280, 180)
        container.setObjectName("backupContainer")
        container.setStyleSheet("""
            #backupContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X 버튼
        close_btn = QPushButton(container)
        close_btn.setGeometry(245, 10, 24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: #F0F0F0;
                border-radius: 12px;
            }
        """)
        close_svg = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="#888888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        close_icon = QIcon(QPixmap.fromImage(QImage.fromData(close_svg.encode())))
        close_btn.setIcon(close_icon)
        close_btn.setIconSize(QSize(20, 20))
        close_btn.clicked.connect(dialog.reject)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(10)
        
        # 타이틀
        title = QLabel("앱 전체 백업/불러오기")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # 백업하기 버튼
        export_btn = QPushButton("백업하기")
        export_btn.setMinimumHeight(42)
        export_btn.setCursor(Qt.PointingHandCursor)
        export_btn.setStyleSheet("""
            QPushButton {
                background: #C5E8D8;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #B5DEC8;
            }
        """)
        export_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'export'))
        layout.addWidget(export_btn)
        
        # 불러오기 버튼
        import_btn = QPushButton("불러오기")
        import_btn.setMinimumHeight(42)
        import_btn.setCursor(Qt.PointingHandCursor)
        import_btn.setStyleSheet("""
            QPushButton {
                background: #A8D5BA;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #98C5AA;
            }
        """)
        import_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'import'))
        layout.addWidget(import_btn)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()
    
    def _on_add_choice(self, dialog, choice):
        """캐릭터 추가 선택 처리"""
        dialog.accept()
        if choice == 'new':
            self._add_new_character()
        else:
            self._load_character_from_json()
    
    def _on_backup_choice(self, dialog, choice):
        """백업 선택 처리"""
        dialog.accept()
        if choice == 'export':
            self._export_all_characters()
        else:
            self._import_all_characters()
    
    def _show_app_backup_dialog_from_batch(self, parent_dialog):
        """일괄 백업 다이얼로그에서 앱 전체 백업/불러오기 호출"""
        parent_dialog.accept()
        self._show_app_backup_dialog_standalone()
    
    def _show_app_backup_dialog_standalone(self):
        """앱 전체 백업/불러오기 선택 다이얼로그 (독립형)"""
        dialog = QDialog(self)
        dialog.setWindowTitle("앱 전체 백업")
        dialog.setWindowFlags(Qt.Dialog | Qt.FramelessWindowHint)
        dialog.setFixedSize(280, 180)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        
        # 메인 컨테이너
        container = QWidget(dialog)
        container.setGeometry(0, 0, 280, 180)
        container.setObjectName("backupContainer")
        container.setStyleSheet("""
            #backupContainer {
                background: #FFF;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        
        # X 버튼
        close_btn = QPushButton(container)
        close_btn.setGeometry(245, 10, 24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.setStyleSheet("""
            QPushButton {
                background: transparent;
                border: none;
            }
            QPushButton:hover {
                background: #F0F0F0;
                border-radius: 12px;
            }
        """)
        close_svg = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M18 6L6 18M6 6L18 18" stroke="#888888" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        close_icon = QIcon(QPixmap.fromImage(QImage.fromData(close_svg.encode())))
        close_btn.setIcon(close_icon)
        close_btn.setIconSize(QSize(20, 20))
        close_btn.clicked.connect(dialog.reject)
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 15, 20, 20)
        layout.setSpacing(10)
        
        # 타이틀
        title = QLabel("앱 전체 백업/불러오기")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 16px;
            font-weight: 700;
            color: #317C75;
            font-family: 'Pretendard', sans-serif;
            border: none;
            background: transparent;
        """)
        layout.addWidget(title)
        
        # 백업하기 버튼
        export_btn = QPushButton("백업하기")
        export_btn.setMinimumHeight(42)
        export_btn.setCursor(Qt.PointingHandCursor)
        export_btn.setStyleSheet("""
            QPushButton {
                background: #C5E8D8;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #B5DEC8;
            }
        """)
        export_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'export'))
        layout.addWidget(export_btn)
        
        # 불러오기 버튼
        import_btn = QPushButton("불러오기")
        import_btn.setMinimumHeight(42)
        import_btn.setCursor(Qt.PointingHandCursor)
        import_btn.setStyleSheet("""
            QPushButton {
                background: #A8D5BA;
                border-radius: 19px;
                color: #317C75;
                font-family: 'Pretendard', sans-serif;
                font-size: 15px;
                font-weight: 700;
                border: none;
            }
            QPushButton:hover {
                background: #98C5AA;
            }
        """)
        import_btn.clicked.connect(lambda: self._on_backup_choice(dialog, 'import'))
        layout.addWidget(import_btn)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()

    def _load_character_from_json(self):
        """캐릭터 불러오기 (폴더 또는 JSON 파일)"""
        import shutil
        import base64
        
        # 선택 방식 팝업
        msg = QMessageBox(self)
        msg.setWindowTitle("캐릭터 불러오기")
        msg.setText("백업 폴더 혹은 JSON 파일을 선택해주세요.")
        folder_btn = msg.addButton("폴더 선택", QMessageBox.ActionRole)
        file_btn = msg.addButton("JSON 파일 선택", QMessageBox.ActionRole)
        msg.addButton("취소", QMessageBox.RejectRole)
        msg.exec_()
        
        clicked = msg.clickedButton()
        
        if clicked == folder_btn:
            # 폴더 선택
            folder_path = QFileDialog.getExistingDirectory(
                self,
                "캐릭터 백업 폴더 선택"
            )
            
            if not folder_path:
                return
            
            # 폴더에서 JSON 찾기 (_로 시작하는 메타 파일 제외)
            json_files = [f for f in os.listdir(folder_path) if f.endswith('.json') and not f.startswith('_')]
            if not json_files:
                QMessageBox.warning(self, "불러오기 실패", "선택한 폴더에 JSON 파일이 없습니다.")
                return
            
            # 여러 JSON 파일이 있으면 전체 불러오기
            if len(json_files) > 1:
                self._load_multiple_characters_from_folder(folder_path, json_files)
                return
            
            # 1개만 있으면 기존 방식으로 개별 불러오기
            json_path = os.path.join(folder_path, json_files[0])
            
        elif clicked == file_btn:
            # JSON 파일 선택
            json_path, _ = QFileDialog.getOpenFileName(
                self,
                "캐릭터 JSON 파일 선택",
                "",
                "JSON 파일 (*.json);;모든 파일 (*.*)"
            )
            
            if not json_path:
                return
        else:
            return
        
        try:
            with open(json_path, 'r', encoding='utf-8') as f:
                backup_data = json.load(f)
            
            char_name = backup_data.get('char_name', '불러온 캐릭터')
            json_folder = os.path.dirname(json_path)
            
            # 이미지 찾기
            image_path = ""
            
            # 1. base64 이미지가 있는지 확인 (구 버전 백업)
            if backup_data.get('image_data'):
                temp_dir = os.path.join(self.app_dir, 'temp_images')
                os.makedirs(temp_dir, exist_ok=True)
                
                import uuid
                image_ext = backup_data.get('image_ext', '.png')
                unique_filename = f"img_{uuid.uuid4().hex[:8]}{image_ext}"
                image_path = os.path.join(temp_dir, unique_filename)
                
                image_bytes = base64.b64decode(backup_data['image_data'])
                with open(image_path, 'wb') as f:
                    f.write(image_bytes)
            
            # 2. image_file 필드로 찾기
            if not image_path:
                image_file = backup_data.get('image_file', '')
                if image_file:
                    possible_path = os.path.join(json_folder, image_file)
                    if os.path.exists(possible_path):
                        image_path = possible_path
            
            # 3. 같은 폴더에서 이미지 파일 자동 검색
            if not image_path:
                for f in os.listdir(json_folder):
                    if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                        image_path = os.path.join(json_folder, f)
                        break
            
            # 4. 이미지가 없으면 직접 선택 요청
            if not image_path:
                QMessageBox.information(self, "이미지 필요", "이미지를 선택해주세요.")
                image_path, _ = QFileDialog.getOpenFileName(
                    self,
                    "캐릭터 이미지 선택",
                    json_folder,
                    "이미지 파일 (*.png *.jpg *.jpeg *.gif *.bmp);;모든 파일 (*.*)"
                )
                if not image_path:
                    return
            
            # 캐릭터 로드 완료
            self._finish_load_character(backup_data, image_path)
            
        except json.JSONDecodeError:
            QMessageBox.critical(self, "불러오기 실패", "올바른 JSON 파일이 아닙니다.")
        except Exception as e:
            import traceback
            print(f"[불러오기 오류] {e}")
            print(traceback.format_exc())
            QMessageBox.critical(self, "불러오기 실패", f"불러오기 중 오류가 발생했습니다.\n\n{str(e)}")
    
    def _load_multiple_characters_from_folder(self, folder_path, json_files):
        """백업 폴더에서 여러 캐릭터 불러오기"""
        import shutil
        
        # 확인 팝업
        reply = QMessageBox.question(
            self,
            "캐릭터 불러오기",
            f"이 폴더에 {len(json_files)}개의 캐릭터가 있습니다.\n\n모두 불러오시겠습니까?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply != QMessageBox.Yes:
            return
        
        # temp_images 폴더 준비
        temp_dir = os.path.join(self.app_dir, 'temp_images')
        os.makedirs(temp_dir, exist_ok=True)
        
        loaded_count = 0
        global _ai_dialogues_cache
        
        for json_file in json_files:
            try:
                json_path = os.path.join(folder_path, json_file)
                with open(json_path, 'r', encoding='utf-8') as f:
                    char_backup = json.load(f)
                
                char_name = char_backup.get('char_name', '캐릭터')
                
                # 새 char_id 할당
                new_char_id = self.char_id_counter
                self.char_id_counter += 1
                
                # 이미지 파일 찾기
                image_file = char_backup.get('image_file', '')
                image_path = ""
                
                if image_file:
                    possible_path = os.path.join(folder_path, image_file)
                    if os.path.exists(possible_path):
                        image_path = possible_path
                
                # 이미지 못 찾으면 파일명 기반으로 검색
                if not image_path:
                    base_name = os.path.splitext(json_file)[0]
                    for ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.PNG', '.JPG']:
                        test_path = os.path.join(folder_path, f"{base_name}_image{ext}")
                        if os.path.exists(test_path):
                            image_path = test_path
                            break
                        # JSON과 같은 이름의 이미지도 검색
                        test_path = os.path.join(folder_path, f"{base_name}{ext}")
                        if os.path.exists(test_path):
                            image_path = test_path
                            break
                
                # 그래도 없으면 폴더 내 첫 번째 이미지 사용
                if not image_path:
                    for f in os.listdir(folder_path):
                        if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                            image_path = os.path.join(folder_path, f)
                            break
                
                # 그래도 없으면 placeholder 사용
                if not image_path or not os.path.exists(image_path):
                    from PyQt5.QtSvg import QSvgRenderer
                    from PyQt5.QtGui import QImage, QPainter
                    from PyQt5.QtCore import Qt
                    import uuid
                    
                    unique_filename = f"placeholder_{uuid.uuid4().hex[:8]}.png"
                    image_path = os.path.join(temp_dir, unique_filename)
                    
                    renderer = QSvgRenderer(PLACEHOLDER_SVG.encode('utf-8'))
                    img = QImage(100, 100, QImage.Format_ARGB32)
                    img.fill(Qt.transparent)
                    painter = QPainter(img)
                    renderer.render(painter)
                    painter.end()
                    img.save(image_path)
                
                # 이미지 복사
                import uuid
                ext = os.path.splitext(image_path)[1]
                unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                copied_path = os.path.join(temp_dir, unique_filename)
                shutil.copy2(image_path, copied_path)
                
                # 캐릭터 생성
                direction = char_backup.get('facing_direction', 'right')
                scale = char_backup.get('scale', 100)
                bubble_color = char_backup.get('bubble_color', '#A8D5BA')
                bubble_size = char_backup.get('bubble_size', 100)
                is_active = char_backup.get('is_active', True)
                catchphrase = char_backup.get('catchphrase', '')
                
                char_widget = CharacterWidget(copied_path, new_char_id, direction, scale, bubble_color, bubble_size)
                char_widget.char_name = char_name
                char_widget.personality = char_backup.get('personality', '')
                char_widget.background_story = char_backup.get('background_story', '')
                char_widget.ai_auto_generate = char_backup.get('ai_auto_generate', True)
                char_widget.nicknames = char_backup.get('nicknames', {})
                char_widget.stories = char_backup.get('stories', {})
                
                if not is_active:
                    char_widget.hide()
                    char_widget.timer.stop()
                
                self.characters.append(char_widget)
                
                # 캐릭터 데이터 저장
                self.character_data[new_char_id] = {
                    'name': char_name,
                    'scale': scale,
                    'bubble_color': bubble_color,
                    'bubble_size': bubble_size,
                    'facing_direction': direction,
                    'image_path': copied_path,
                    'is_active': is_active,
                    'catchphrase': catchphrase,
                    'personality': char_backup.get('personality', ''),
                    'background_story': char_backup.get('background_story', ''),
                    'sample_dialogues': char_backup.get('sample_dialogues', []),
                    'ai_auto_generate': char_backup.get('ai_auto_generate', True),
                    'nicknames': char_backup.get('nicknames', {}),
                    'stories': char_backup.get('stories', {})
                }
                
                # 대사 데이터 (키 형식 통일)
                dialogues_data = char_backup.get('dialogues', [])
                if isinstance(dialogues_data, dict):
                    # 키 형식 변환: int → 'char_X'
                    converted = {}
                    for key, values in dialogues_data.items():
                        if key == '기본':
                            converted['기본'] = values
                        elif isinstance(key, int):
                            converted[f'char_{key}'] = values
                        elif isinstance(key, str) and key.isdigit():
                            converted[f'char_{key}'] = values
                        else:
                            converted[key] = values
                    self.dialogues[new_char_id] = converted
                else:
                    self.dialogues[new_char_id] = {'기본': dialogues_data}
                char_widget.dialogues = self.dialogues.get(new_char_id, {'기본': []})
                
                # AI 캐시 복원
                # AI 캐시 복원 (interaction 키를 int로 변환)
                if char_backup.get('ai_cache'):
                    raw_interaction = char_backup['ai_cache'].get('interaction', {})
                    converted_interaction = {}
                    for k, v in raw_interaction.items():
                        try:
                            converted_interaction[int(k)] = v
                        except (ValueError, TypeError):
                            converted_interaction[k] = v
                    
                    _ai_dialogues_cache[new_char_id] = {
                        'solo': char_backup['ai_cache'].get('solo', []),
                        'interaction': converted_interaction,
                        'fallback': char_backup['ai_cache'].get('fallback', []),
                        'generated_at': time.time()
                    }
                
                # 수동 대사를 AI 캐시에 동기화
                sync_dialogues_to_ai_cache(new_char_id, self.dialogues[new_char_id])
                
                # 카드 생성
                card = CharacterCard(new_char_id, copied_path, char_name, is_active, catchphrase)
                card.remove_clicked.connect(self.remove_character)
                card.change_image_clicked.connect(self.change_character_image)
                card.change_scale_clicked.connect(self.change_character_scale)
                card.change_bubble_color_clicked.connect(self.change_bubble_color)
                card.change_relationships_clicked.connect(self.change_relationships)
                card.change_dialogues_clicked.connect(self.change_dialogues)
                card.change_personality_clicked.connect(self.change_personality)
                card.name_changed.connect(self.update_character_name)
                card.catchphrase_changed.connect(self.update_character_catchphrase)
                card.toggle_active.connect(self.toggle_character_active)
                card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                card.update_scale_display(scale)
                
                self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                
                loaded_count += 1
                
            except Exception as e:
                print(f"[폴더 불러오기] 캐릭터 로드 오류: {json_file} - {e}")
                import traceback
                print(traceback.format_exc())
        
        # 저장
        self.save_characters()
        
        # 관계/대사 정보 전달
        self.update_character_relationships()
        self.update_character_dialogues()
        self.update_character_personalities()
        
        QMessageBox.information(self, "불러오기 완료", f"{loaded_count}개 캐릭터를 불러왔습니다.")
    
    def _finish_load_character(self, backup_data, image_path):
        """캐릭터 불러오기 완료 처리"""
        import shutil
        
        char_name = backup_data.get('char_name', '불러온 캐릭터')
        
        # 이미지를 temp_images에 복사
        temp_dir = os.path.join(self.app_dir, 'temp_images')
        os.makedirs(temp_dir, exist_ok=True)
        
        import uuid
        ext = os.path.splitext(image_path)[1]
        unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
        copied_path = os.path.join(temp_dir, unique_filename)
        shutil.copy2(image_path, copied_path)
        image_path = copied_path
        
        # 방향
        direction = backup_data.get('facing_direction', 'right')
        
        # 빈 캐릭터 번호 찾기
        used_ids = set(self.character_data.keys())
        new_char_id = self.char_id_counter
        for i in range(self.char_id_counter):
            if i not in used_ids:
                new_char_id = i
                break
        
        # 캐릭터 설정
        scale = backup_data.get('scale', 100)
        bubble_color = backup_data.get('bubble_color', '#A8D5BA')
        bubble_size = backup_data.get('bubble_size', 100)
        catchphrase = backup_data.get('catchphrase', '')
        is_active = backup_data.get('is_active', True)
        
        char_widget = CharacterWidget(image_path, new_char_id, direction, scale, bubble_color, bubble_size)
        if not is_active:
            char_widget.hide()
        self.characters.append(char_widget)
        
        # 캐릭터 데이터 저장 (nicknames/stories는 아래에서 변환 후 설정)
        self.character_data[new_char_id] = {
            'name': char_name,
            'scale': scale,
            'bubble_color': bubble_color,
            'bubble_size': bubble_size,
            'facing_direction': direction,
            'image_path': image_path,
            'is_active': is_active,
            'catchphrase': catchphrase,
            'personality': backup_data.get('personality', ''),
            'background_story': backup_data.get('background_story', ''),
            'nicknames': {},  # 아래에서 이름->ID 변환 후 설정
            'stories': {},  # 아래에서 이름->ID 변환 후 설정
            'sample_dialogues': backup_data.get('sample_dialogues', [])
        }
        
        # 대사 데이터 (dialogues가 dict 형태인지 list 형태인지 확인, 키 형식 통일)
        dialogues_data = backup_data.get('dialogues', [])
        if isinstance(dialogues_data, dict):
            # 키 형식 변환: int → 'char_X'
            converted = {}
            for key, values in dialogues_data.items():
                if key == '기본':
                    converted['기본'] = values
                elif isinstance(key, int):
                    converted[f'char_{key}'] = values
                elif isinstance(key, str) and key.isdigit():
                    converted[f'char_{key}'] = values
                else:
                    converted[key] = values
            self.dialogues[new_char_id] = converted
        else:
            # 구 형식: [...]
            self.dialogues[new_char_id] = {'기본': dialogues_data}
        
        # 캐릭터 위젯에 데이터 전달
        char_widget.dialogues = self.dialogues.get(new_char_id, {'기본': []})
        char_widget.personality = backup_data.get('personality', '')
        char_widget.background_story = backup_data.get('background_story', '')
        char_widget.char_name = char_name
        char_widget.catchphrase = catchphrase
        char_widget.sample_dialogues = backup_data.get('sample_dialogues', [])
        
        # nicknames와 stories를 이름에서 ID로 변환
        raw_nicknames = backup_data.get('nicknames', {})
        raw_stories = backup_data.get('stories', {})
        
        # 현재 앱의 캐릭터 이름->ID 매핑
        name_to_id = {}
        for cid, cdata in self.character_data.items():
            cname = cdata.get('name', '')
            if cname:
                name_to_id[cname] = cid
        
        # 호칭 변환
        new_nicknames = {}
        for key, nickname in raw_nicknames.items():
            # 숫자(ID)인 경우 그대로 사용 (동일 앱 내 백업/복원)
            try:
                key_int = int(key)
                if key_int in self.character_data:
                    new_nicknames[key_int] = nickname
                continue
            except ValueError:
                pass
            # 이름인 경우 ID로 변환
            if key in name_to_id:
                new_nicknames[name_to_id[key]] = nickname
        
        # 서사 변환
        new_stories = {}
        for key, story in raw_stories.items():
            try:
                key_int = int(key)
                if key_int in self.character_data:
                    new_stories[key_int] = story
                continue
            except ValueError:
                pass
            if key in name_to_id:
                new_stories[name_to_id[key]] = story
        
        char_widget.nicknames = new_nicknames
        char_widget.stories = new_stories
        self.character_data[new_char_id]['nicknames'] = new_nicknames
        self.character_data[new_char_id]['stories'] = new_stories
        
        # AI 캐시 복원 (interaction 키를 int로 변환)
        if 'ai_cache' in backup_data:
            global _ai_dialogues_cache
            raw_interaction = backup_data['ai_cache'].get('interaction', {})
            converted_interaction = {}
            for k, v in raw_interaction.items():
                try:
                    converted_interaction[int(k)] = v
                except (ValueError, TypeError):
                    converted_interaction[k] = v
            
            _ai_dialogues_cache[new_char_id] = {
                'solo': backup_data['ai_cache'].get('solo', []),
                'interaction': converted_interaction,
                'fallback': backup_data['ai_cache'].get('fallback', []),
                'generated_at': time.time()
            }
        
        # 수동 대사를 AI 캐시에 동기화
        sync_dialogues_to_ai_cache(new_char_id, self.dialogues[new_char_id])
        
        # 카드 생성
        card = CharacterCard(new_char_id, image_path, char_name, is_active=is_active, catchphrase=catchphrase)
        card.remove_clicked.connect(self.remove_character)
        card.change_image_clicked.connect(self.change_character_image)
        card.change_scale_clicked.connect(self.change_character_scale)
        card.change_bubble_color_clicked.connect(self.change_bubble_color)
        card.change_relationships_clicked.connect(self.change_relationships)
        card.change_dialogues_clicked.connect(self.change_dialogues)
        card.change_personality_clicked.connect(self.change_personality)
        card.name_changed.connect(self.update_character_name)
        card.catchphrase_changed.connect(self.update_character_catchphrase)
        card.toggle_active.connect(self.toggle_character_active)
        card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
        card.update_scale_display(scale)
        
        self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
        
        if new_char_id >= self.char_id_counter:
            self.char_id_counter = new_char_id + 1
        
        self.save_characters()
        
        # 상세 완료 메시지
        has_ai = "✅" if backup_data.get('ai_cache') else "❌"
        has_personality = "✅" if backup_data.get('personality') else "❌"
        
        QMessageBox.information(self, "불러오기 완료", 
            f"'{char_name}' 캐릭터를 불러왔습니다.")
    
    def _add_new_character(self):
        """신규 캐릭터 추가"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "캐릭터 이미지 선택",
            "",
            "이미지 파일 (*.png *.jpg *.jpeg *.gif *.bmp)"
        )
        
        if file_path:
            # 방향 선택 다이얼로그
            direction_dialog = DirectionDialog(self)
            if direction_dialog.exec_() == QDialog.Accepted:
                direction = direction_dialog.get_direction()
                
                try:
                    # 이미지를 temp_images에 고유 파일명으로 복사
                    import uuid
                    import shutil
                    temp_dir = os.path.join(self.app_dir, 'temp_images')
                    os.makedirs(temp_dir, exist_ok=True)
                    
                    ext = os.path.splitext(file_path)[1]
                    unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                    copied_path = os.path.join(temp_dir, unique_filename)
                    shutil.copy2(file_path, copied_path)
                    
                    # 빈 캐릭터 번호 찾기
                    used_ids = set(self.character_data.keys())
                    new_char_id = self.char_id_counter
                    
                    # 빈 자리가 있으면 그 번호 사용
                    for i in range(self.char_id_counter):
                        if i not in used_ids:
                            new_char_id = i
                            break
                    
                    char_widget = CharacterWidget(copied_path, new_char_id, direction, 100, '#A8D5BA', 100)
                    self.characters.append(char_widget)
                    
                    # 캐릭터 데이터 저장 (복사된 경로 사용)
                    self.character_data[new_char_id] = {
                        'name': f'캐릭터 {new_char_id + 1}',
                        'scale': 100,
                        'bubble_color': '#A8D5BA',  # 민트 그린
                        'bubble_size': 100,
                        'facing_direction': direction,
                        'image_path': copied_path,
                        'is_active': True,
                        'personality': '',
                        'nicknames': {},
                        'stories': {},
                        'background_story': '',
                        'sample_dialogues': [],
                        'catchphrase': '',
                        'ai_auto_generate': True  # AI 자동생성 기본값
                    }
                    
                    # 대사 초기화 (중요!)
                    if new_char_id not in self.dialogues:
                        self.dialogues[new_char_id] = {'기본': []}
                    
                    # 캐릭터 위젯에 대사 전달
                    char_widget.dialogues = self.dialogues.get(new_char_id, {'기본': []})
                    
                    print(f"[캐릭터 추가] ID: {new_char_id}, 이름: 캐릭터 {new_char_id + 1}, 대사: {char_widget.dialogues}")
                    
                    card = CharacterCard(new_char_id, copied_path, is_active=True)
                    card.remove_clicked.connect(self.remove_character)
                    card.change_image_clicked.connect(self.change_character_image)
                    card.change_scale_clicked.connect(self.change_character_scale)
                    card.change_bubble_color_clicked.connect(self.change_bubble_color)
                    card.change_relationships_clicked.connect(self.change_relationships)
                    card.change_dialogues_clicked.connect(self.change_dialogues)
                    card.change_personality_clicked.connect(self.change_personality)
                    card.name_changed.connect(self.update_character_name)
                    card.catchphrase_changed.connect(self.update_character_catchphrase)
                    card.toggle_active.connect(self.toggle_character_active)
                    card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                    
                    self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                    
                    # char_id_counter는 최대값만 추적
                    if new_char_id >= self.char_id_counter:
                        self.char_id_counter = new_char_id + 1
                    
                    # 저장
                    print("[add_character] 저장 호출!")
                    self.save_characters()
                    
                    QMessageBox.information(self, "성공", "캐릭터가 추가되었습니다!")
                except Exception as e:
                    import traceback
                    print(f"[add_character 오류] {e}")
                    print(traceback.format_exc())
                    QMessageBox.warning(self, "오류", f"이미지를 불러올 수 없습니다:\n{str(e)}")
    
    def remove_character(self, char_id):
        """캐릭터 제거 - 확인 후 관련 파일 모두 삭제"""
        # 확인 팝업 - 커스텀 다이얼로그
        char_name = self.character_data.get(char_id, {}).get('name', f'캐릭터 {char_id + 1}')
        
        dialog = DeleteConfirmDialog(char_name, self)
        dialog.exec_()
        
        if not dialog.result:
            return
        
        # 원본 이미지 파일은 삭제하지 않음 (사용자 파일 보존)
        
        # AI 대사 캐시 삭제
        global _ai_dialogues_cache
        if char_id in _ai_dialogues_cache:
            del _ai_dialogues_cache[char_id]
            print(f"[삭제] AI 대사 캐시 삭제")
        
        # 임시 대사 캐시 삭제
        global _temp_dialogues_cache
        if char_id in _temp_dialogues_cache:
            del _temp_dialogues_cache[char_id]
            print(f"[삭제] 임시 대사 캐시 삭제")
        
        # 대사 데이터 삭제
        if char_id in self.dialogues:
            del self.dialogues[char_id]
            print(f"[삭제] 캐릭터 {char_id}의 대사 삭제")
        
        # 다른 캐릭터들의 대사에서 이 캐릭터 관련 대사도 삭제
        for other_id in list(self.dialogues.keys()):
            target_key = f'char_{char_id}'
            if target_key in self.dialogues.get(other_id, {}):
                del self.dialogues[other_id][target_key]
                print(f"[삭제] 캐릭터 {other_id}의 {target_key} 대사 삭제")
        
        # 다른 캐릭터들의 AI 캐시에서 이 캐릭터 관련 상호작용 대사도 삭제
        for other_id in list(_ai_dialogues_cache.keys()):
            if 'interaction' in _ai_dialogues_cache[other_id]:
                interaction = _ai_dialogues_cache[other_id]['interaction']
                if isinstance(interaction, dict) and char_id in interaction:
                    del interaction[char_id]
                    print(f"[삭제] 캐릭터 {other_id}의 AI 상호작용 대사에서 {char_id} 삭제")
        
        # 다른 캐릭터들의 nicknames, stories에서 이 캐릭터 관련 데이터도 삭제
        for other_id, other_data in self.character_data.items():
            if other_id == char_id:
                continue
            # nicknames에서 삭제
            if 'nicknames' in other_data and char_id in other_data['nicknames']:
                del other_data['nicknames'][char_id]
                print(f"[삭제] 캐릭터 {other_id}의 nicknames에서 {char_id} 삭제")
            # stories에서 삭제
            if 'stories' in other_data and char_id in other_data['stories']:
                del other_data['stories'][char_id]
                print(f"[삭제] 캐릭터 {other_id}의 stories에서 {char_id} 삭제")
        
        # CharacterWidget의 nicknames, stories도 정리
        for char in self.characters:
            if char.char_id != char_id:
                if hasattr(char, 'nicknames') and char_id in char.nicknames:
                    del char.nicknames[char_id]
                if hasattr(char, 'stories') and char_id in char.stories:
                    del char.stories[char_id]
        
        # 캐릭터 위젯 닫기
        for char in self.characters:
            if char.char_id == char_id:
                char.close()
                self.characters.remove(char)
                break
        
        # 캐릭터 데이터 삭제
        if char_id in self.character_data:
            del self.character_data[char_id]
        
        # 카드 위젯 삭제
        for i in range(self.scroll_layout.count()):
            item = self.scroll_layout.itemAt(i)
            if item and item.widget():
                widget = item.widget()
                if isinstance(widget, CharacterCard) and widget.char_id == char_id:
                    widget.deleteLater()
                    break
        
        # 저장
        self.save_characters()
    
    def toggle_character_active(self, char_id, is_active):
        """캐릭터 활성화/비활성화 (위치 유지)"""
        if char_id in self.character_data:
            self.character_data[char_id]['is_active'] = is_active
        
        for char in self.characters:
            if char.char_id == char_id:
                if is_active:
                    # 저장된 위치로 복원
                    saved_x = self.character_data.get(char_id, {}).get('x', None)
                    saved_y = self.character_data.get(char_id, {}).get('y', None)
                    if saved_x is not None and saved_y is not None:
                        char.move(saved_x, saved_y)
                    char.show()
                    char.timer.start(30)
                else:
                    # 현재 위치 저장
                    self.character_data[char_id]['x'] = char.x()
                    self.character_data[char_id]['y'] = char.y()
                    char.hide()
                    char.timer.stop()
                break
        
        # 저장
        self.save_characters()
    
    def show_batch_active_dialog(self):
        """다중 캐릭터 활성화/비활성화 관리 다이얼로그"""
        if not self.character_data:
            QMessageBox.information(self, "활성화 관리", "관리할 캐릭터가 없습니다.")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("캐릭터 활성화 관리")
        dialog.setFixedWidth(320)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
            }
        """)
        
        main_layout = QVBoxLayout(dialog)
        main_layout.setContentsMargins(20, 20, 20, 20)
        main_layout.setSpacing(12)
        
        # 설명 박스
        desc_box = QWidget()
        desc_box.setStyleSheet("""
            background-color: white;
            border-radius: 12px;
            border: 1px solid #9DD4BA;
        """)
        desc_layout = QVBoxLayout(desc_box)
        desc_layout.setContentsMargins(15, 12, 15, 12)
        
        desc_text = QLabel("활성화할 캐릭터를 선택하세요.\n체크 해제된 캐릭터는 화면에서 숨겨집니다.")
        desc_text.setAlignment(Qt.AlignCenter)
        desc_text.setStyleSheet("""
            font-size: 12px;
            color: #5A9C85;
            background: transparent;
            border: none;
        """)
        desc_layout.addWidget(desc_text)
        main_layout.addWidget(desc_box)
        
        # 모두 선택 / 모두 해제 버튼
        top_btn_layout = QHBoxLayout()
        
        select_all_btn = QPushButton("모두 선택")
        select_all_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #317C75;
                border: 1px solid #9DD4BA;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        top_btn_layout.addWidget(select_all_btn)
        
        deselect_all_btn = QPushButton("모두 해제")
        deselect_all_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #317C75;
                border: 1px solid #9DD4BA;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        top_btn_layout.addWidget(deselect_all_btn)
        top_btn_layout.addStretch()
        main_layout.addLayout(top_btn_layout)
        
        # 캐릭터 체크박스 목록 (스크롤 영역)
        scroll_frame = QFrame()
        scroll_frame.setMaximumHeight(300)
        scroll_frame.setStyleSheet("""
            QFrame {
                background-color: white;
                border-radius: 12px;
                border: 1px solid #9DD4BA;
            }
        """)
        scroll_frame_layout = QVBoxLayout(scroll_frame)
        scroll_frame_layout.setContentsMargins(2, 2, 2, 2)
        
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)
        scroll_area.setStyleSheet("""
            QScrollArea {
                background-color: transparent;
                border: none;
            }
            QWidget#checkboxContainer {
                background-color: white;
                border-radius: 10px;
            }
            QScrollBar:vertical {
                background: #F0F0F0;
                width: 8px;
                border-radius: 4px;
                margin: 4px 2px 4px 0px;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 4px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background: #9DD4BA;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        
        checkbox_container = QWidget()
        checkbox_container.setObjectName("checkboxContainer")
        checkbox_layout = QVBoxLayout(checkbox_container)
        checkbox_layout.setContentsMargins(13, 10, 13, 10)
        checkbox_layout.setSpacing(8)
        
        checkboxes = {}
        for char_id, data in self.character_data.items():
            char_name = data.get('name', f'캐릭터 {char_id + 1}')
            is_active = data.get('is_active', True)
            
            cb = QCheckBox(char_name)
            cb.setChecked(is_active)
            cb.setStyleSheet("""
                QCheckBox {
                    font-size: 13px;
                    color: #317C75;
                    spacing: 8px;
                    border: none;
                    background: transparent;
                }
                QCheckBox::indicator {
                    width: 16px;
                    height: 16px;
                    border-radius: 4px;
                    border: 2px solid #C5E8D8;
                }
                QCheckBox::indicator:checked {
                    background-color: #8ECFB5;
                    border: 2px solid #8ECFB5;
                }
            """)
            checkboxes[char_id] = cb
            checkbox_layout.addWidget(cb)
        
        checkbox_layout.addStretch()
        scroll_area.setWidget(checkbox_container)
        scroll_frame_layout.addWidget(scroll_area)
        main_layout.addWidget(scroll_frame)
        
        # 모두 선택 / 모두 해제 연결
        def select_all():
            for cb in checkboxes.values():
                cb.setChecked(True)
        
        def deselect_all():
            for cb in checkboxes.values():
                cb.setChecked(False)
        
        select_all_btn.clicked.connect(select_all)
        deselect_all_btn.clicked.connect(deselect_all)
        
        # 적용 버튼
        apply_btn = QPushButton("적용")
        apply_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 10px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #7EC9A9;
            }
        """)
        
        def apply_changes():
            for char_id, cb in checkboxes.items():
                new_active = cb.isChecked()
                old_active = self.character_data.get(char_id, {}).get('is_active', True)
                
                if new_active != old_active:
                    # 토글 상태 변경
                    self.toggle_character_active(char_id, new_active)
                    
                    # 카드 UI 업데이트
                    for i in range(self.scroll_layout.count()):
                        widget = self.scroll_layout.itemAt(i).widget()
                        if isinstance(widget, CharacterCard) and widget.char_id == char_id:
                            widget.set_active(new_active)
                            break
            
            dialog.accept()
        
        apply_btn.clicked.connect(apply_changes)
        main_layout.addWidget(apply_btn)
        
        dialog.exec_()
    
    def update_character_name(self, char_id, name):
        """캐릭터 이름 업데이트"""
        if char_id in self.character_data:
            self.character_data[char_id]['name'] = name
            # 저장
            self.save_characters()
    
    def update_character_catchphrase(self, char_id, catchphrase):
        """캐릭터 캐치프레이즈 업데이트"""
        if char_id in self.character_data:
            self.character_data[char_id]['catchphrase'] = catchphrase
            # 저장
            self.save_characters()
    
    def change_character_scale(self, char_id):
        """캐릭터 크기 변경"""
        current_scale = self.character_data.get(char_id, {}).get('scale', 100)
        
        # 미리보기를 위해 캐릭터 객체 찾기
        target_char = None
        for char in self.characters:
            if char.char_id == char_id:
                target_char = char
                break
        
        scale_dialog = ScaleDialog(current_scale, self, character=target_char)
        if scale_dialog.exec_() == QDialog.Accepted:
            new_scale = scale_dialog.get_scale()
            print(f"[크기] char_id={char_id}, 새 크기={new_scale}%")
            
            # 이미 미리보기로 적용되어 있으므로 데이터만 저장
            self.character_data[char_id]['scale'] = new_scale
            
            # 카드의 버튼 텍스트도 업데이트
            card_found = False
            for i in range(self.scroll_layout.count()):
                item = self.scroll_layout.itemAt(i)
                if item:
                    widget = item.widget()
                    if widget and isinstance(widget, CharacterCard):
                        print(f"[크기] 카드 발견: char_id={widget.char_id}")
                        if widget.char_id == char_id:
                            widget.update_scale_display(new_scale)
                            print(f"[크기] 카드 UI 업데이트 완료: {new_scale}%")
                            card_found = True
                            break
            
            if not card_found:
                print(f"[크기] 경고: char_id={char_id}에 해당하는 카드를 찾지 못함")
            
            # 저장
            self.save_characters()
    
    def change_bubble_color(self, char_id):
        """말풍선 색상 및 크기 변경 (실시간 미리보기)"""
        current_color = self.character_data.get(char_id, {}).get('bubble_color', '#81C784')
        current_size = self.character_data.get(char_id, {}).get('bubble_size', 100)
        
        # 캐릭터 찾기
        target_char = None
        for char in self.characters:
            if char.char_id == char_id:
                target_char = char
                break
        
        # 캐릭터를 멈추고 말풍선 표시
        if target_char:
            target_char.timer.stop()  # 움직임 멈춤
            target_char.is_previewing_bubble = True
            target_char.show_dialogue("미리보기", duration=999999)  # 긴 시간 유지
        
        color_dialog = BubbleColorDialog(current_color, current_size, self)
        
        # 실시간 미리보기 콜백
        def on_preview_changed(color, size):
            if target_char:
                target_char.bubble_color = QColor(color)
                target_char.bubble_size = size
                target_char.update()  # 화면 갱신
        
        color_dialog.preview_changed.connect(on_preview_changed)
        
        if color_dialog.exec_() == QDialog.Accepted:
            new_color = color_dialog.get_color()
            new_size = color_dialog.get_size()
            
            if target_char:
                target_char.bubble_color = QColor(new_color)
                target_char.bubble_size = new_size
                self.character_data[char_id]['bubble_color'] = new_color
                self.character_data[char_id]['bubble_size'] = new_size
            
            # 저장
            self.save_characters()
        else:
            # 취소 시 원래 값 복원
            if target_char:
                target_char.bubble_color = QColor(current_color)
                target_char.bubble_size = current_size
        
        # 말풍선 숨기고 캐릭터 다시 움직이기
        if target_char:
            target_char.is_previewing_bubble = False
            target_char.hide_dialogue()
            target_char.timer.start(30)
    
    def change_relationships(self, char_id):
        """관계 설정"""
        # 모든 캐릭터 이름 수집
        all_characters = {}
        for cid, data in self.character_data.items():
            all_characters[cid] = data.get('name', f'캐릭터 {cid + 1}')
        
        if len(all_characters) < 2:
            QMessageBox.information(self, "알림", "관계를 설정하려면 캐릭터가 2개 이상 필요합니다!")
            return
        
        # 현재 캐릭터 이름
        char_name = self.character_data.get(char_id, {}).get('name', f'캐릭터 {char_id + 1}')
        
        print(f"[관계 설정] 캐릭터 {char_id} ({char_name}) 관계 다이얼로그 열기")
        print(f"[관계 설정] 현재 self.relationships: {self.relationships}")
        
        try:
            dialog = RelationshipDialog(char_id, char_name, all_characters, self.relationships, self)
            if dialog.exec_() == QDialog.Accepted:
                new_feelings = dialog.get_relationships()  # {other_id: "감정"}
                
                print(f"[관계 설정] 새 감정: {new_feelings}")
                
                # 감정 업데이트 (새 형식: {(min_id, max_id): {char1_id: "감정1", char2_id: "감정2"}})
                for other_id, my_feeling in new_feelings.items():
                    # None 체크
                    if my_feeling is None:
                        my_feeling = "무관심"
                    
                    key = tuple(sorted([char_id, other_id]))
                    
                    print(f"[관계 설정] 키: {key}, 캐릭터 {char_id} -> {other_id}: {my_feeling}")
                    
                    # 기존 데이터가 있으면 유지하면서 업데이트
                    if key in self.relationships and isinstance(self.relationships[key], dict):
                        self.relationships[key][char_id] = my_feeling
                        print(f"[관계 설정] 기존 데이터 업데이트: {self.relationships[key]}")
                    else:
                        # 새로 생성 (상대방 감정은 기본값 "무관심")
                        self.relationships[key] = {
                            char_id: my_feeling,
                            other_id: "무관심"
                        }
                        print(f"[관계 설정] 새로 생성: {self.relationships[key]}")
                
                print(f"[관계 설정] 업데이트 후 self.relationships: {self.relationships}")
                
                # 캐릭터 위젯에 감정 정보 전달
                self.update_character_relationships()
                
                # 저장
                self.save_characters()
                print(f"[관계 설정] 저장 완료")
        except Exception as e:
            import traceback
            print(f"[관계 설정 오류] {e}")
            print(traceback.format_exc())
            QMessageBox.warning(self, "오류", f"감정 설정 중 오류 발생:\n{str(e)}")
    
    def change_dialogues(self, char_id):
        """대사 설정"""
        # 모든 캐릭터 이름 수집
        all_characters = {}
        for cid, data in self.character_data.items():
            all_characters[cid] = data.get('name', f'캐릭터 {cid + 1}')
        
        # 현재 캐릭터 이름
        char_name = self.character_data.get(char_id, {}).get('name', f'캐릭터 {char_id + 1}')
        
        try:
            dialog = DialogueDialog(char_id, char_name, all_characters, self.dialogues, self)
            if dialog.exec_() == QDialog.Accepted:
                new_dialogues = dialog.get_dialogues()
                self.dialogues[char_id] = new_dialogues
                
                print(f"[대사 변경] 캐릭터 {char_id}의 대사: {new_dialogues}")
                
                # 수동 대사를 AI 캐시에 동기화
                sync_dialogues_to_ai_cache(char_id, new_dialogues)
                
                # 캐릭터 위젯에 대사 정보 전달
                self.update_character_dialogues()
                
                # 캐릭터 위젯의 대사 확인
                for char in self.characters:
                    if char.char_id == char_id:
                        print(f"[위젯 대사] 캐릭터 {char_id}: {char.dialogues}")
                
                # 저장
                self.save_characters()
        except Exception as e:
            import traceback
            print(f"[대사 설정 오류] {e}")
            print(traceback.format_exc())
            QMessageBox.warning(self, "오류", f"대사 설정 중 오류 발생:\n{str(e)}")
    
    def change_personality(self, char_id):
        """성격 설정 (대사 + AI 성격 통합)"""
        # 모든 캐릭터 이름 수집
        all_characters = {}
        for cid, data in self.character_data.items():
            all_characters[cid] = data.get('name', f'캐릭터 {cid + 1}')
        
        # 현재 캐릭터 이름
        char_name = self.character_data.get(char_id, {}).get('name', f'캐릭터 {char_id + 1}')
        
        # 현재 성격, 호칭, 대사 가져오기
        current_personality = ""
        current_nicknames = {}
        for char in self.characters:
            if char.char_id == char_id:
                current_personality = char.personality
                current_nicknames = char.nicknames
                break
        
        # 현재 대사
        current_dialogues = self.dialogues.get(char_id, {}).get('기본', ['', '', ''])
        
        # 현재 서사
        current_stories = self.character_data.get(char_id, {}).get('stories', {})
        
        # 현재 배경 스토리
        current_background_story = self.character_data.get(char_id, {}).get('background_story', '')
        
        try:
            dialog = PersonalityDialog(char_id, char_name, all_characters, 
                                       current_personality, current_nicknames, 
                                       current_dialogues, current_stories, 
                                       current_background_story, self)
            if dialog.exec_() == QDialog.Accepted:
                new_personality = dialog.get_personality()
                new_background_story = dialog.get_background_story()
                new_nicknames = dialog.get_nicknames()
                new_dialogues = dialog.get_dialogues()
                new_stories = dialog.get_stories()
                
                # 성격이 새로 추가되었는지 확인
                personality_added = new_personality and not current_personality
                
                # 캐릭터 위젯에 성격 정보 업데이트
                for char in self.characters:
                    if char.char_id == char_id:
                        char.personality = new_personality
                        char.background_story = new_background_story
                        char.nicknames = new_nicknames
                        char.char_name = char_name
                        char.dialogues = {'기본': new_dialogues}
                        char.stories = new_stories
                        break
                
                # character_data에도 저장
                if char_id not in self.character_data:
                    self.character_data[char_id] = {}
                self.character_data[char_id]['personality'] = new_personality
                self.character_data[char_id]['background_story'] = new_background_story
                self.character_data[char_id]['nicknames'] = new_nicknames
                self.character_data[char_id]['stories'] = new_stories
                
                # 대사 저장
                if char_id not in self.dialogues:
                    self.dialogues[char_id] = {}
                self.dialogues[char_id]['기본'] = new_dialogues
                
                # 수동 대사를 AI 캐시에 동기화
                sync_dialogues_to_ai_cache(char_id, self.dialogues[char_id])
                
                print(f"[성격] 캐릭터 {char_id}: 성격={new_personality}, 호칭={new_nicknames}, 대사={new_dialogues}, 서사={new_stories}")
                
                # 저장
                self.save_characters()
                
                # 성격이 새로 추가되면 해당 캐릭터만 바로 대사 생성
                if personality_added and self.ai_enabled and self.gemini_api_key:
                    print(f"[AI] 새 성격 추가됨 - {char_name} 대사 바로 생성")
                    self.generate_single_character_cache(char_id)
                    
        except Exception as e:
            import traceback
            print(f"[성격 설정 오류] {e}")
            print(traceback.format_exc())
            QMessageBox.warning(self, "오류", f"성격 설정 중 오류 발생:\n{str(e)}")
    
    def update_character_relationships(self):
        """모든 캐릭터에 감정 정보 업데이트 (새 시스템)"""
        print(f"[관계 업데이트] 시작 - self.relationships: {self.relationships}")
        
        for char in self.characters:
            char.relationships = {}
            
            # 새 형식: relationships = {(min_id, max_id): {char1_id: "감정1", char2_id: "감정2"}}
            for key, rel_data in self.relationships.items():
                try:
                    # key가 튜플이고 char_id가 포함되어 있는지 확인
                    if not isinstance(key, tuple) or len(key) != 2:
                        print(f"[관계 업데이트] 잘못된 키 형식 무시: {key}")
                        continue
                    
                    if char.char_id not in key:
                        continue
                    
                    other_id = key[0] if key[1] == char.char_id else key[1]
                    
                    # other_id가 정수인지 확인
                    if not isinstance(other_id, int):
                        print(f"[관계 업데이트] other_id가 정수가 아님: {other_id} (type: {type(other_id)})")
                        continue
                    
                    if isinstance(rel_data, dict):
                        # 새 형식 - 각 캐릭터의 감정 가져오기
                        my_feeling = rel_data.get(char.char_id, "무관심")
                        # my_feeling이 문자열인지 확인
                        if isinstance(my_feeling, str):
                            char.relationships[other_id] = my_feeling
                            print(f"[관계 업데이트] 캐릭터 {char.char_id} -> {other_id}: {my_feeling}")
                    else:
                        # 구 형식 호환 - 기본값으로 변환
                        char.relationships[other_id] = self._convert_old_to_feeling(rel_data)
                except Exception as e:
                    print(f"[관계 업데이트 오류] key={key}, rel_data={rel_data}, error={e}")
            
            print(f"[관계 업데이트] 캐릭터 {char.char_id} 최종 relationships: {char.relationships}")
    
    def _convert_old_to_feeling(self, old_rel):
        """구 형식 관계를 새 감정으로 변환"""
        # 비대칭 관계 처리
        if ":" in str(old_rel):
            base_rel, _ = old_rel.rsplit(":", 1)
            old_rel = base_rel
        
        # 관계 타입을 감정으로 매핑
        rel_to_feeling = {
            "친구": "우정", "파트너": "신뢰", "연인": "사랑",
            "라이벌": "질투", "적": "증오", "낯선 사이": "무관심"
        }
        
        if "/" in str(old_rel):
            # 비대칭 관계 - 첫 번째 감정 사용
            parts = old_rel.split("/")
            mapping = {
                "애정": "사랑", "증오": "증오", "무관심": "무관심",
                "장난": "장난", "짜증": "짜증", "존경": "동경",
                "질투": "질투", "집착": "사랑", "두려움": "어색",
                "친근": "우정", "경계": "어색", "신뢰": "신뢰", "의심": "어색"
            }
            return mapping.get(parts[0], "무관심")
        
        return rel_to_feeling.get(old_rel, "무관심")
    
    def update_character_dialogues(self):
        """모든 캐릭터에 대사 정보 업데이트"""
        for char in self.characters:
            char.dialogues = self.dialogues.get(char.char_id, {'기본': []})
    
    def update_character_personalities(self):
        """모든 캐릭터에 성격 및 호칭, 서사 정보 업데이트"""
        for char in self.characters:
            char_data = self.character_data.get(char.char_id, {})
            char.personality = char_data.get('personality', '')
            char.background_story = char_data.get('background_story', '')
            char.sample_dialogues = char_data.get('sample_dialogues', [])
            char.nicknames = char_data.get('nicknames', {})
            char.stories = char_data.get('stories', {})
            char.char_name = char_data.get('name', f'캐릭터 {char.char_id + 1}')
            char.ai_auto_generate = char_data.get('ai_auto_generate', True)
    
    def change_character_image(self, char_id):
        """캐릭터 이미지 변경"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "새 이미지 선택",
            "",
            "이미지 파일 (*.png *.jpg *.jpeg *.gif *.bmp)"
        )
        
        if file_path:
            # 방향 선택 다이얼로그
            direction_dialog = DirectionDialog(self)
            if direction_dialog.exec_() == QDialog.Accepted:
                direction = direction_dialog.get_direction()
                
                # 이미지를 temp_images에 고유 파일명으로 복사
                import uuid
                import shutil
                temp_dir = os.path.join(self.app_dir, 'temp_images')
                os.makedirs(temp_dir, exist_ok=True)
                
                ext = os.path.splitext(file_path)[1]
                unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                copied_path = os.path.join(temp_dir, unique_filename)
                shutil.copy2(file_path, copied_path)
                
                for char in self.characters:
                    if char.char_id == char_id:
                        # 기존 데이터 저장
                        pos = char.pos()
                        velocity_x = char.velocity_x
                        current_scale = self.character_data.get(char_id, {}).get('scale', 100)
                        current_name = self.character_data.get(char_id, {}).get('name', f'캐릭터 {char_id + 1}')
                        current_color = self.character_data.get(char_id, {}).get('bubble_color', '#81C784')
                        
                        # 대사 관련 데이터 저장
                        saved_personality = char.personality
                        saved_dialogues = char.dialogues.copy() if char.dialogues else {}
                        saved_sample_dialogues = char.sample_dialogues.copy() if hasattr(char, 'sample_dialogues') and char.sample_dialogues else []
                        saved_background_story = char.background_story
                        saved_char_name = char.char_name
                        saved_nicknames = char.nicknames.copy() if hasattr(char, 'nicknames') and char.nicknames else {}
                        saved_stories = char.stories.copy() if hasattr(char, 'stories') and char.stories else {}
                        saved_relationships = char.relationships.copy() if hasattr(char, 'relationships') and char.relationships else {}
                        saved_bubble_size = char.bubble_size if hasattr(char, 'bubble_size') else 100
                        
                        char.close()
                        self.characters.remove(char)
                        
                        new_char = CharacterWidget(copied_path, char_id, direction, current_scale, current_color, saved_bubble_size)
                        new_char.move(pos)
                        new_char.velocity_x = velocity_x
                        
                        # 대사 관련 데이터 복원
                        new_char.personality = saved_personality
                        new_char.dialogues = saved_dialogues
                        new_char.sample_dialogues = saved_sample_dialogues
                        new_char.background_story = saved_background_story
                        new_char.char_name = saved_char_name
                        new_char.nicknames = saved_nicknames
                        new_char.stories = saved_stories
                        new_char.relationships = saved_relationships
                        
                        self.characters.append(new_char)
                        
                        # 데이터 업데이트 (복사된 경로 사용)
                        self.character_data[char_id]['facing_direction'] = direction
                        self.character_data[char_id]['image_path'] = copied_path
                        
                        for i in range(self.scroll_layout.count()):
                            item = self.scroll_layout.itemAt(i)
                            if item and item.widget():
                                widget = item.widget()
                                if isinstance(widget, CharacterCard) and widget.char_id == char_id:
                                    is_active = self.character_data[char_id].get('is_active', True)
                                    catchphrase = self.character_data[char_id].get('catchphrase', '')
                                    new_card = CharacterCard(char_id, copied_path, current_name, is_active, catchphrase)
                                    new_card.remove_clicked.connect(self.remove_character)
                                    new_card.change_image_clicked.connect(self.change_character_image)
                                    new_card.change_scale_clicked.connect(self.change_character_scale)
                                    new_card.change_bubble_color_clicked.connect(self.change_bubble_color)
                                    new_card.change_relationships_clicked.connect(self.change_relationships)
                                    new_card.change_dialogues_clicked.connect(self.change_dialogues)
                                    new_card.change_personality_clicked.connect(self.change_personality)
                                    new_card.name_changed.connect(self.update_character_name)
                                    new_card.catchphrase_changed.connect(self.update_character_catchphrase)
                                    new_card.toggle_active.connect(self.toggle_character_active)
                                    new_card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                                    # 크기 표시 업데이트
                                    scale = self.character_data[char_id].get('scale', 100)
                                    new_card.update_scale_display(scale)
                                    self.scroll_layout.replaceWidget(widget, new_card)
                                    widget.deleteLater()
                                    break
                        break
                
                # 저장
                self.save_characters()
    
    def generate_ai_cache(self):
        """모든 캐릭터의 대사 캐시 생성 (순차적으로)"""
        global _ai_dialogues_cache
        
        if not self.gemini_api_key or not self.ai_enabled:
            return
        
        print("[AI] 대사 캐시 생성 시작...")
        
        # 성격이 설정된 캐릭터 목록 수집
        chars_to_generate = []
        
        try:
            for char in self.characters:
                char_data = self.character_data.get(char.char_id, {})
                personality = char_data.get('personality', '')
                
                # ai_auto_generate가 False면 스킵
                ai_auto = char_data.get('ai_auto_generate', True)
                if not ai_auto:
                    print(f"[AI] {char_data.get('name', '?')} - 자동생성 비활성화, 스킵")
                    continue
                
                if personality:  # 성격이 설정된 캐릭터만
                    # 이미 캐시가 있으면 스킵
                    existing_cache = _ai_dialogues_cache.get(char.char_id, {})
                    if existing_cache.get('solo'):
                        print(f"[AI] {char_data.get('name', '?')} - 기존 캐시 사용")
                        continue
                    
                    # 다른 캐릭터 정보 수집
                    other_chars_info = []
                    for other in self.characters:
                        if other.char_id != char.char_id:
                            other_name = self.character_data.get(other.char_id, {}).get('name', f'캐릭터 {other.char_id + 1}')
                            nicknames_str = char_data.get('nicknames', {}).get(other.char_id, other_name)
                            # 서사 정보
                            story = char_data.get('stories', {}).get(other.char_id, '')
                            # 관계 정보 - 딕셔너리 형태에서 현재 캐릭터의 감정 추출
                            rel_key = (min(char.char_id, other.char_id), max(char.char_id, other.char_id))
                            rel_data = self.relationships.get(rel_key, {})
                            if isinstance(rel_data, dict):
                                relationship = rel_data.get(char.char_id, "친구")
                            else:
                                relationship = rel_data if rel_data else "친구"
                            other_chars_info.append((other_name, nicknames_str, relationship, story))
                    
                    print(f"[AI] {char_data.get('name', '?')} - 상호작용 대상: {[info[0] for info in other_chars_info]}")
                    
                    # 중복 이름 처리
                    other_chars_info = make_unique_names(other_chars_info)
                    
                    print(f"[AI] {char_data.get('name', '?')} - 중복처리 후: {[info[0] for info in other_chars_info]}")
                    
                    # 샘플 대사
                    sample_dialogues = self.dialogues.get(char.char_id, {}).get('기본', [])
                    
                    # 배경 스토리
                    background_story = char_data.get('background_story', '')
                    
                    # 현재 대사 수 계산 (정렬용)
                    cache = _ai_dialogues_cache.get(char.char_id, {})
                    current_count = len(cache.get('solo', [])) + sum(len(v) for v in cache.get('interaction', {}).values())
                    
                    chars_to_generate.append({
                        'char_id': char.char_id,
                        'name': char_data.get('name', f'캐릭터 {char.char_id + 1}'),
                        'personality': personality,
                        'sample_dialogues': sample_dialogues,
                        'other_chars_info': other_chars_info,
                        'background_story': background_story,
                        'current_dialogue_count': current_count  # 정렬용
                    })
            
            # 대사가 적은 캐릭터 우선 정렬
            chars_to_generate.sort(key=lambda x: x['current_dialogue_count'])
            
            # 순차적으로 캐시 생성 (5초 간격)
            if chars_to_generate:
                print(f"[AI] {len(chars_to_generate)}개 캐릭터 캐시 생성 필요 (대사 적은 순)")
                for i, c in enumerate(chars_to_generate):
                    print(f"  {i+1}. {c['name']} (현재 {c['current_dialogue_count']}개)")
                self._ai_cache_queue = chars_to_generate
                self._ai_cache_index = 0
                self._process_next_ai_cache()
            else:
                print("[AI] 모든 캐릭터 캐시 이미 존재")
                
        except Exception as e:
            print(f"[AI] 캐시 생성 중 오류: {e}")
    
    def _process_next_ai_cache(self):
        """AI 캐시 큐에서 다음 캐릭터 처리"""
        if not hasattr(self, '_ai_cache_queue') or self._ai_cache_index >= len(self._ai_cache_queue):
            print("[AI] 모든 캐릭터 캐시 생성 요청 완료")
            self._current_ai_mode = None
            # 모든 캐릭터의 생성 상태 지우기
            for char in self.characters:
                char.generating_status = ""
                char.update()
            return
        
        char_info = self._ai_cache_queue[self._ai_cache_index]
        char_id = char_info['char_id']
        print(f"[AI] {char_info['name']} 대사 생성 중... ({self._ai_cache_index + 1}/{len(self._ai_cache_queue)})")
        
        # 현재 모드 설정 및 다음 인덱스 미리 저장
        self._current_ai_mode = 'cache'
        self._ai_cache_index += 1
        has_more = self._ai_cache_index < len(self._ai_cache_queue)
        self._cache_has_more = has_more  # 인스턴스 변수로 저장
        
        # 해당 캐릭터에 생성 중 표시
        for char in self.characters:
            if char.char_id == char_id:
                char.generating_status = "대사 생성 중..."
                char.update()
                break
        
        # 큐를 사용하여 메인 스레드에서 처리
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error,  # 에러 플래그
                '_has_more_cache': has_more  # 다음 처리 여부 전달
            })

        # 기존 대사 가져오기 (중복 방지용)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_info['name'],
            char_info['personality'],
            char_info['sample_dialogues'],
            char_info['other_chars_info'],
            on_complete,
            char_info.get('background_story', ''),
            0,
            existing
        )
    
    def generate_dialogues_now(self, btn=None):
        """즉시 대사 생성 (버튼 클릭 시) - 캐릭터 선택 팝업"""
        if not self.gemini_api_key:
            QMessageBox.warning(None, "API 키 필요", "먼저 Gemini API 키를 입력해주세요.")
            return
        
        # 이미 생성 중인지 확인
        if getattr(self, '_is_generating_now', False):
            QMessageBox.information(None, "생성 중", "이미 대사를 생성하고 있습니다.\n잠시만 기다려주세요.")
            return
        
        # 성격이 설정된 캐릭터가 있는지 확인
        chars_with_personality = [c for c in self.characters if c.personality]
        if not chars_with_personality:
            QMessageBox.warning(None, "캐릭터 없음", "성격이 설정된 캐릭터가 없습니다.\n캐릭터 성격을 먼저 설정해주세요.")
            return
        
        # 캐릭터 선택 다이얼로그 표시
        dialog = QDialog(self)
        dialog.setWindowTitle("즉시 대사 생성")
        dialog.setMinimumSize(350, 450)  # 최소 크기 (내용에 따라 늘어남)
        dialog.setMaximumHeight(600)  # 최대 높이 제한
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                color: #5A9C85;
            }
            QCheckBox {
                color: #5A9C85;
                font-size: 15px;
                spacing: 10px;
                padding: 8px;
            }
            QCheckBox::indicator {
                width: 20px;
                height: 20px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # 타이틀
        title = QLabel("대사를 생성할 캐릭터 선택")
        title.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 18px; font-weight: 700; color: #5A9C85;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # 스크롤 영역
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setMinimumHeight(280)  # 스크롤 영역 최소 높이 증가
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                background-color: white;
            }
            QScrollBar:vertical {
                background: #F0F0F0;
                width: 12px;
                border-radius: 6px;
                margin: 6px 2px;
            }
            QScrollBar::handle:vertical {
                background: #C5E8D8;
                border-radius: 5px;
                min-height: 30px;
            }
            QScrollBar::handle:vertical:hover {
                background: #8ECFB5;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)
        scroll.viewport().setStyleSheet("background-color: white; border-radius: 10px;")
        
        scroll_content = QWidget()
        scroll_content.setStyleSheet("background-color: white; border-radius: 10px;")
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setSpacing(5)
        scroll_layout.setContentsMargins(15, 15, 15, 15)
        scroll_layout.setAlignment(Qt.AlignTop)  # 위쪽 정렬
        
        # 캐릭터별 체크박스
        checkboxes = {}
        for char in chars_with_personality:
            char_name = self.character_data.get(char.char_id, {}).get('name', f'캐릭터 {char.char_id + 1}')
            cb = QCheckBox(char_name)
            cb.setChecked(True)  # 기본적으로 선택됨
            cb.setMinimumHeight(35)  # 체크박스 최소 높이
            checkboxes[char.char_id] = cb
            scroll_layout.addWidget(cb)
        
        scroll.setWidget(scroll_content)
        layout.addWidget(scroll, 1)  # stretch factor 1로 스크롤 영역이 공간 차지
        
        # 전체 선택/해제 버튼
        select_layout = QHBoxLayout()
        select_all_btn = QPushButton("전체 선택")
        select_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border-radius: 12px;
                padding: 8px 15px;
                font-weight: 700;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        select_all_btn.clicked.connect(lambda: [cb.setChecked(True) for cb in checkboxes.values()])
        
        deselect_all_btn = QPushButton("전체 해제")
        deselect_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #B0BEC5;
                color: white;
                border-radius: 12px;
                padding: 8px 15px;
                font-weight: 700;
            }
            QPushButton:hover { background-color: #90A4AE; }
        """)
        deselect_all_btn.clicked.connect(lambda: [cb.setChecked(False) for cb in checkboxes.values()])
        
        select_layout.addWidget(select_all_btn)
        select_layout.addWidget(deselect_all_btn)
        layout.addLayout(select_layout)
        
        # 생성 버튼
        generate_btn = QPushButton("대사 생성")
        generate_btn.setMinimumHeight(45)
        generate_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border-radius: 12px;
                font-size: 17px;
                font-weight: 700;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        
        def start_generation():
            # 선택된 캐릭터 ID 수집
            selected_ids = [cid for cid, cb in checkboxes.items() if cb.isChecked()]
            if not selected_ids:
                QMessageBox.warning(dialog, "선택 필요", "최소 한 명의 캐릭터를 선택해주세요.")
                return
            dialog.accept()
            self._generate_for_selected_characters(selected_ids, btn)
        
        generate_btn.clicked.connect(start_generation)
        layout.addWidget(generate_btn)
        
        dialog.exec_()
    
    def _generate_for_selected_characters(self, selected_ids, btn=None):
        """선택된 캐릭터들에 대해 즉시 대사 생성"""
        # 생성 중 상태 설정
        self._is_generating_now = True
        
        # 버튼 비활성화
        if btn:
            btn.setEnabled(False)
            btn.setText(f"생성 중... 0/{len(selected_ids)}")
        
        print(f"[AI] 즉시 대사 생성 시작 - 선택된 {len(selected_ids)}개 캐릭터")
        
        # 선택된 캐릭터만 대사 추가
        self._generate_now_queue = []
        
        for char in self.characters:
            if char.char_id not in selected_ids:
                continue
            if not char.personality:
                continue
            
            char_data = self.character_data.get(char.char_id, {})
            
            # 다른 캐릭터 정보 수집
            other_chars_info = []
            for other in self.characters:
                if other.char_id != char.char_id:
                    other_name = self.character_data.get(other.char_id, {}).get('name', f'캐릭터 {other.char_id + 1}')
                    nicknames = char.nicknames.get(other.char_id, other_name)
                    rel_key = tuple(sorted([char.char_id, other.char_id]))
                    # 관계 정보 - 딕셔너리 형태에서 현재 캐릭터의 감정 추출
                    rel_data = self.relationships.get(rel_key, {})
                    if isinstance(rel_data, dict):
                        relationship = rel_data.get(char.char_id, "친구")
                    else:
                        relationship = rel_data if rel_data else "친구"
                    story = char.stories.get(other.char_id, "") if hasattr(char, 'stories') else ""
                    other_chars_info.append((other_name, nicknames, relationship, story))
            
            # 중복 이름 처리
            other_chars_info = make_unique_names(other_chars_info)
            
            sample_dialogues = char.dialogues.get('기본', [])
            sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '(선택)']
            
            background_story = char_data.get('background_story', '') or getattr(char, 'background_story', '')
            
            self._generate_now_queue.append({
                'char_id': char.char_id,
                'name': char.char_name,
                'personality': char.personality,
                'sample_dialogues': sample_dialogues,
                'other_chars_info': other_chars_info,
                'background_story': background_story
            })
        
        if self._generate_now_queue:
            self._generate_now_index = 0
            self._generate_now_btn = btn
            self._process_next_generate_now()
        else:
            self._is_generating_now = False
            if btn:
                btn.setEnabled(True)
                btn.setText("즉시 대사 생성")
    
    def _process_next_generate_now(self):
        """즉시 대사 생성 큐 처리"""
        try:
            if self._generate_now_index >= len(self._generate_now_queue):
                print("[AI] 즉시 대사 생성 완료")
                self._is_generating_now = False
                self._current_ai_mode = None
                if self._generate_now_btn:
                    self._generate_now_btn.setEnabled(True)
                    self._generate_now_btn.setText("즉시 대사 생성")
                return
            
            char_info = self._generate_now_queue[self._generate_now_index]
            char_id = char_info.get('char_id')
            total = len(self._generate_now_queue)
            current = self._generate_now_index + 1
            print(f"[AI] {char_info.get('name', '캐릭터')} 대사 생성 중... ({current}/{total})")
            
            # 현재 모드 설정
            self._current_ai_mode = 'generate_now'
            
            # 버튼 텍스트 업데이트
            if self._generate_now_btn:
                self._generate_now_btn.setText(f"생성 중... {current}/{total}")
            
            # 생성 중 표시
            for char in self.characters:
                if char.char_id == char_id:
                    char.generating_status = "대사 생성 중..."
                    char.update()
                    break
            
            # 큐를 사용하여 메인 스레드에서 처리
            def on_complete(solo, interaction, fallback, is_error=False):
                try:
                    self._ai_complete_queue.append({
                        'char_id': char_id,
                        'solo': solo if solo else [],
                        'interaction': interaction if interaction else {},
                        'fallback': fallback if fallback else [],
                        'is_error': is_error  # 에러 플래그
                    })
                except Exception as e:
                    print(f"[AI] 콜백 처리 오류: {e}")
            
            # 기존 대사 가져오기 (중복 방지용)
            existing = _ai_dialogues_cache.get(char_id, None)

            generate_dialogues_batch(
                char_info.get('name', ''),
                char_info.get('personality', ''),
                char_info.get('sample_dialogues', []),
                char_info.get('other_chars_info', []),
                on_complete,
                char_info.get('background_story', ''),
                0,
                existing
            )
        except Exception as e:
            print(f"[AI] 대사 생성 처리 중 오류: {type(e).__name__}: {e}")
            self._is_generating_now = False
            self._current_ai_mode = None
            if hasattr(self, '_generate_now_btn') and self._generate_now_btn:
                try:
                    self._generate_now_btn.setEnabled(True)
                    self._generate_now_btn.setText("즉시 대사 생성")
                except:
                    pass
    
    def _process_ai_complete_queue(self):
        """AI 완료 큐 처리 (메인 스레드에서 실행)"""
        if not self._ai_complete_queue:
            return
        
        try:
            # 큐에서 하나 꺼내기
            item = self._ai_complete_queue.pop(0)
            char_id = item.get('char_id')
            solo = item.get('solo', []) or []
            interaction = item.get('interaction', {}) or {}
            fallback = item.get('fallback', []) or []
            is_error = item.get('is_error', False)  # 에러 플래그 확인
            
            # 캐릭터 이름 → ID 매핑 생성
            name_to_id = {}
            for cid, cdata in self.character_data.items():
                cname = cdata.get('name', '')
                if cname:
                    name_to_id[cname] = cid
            
            # (N) 패턴 제거 함수
            import re
            def strip_number_suffix(name):
                """이름에서 (2), (3) 등의 접미사 제거"""
                return re.sub(r'\(\d+\)$', '', name).strip()
            
            # interaction 키를 이름에서 ID로 변환
            interaction_by_id = {}
            if isinstance(interaction, dict):
                print(f"[AI] 상호작용 대사 키들: {list(interaction.keys())}")
                print(f"[AI] 이름→ID 매핑: {name_to_id}")
                
                for key, dialogues in interaction.items():
                    if key == 'default':
                        # default는 그대로 유지
                        interaction_by_id['default'] = dialogues
                    elif key in name_to_id:
                        # 정확히 일치하는 이름
                        target_id = name_to_id[key]
                        if target_id not in interaction_by_id:
                            interaction_by_id[target_id] = []
                        interaction_by_id[target_id].extend(dialogues if dialogues else [])
                        print(f"[AI] 이름 '{key}' → ID {target_id} 매칭 성공")
                    else:
                        # (N) 패턴 제거 후 다시 시도
                        base_name = strip_number_suffix(key)
                        if base_name in name_to_id:
                            target_id = name_to_id[base_name]
                            if target_id not in interaction_by_id:
                                interaction_by_id[target_id] = []
                            interaction_by_id[target_id].extend(dialogues if dialogues else [])
                            print(f"[AI] 이름 '{key}' → '{base_name}' → ID {target_id} 매칭 성공")
                        elif isinstance(key, int):
                            # 이미 ID인 경우
                            if key not in interaction_by_id:
                                interaction_by_id[key] = []
                            interaction_by_id[key].extend(dialogues if dialogues else [])
                        else:
                            # 부분 매칭 시도
                            matched = False
                            for name, cid in name_to_id.items():
                                if name in key or key in name:
                                    if cid not in interaction_by_id:
                                        interaction_by_id[cid] = []
                                    interaction_by_id[cid].extend(dialogues if dialogues else [])
                                    print(f"[AI] 이름 '{key}' 부분 매칭 → '{name}' → ID {cid}")
                                    matched = True
                                    break
                            if not matched:
                                print(f"[AI] 상호작용 대사 키 매칭 실패: '{key}'")
            
            global _ai_dialogues_cache
            
            # 에러가 발생한 경우 기존 캐시 완전 보존 (아무것도 하지 않음)
            if is_error:
                print(f"[AI] char_id={char_id} 에러 발생 - 기존 캐시 유지 (변경 없음)")
            # 빈 데이터가 반환된 경우도 기존 캐시 보존
            elif not solo and not interaction_by_id and not fallback:
                print(f"[AI] char_id={char_id} 빈 데이터 반환 - 기존 캐시 유지")
            # 기존 캐시가 있으면 추가 (중복 제거)
            elif char_id in _ai_dialogues_cache:
                cache = _ai_dialogues_cache[char_id]
                if 'solo' not in cache:
                    cache['solo'] = []
                if 'fallback' not in cache:
                    cache['fallback'] = []

                # solo 대사 중복/유사 제거 후 추가
                added_solo = 0
                skipped_similar = 0
                for d in solo:
                    if not d or not d.strip():
                        continue
                    if is_similar_dialogue(d, cache['solo']):
                        skipped_similar += 1
                        continue
                    cache['solo'].append(d)
                    added_solo += 1

                # fallback 대사 중복/유사 제거 후 추가
                added_fallback = 0
                for d in fallback:
                    if not d or not d.strip():
                        continue
                    if is_similar_dialogue(d, cache['fallback']):
                        continue
                    cache['fallback'].append(d)
                    added_fallback += 1

                if 'interaction' not in cache:
                    cache['interaction'] = {}

                # interaction 대사 중복/유사 제거 후 추가
                added_interaction = {}
                skipped_interaction = 0
                for key, dialogues in interaction_by_id.items():
                    if key not in cache['interaction']:
                        cache['interaction'][key] = []
                    added_count = 0
                    for d in (dialogues if dialogues else []):
                        if not d or not d.strip():
                            continue
                        if is_similar_dialogue(d, cache['interaction'][key]):
                            skipped_interaction += 1
                            continue
                        cache['interaction'][key].append(d)
                        added_count += 1
                    if added_count > 0:
                        added_interaction[key] = added_count
                cache['generated_at'] = time.time()

                # 상호작용 대사 통계 출력 (실제 추가된 개수)
                interaction_stats = ", ".join([f"{k}:+{v}" for k, v in added_interaction.items()])
                total_skipped = skipped_similar + skipped_interaction
                print(f"[AI] char_id={char_id} 캐시 추가 (solo +{added_solo}, 유사 스킵 {total_skipped}, interaction: {interaction_stats})")
                # 성공 시 즉시 저장
                self.save_characters()
            else:
                # 새 캐시 생성
                _ai_dialogues_cache[char_id] = {
                    'solo': solo,
                    'interaction': interaction_by_id,
                    'fallback': fallback,
                    'reference': {},  # 참고용 수동 대사
                    'generated_at': time.time()
                }
                # 상호작용 대사 통계 출력
                interaction_stats = ", ".join([f"{k}:{len(v)}개" for k, v in interaction_by_id.items()])
                print(f"[AI] char_id={char_id} 새 캐시 생성 (solo {len(solo)}개, interaction: {interaction_stats})")
                # 성공 시 즉시 저장
                self.save_characters()
            
            # 생성 상태 지우기
            for c in self.characters:
                if c.char_id == char_id:
                    c.generating_status = ""
                    c.update()
                    break
            
            # 모드에 따라 다음 처리 (에러여도 다음 캐릭터로 진행)
            if self._current_ai_mode == 'generate_now':
                self._generate_now_index += 1
                if self._generate_now_index < len(self._generate_now_queue):
                    total = len(self._generate_now_queue)
                    next_idx = self._generate_now_index + 1
                    if self._generate_now_btn:
                        self._generate_now_btn.setText(f"대기 중... {next_idx}/{total}")
                    QTimer.singleShot(60000, self._process_next_generate_now)
                else:
                    print("[AI] 즉시 대사 생성 완료")
                    self._is_generating_now = False
                    self._current_ai_mode = None
                    if self._generate_now_btn:
                        self._generate_now_btn.setEnabled(True)
                        self._generate_now_btn.setText("즉시 대사 생성")
            
            elif self._current_ai_mode == 'uncached':
                self._uncached_index += 1
                if self._uncached_index < len(self._uncached_queue):
                    QTimer.singleShot(60000, self._process_next_uncached)
                else:
                    self._current_ai_mode = None
            
            elif self._current_ai_mode == 'cache':
                # _has_more_cache 확인하여 다음 캐릭터 처리
                if item.get('_has_more_cache', False):
                    QTimer.singleShot(60000, self._process_next_ai_cache)
            
            elif self._current_ai_mode == 'single':
                self._current_ai_mode = None
                self.update_ai_timer_interval()
            
            elif self._current_ai_mode == 'add':
                # _has_more_add 확인하여 다음 캐릭터 처리
                if item.get('_has_more_add', False):
                    QTimer.singleShot(60000, self._process_next_ai_add)
                    
        except Exception as e:
            print(f"[AI] 큐 처리 중 오류: {type(e).__name__}: {e}")
            # 오류가 발생해도 계속 진행
            self._is_generating_now = False
            self._current_ai_mode = None
            if hasattr(self, '_generate_now_btn') and self._generate_now_btn:
                try:
                    self._generate_now_btn.setEnabled(True)
                    self._generate_now_btn.setText("즉시 대사 생성")
                except:
                    pass
    
    def regenerate_ai_cache(self):
        """AI 대사 캐시 재생성/추가
        - 캐시 없으면: 캐시 없는 모든 캐릭터 순차 생성
        - 캐시 있으면: 기존 대사에 추가 (1시간마다)
        """
        if not self.ai_enabled:
            return
        
        global _ai_dialogues_cache
        
        # 캐시가 없는 캐릭터 찾기 (ai_auto_generate 체크)
        uncached_chars = []
        for char in self.characters:
            char_data = self.character_data.get(char.char_id, {})
            ai_auto = char_data.get('ai_auto_generate', True)
            
            if not ai_auto:
                continue  # 자동생성 비활성화
            
            if char.personality and char.char_id not in _ai_dialogues_cache:
                # 대사 수 계산 (정렬용)
                cache = _ai_dialogues_cache.get(char.char_id, {})
                current_count = len(cache.get('solo', [])) + sum(len(v) for v in cache.get('interaction', {}).values())
                uncached_chars.append((char, current_count))
        
        if uncached_chars:
            # 대사 적은 순 정렬
            uncached_chars.sort(key=lambda x: x[1])
            
            # 캐시 없는 캐릭터들 모두 순차 생성
            print(f"[AI] 캐시 없는 캐릭터 {len(uncached_chars)}명 발견 - 순차 생성 (대사 적은 순)")
            self._uncached_queue = []
            
            for char, _ in uncached_chars:
                char_data = self.character_data.get(char.char_id, {})
                
                # 다른 캐릭터 정보 수집
                other_chars_info = []
                for other in self.characters:
                    if other.char_id != char.char_id:
                        other_name = self.character_data.get(other.char_id, {}).get('name', f'캐릭터 {other.char_id + 1}')
                        nicknames = char.nicknames.get(other.char_id, other_name)
                        rel_key = tuple(sorted([char.char_id, other.char_id]))
                        # 관계 정보 - 딕셔너리 형태에서 현재 캐릭터의 감정 추출
                        rel_data = self.relationships.get(rel_key, {})
                        if isinstance(rel_data, dict):
                            relationship = rel_data.get(char.char_id, "친구")
                        else:
                            relationship = rel_data if rel_data else "친구"
                        story = char.stories.get(other.char_id, "") if hasattr(char, 'stories') else ""
                        other_chars_info.append((other_name, nicknames, relationship, story))
                
                # 중복 이름 처리
                other_chars_info = make_unique_names(other_chars_info)
                
                sample_dialogues = char.dialogues.get('기본', [])
                sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '(선택)']
                
                background_story = char_data.get('background_story', '') or getattr(char, 'background_story', '')
                
                self._uncached_queue.append({
                    'char_id': char.char_id,
                    'name': char.char_name,
                    'personality': char.personality,
                    'sample_dialogues': sample_dialogues,
                    'other_chars_info': other_chars_info,
                    'background_story': background_story
                })
            
            self._uncached_index = 0
            self._process_next_uncached()
        else:
            # 모든 캐릭터에 대사 추가
            print("[AI] 기존 캐시에 대사 추가")
            self.add_dialogues_to_cache()
        
        # 타이머 간격 재조정
        self.update_ai_timer_interval()
    
    def _process_next_uncached(self):
        """캐시 없는 캐릭터 순차 생성"""
        if self._uncached_index >= len(self._uncached_queue):
            print("[AI] 캐시 없는 캐릭터 생성 완료")
            self._current_ai_mode = None
            return
        
        char_info = self._uncached_queue[self._uncached_index]
        char_id = char_info['char_id']
        print(f"[AI] {char_info['name']} 캐시 생성 중... ({self._uncached_index + 1}/{len(self._uncached_queue)})")
        
        # 현재 모드 설정
        self._current_ai_mode = 'uncached'
        
        # 생성 중 표시
        for char in self.characters:
            if char.char_id == char_id:
                char.generating_status = "대사 생성 중..."
                char.update()
                break
        
        # 큐를 사용하여 메인 스레드에서 처리
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error  # 에러 플래그
            })

        # 기존 대사 가져오기 (중복 방지용)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_info['name'],
            char_info['personality'],
            char_info['sample_dialogues'],
            char_info['other_chars_info'],
            on_complete,
            char_info.get('background_story', ''),
            0,
            existing
        )

    def generate_single_character_cache(self, char_id):
        """단일 캐릭터의 생성된 대사 생성"""
        if not self.ai_enabled or not self.gemini_api_key:
            return
        
        # 캐릭터 찾기
        target_char = None
        for char in self.characters:
            if char.char_id == char_id:
                target_char = char
                break
        
        if not target_char or not target_char.personality:
            return
        
        char_data = self.character_data.get(char_id, {})
        char_name = char_data.get('name', f'캐릭터 {char_id + 1}')
        
        # 다른 캐릭터 정보 수집
        other_chars_info = []
        for other in self.characters:
            if other.char_id != char_id:
                other_data = self.character_data.get(other.char_id, {})
                other_name = other_data.get('name', f'캐릭터 {other.char_id + 1}')
                nicknames = target_char.nicknames.get(other.char_id, other_name)
                rel_key = tuple(sorted([char_id, other.char_id]))
                # 관계 정보 - 딕셔너리 형태에서 현재 캐릭터의 감정 추출
                rel_data = self.relationships.get(rel_key, {})
                if isinstance(rel_data, dict):
                    relationship = rel_data.get(char_id, "친구")
                else:
                    relationship = rel_data if rel_data else "친구"
                story = target_char.stories.get(other.char_id, "") if hasattr(target_char, 'stories') else ""
                other_chars_info.append((other_name, nicknames, relationship, story))
        
        # 중복 이름 처리
        other_chars_info = make_unique_names(other_chars_info)
        
        sample_dialogues = target_char.dialogues.get('기본', [])
        sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '(선택)']
        
        # 배경 스토리
        background_story = char_data.get('background_story', '') or getattr(target_char, 'background_story', '')
        
        # 현재 모드 설정
        self._current_ai_mode = 'single'
        
        # 생성 중 표시
        target_char.generating_status = "대사 생성 중..."
        target_char.update()
        
        print(f"[AI] {char_name} 단일 캐릭터 대사 생성 시작")
        
        # 큐를 사용하여 메인 스레드에서 처리
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error  # 에러 플래그
            })

        # 기존 대사 가져오기 (중복 방지용)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_name,
            target_char.personality,
            sample_dialogues,
            other_chars_info,
            on_complete,
            background_story,
            0,
            existing
        )

    def add_dialogues_to_cache(self):
        """기존 캐시에 대사 추가"""
        # 대사 추가할 캐릭터 큐 생성
        chars_to_add = []
        
        for char in self.characters:
            if not char.personality:
                continue
            if char.char_id not in _ai_dialogues_cache:
                continue  # 캐시 없으면 스킵 (generate_ai_cache에서 처리)
            
            # ai_auto_generate 체크
            char_data = self.character_data.get(char.char_id, {})
            ai_auto = char_data.get('ai_auto_generate', True)
            if not ai_auto:
                continue  # 자동생성 비활성화
            
            # 현재 대사 수 계산 (정렬용)
            cache = _ai_dialogues_cache.get(char.char_id, {})
            current_count = len(cache.get('solo', [])) + sum(len(v) for v in cache.get('interaction', {}).values())
            
            # 다른 캐릭터 정보 수집
            other_chars_info = []
            for other in self.characters:
                if other.char_id != char.char_id:
                    nicknames = char.nicknames.get(other.char_id, other.char_name)
                    rel_key = tuple(sorted([char.char_id, other.char_id]))
                    # 관계 정보 - 딕셔너리 형태에서 현재 캐릭터의 감정 추출
                    rel_data = self.relationships.get(rel_key, {})
                    if isinstance(rel_data, dict):
                        relationship = rel_data.get(char.char_id, "친구")
                    else:
                        relationship = rel_data if rel_data else "친구"
                    story = char.stories.get(other.char_id, "")
                    other_chars_info.append((other.char_name, nicknames, relationship, story))
            
            # 중복 이름 처리
            other_chars_info = make_unique_names(other_chars_info)
            
            sample_dialogues = char.dialogues.get('기본', [])
            sample_dialogues = [d for d in sample_dialogues if d.strip() and d != '(선택)']
            
            # 배경 스토리
            background_story = char_data.get('background_story', '') or getattr(char, 'background_story', '')
            
            chars_to_add.append({
                'char_id': char.char_id,
                'name': char.char_name,
                'personality': char.personality,
                'sample_dialogues': sample_dialogues,
                'other_chars_info': other_chars_info,
                'background_story': background_story,
                'current_dialogue_count': current_count
            })
        
        # 대사 적은 캐릭터 우선 정렬
        chars_to_add.sort(key=lambda x: x['current_dialogue_count'])
        
        self._ai_add_queue = chars_to_add
        
        if self._ai_add_queue:
            print(f"[AI] {len(self._ai_add_queue)}개 캐릭터에 대사 추가 (대사 적은 순)")
            self._ai_add_index = 0
            self._process_next_ai_add()
    
    def _process_next_ai_add(self):
        """대사 추가 처리 (큐에서 하나씩)"""
        if self._ai_add_index >= len(self._ai_add_queue):
            print("[AI] 대사 추가 완료")
            self._current_ai_mode = None
            return
        
        char_info = self._ai_add_queue[self._ai_add_index]
        char_id = char_info['char_id']
        print(f"[AI] {char_info['name']} 대사 추가 중... ({self._ai_add_index + 1}/{len(self._ai_add_queue)})")
        
        # 현재 모드 설정 및 다음 인덱스 미리 저장
        self._current_ai_mode = 'add'
        self._ai_add_index += 1
        has_more = self._ai_add_index < len(self._ai_add_queue)
        
        # 큐를 사용하여 메인 스레드에서 처리
        def on_complete(solo, interaction, fallback, is_error=False):
            self._ai_complete_queue.append({
                'char_id': char_id,
                'solo': solo,
                'interaction': interaction,
                'fallback': fallback,
                'is_error': is_error,  # 에러 플래그
                '_has_more_add': has_more  # 다음 처리 여부 전달
            })

        # 기존 대사 가져오기 (중복 방지용)
        existing = _ai_dialogues_cache.get(char_id, None)

        generate_dialogues_batch(
            char_info['name'],
            char_info['personality'],
            char_info['sample_dialogues'],
            char_info['other_chars_info'],
            on_complete,
            char_info.get('background_story', ''),
            0,
            existing
        )

    def check_collisions(self):
        """캐릭터 간 충돌 체크"""
        try:
            for i, char1 in enumerate(self.characters):
                for char2 in self.characters[i+1:]:
                    if char1.check_collision_with(char2):
                        char1.interact_with(char2)
        except Exception as e:
            # 강제 종료 방지
            print(f"[오류] check_collisions 에러: {e}")
    
    def save_characters(self):
        """캐릭터 설정 저장"""
        # 복원 후에는 저장하지 않음 (복원된 파일 보호)
        if getattr(self, '_skip_save_on_close', False):
            print("[저장 스킵] 복원 모드 - 저장하지 않음")
            return

        import json

        print(f"[저장 시작] 캐릭터 수: {len(self.character_data)}")
        
        # AI 캐시 저장용 (generated_at은 저장 안 함)
        global _ai_dialogues_cache
        ai_cache_to_save = {}
        total_dialogues = 0
        for char_id, cache_data in _ai_dialogues_cache.items():
            solo_count = len(cache_data.get('solo', []))
            interaction_count = sum(len(v) for v in cache_data.get('interaction', {}).values())
            fallback_count = len(cache_data.get('fallback', []))
            total_dialogues += solo_count + interaction_count + fallback_count
            
            ai_cache_to_save[str(char_id)] = {
                'solo': cache_data.get('solo', []),
                'interaction': cache_data.get('interaction', {}),
                'fallback': cache_data.get('fallback', []),
                'reference': cache_data.get('reference', {})  # 참고용 수동 대사
            }
            print(f"[저장] AI 캐시 캐릭터 {char_id}: solo={solo_count}, interaction={interaction_count}, fallback={fallback_count}")
        
        print(f"[저장] AI 캐시 총 {len(ai_cache_to_save)}개 캐릭터, {total_dialogues}개 대사")

        # 현재 캐시가 비어있으면 기존 저장된 캐시 유지 (대사 손실 방지)
        if not ai_cache_to_save and os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    existing_config = json.load(f)
                    existing_cache = existing_config.get('ai_dialogues_cache', {})
                    if existing_cache:
                        ai_cache_to_save = existing_cache
                        print(f"[저장] 현재 캐시 비어있음 - 기존 캐시 {len(existing_cache)}개 유지")
            except Exception as e:
                print(f"[저장] 기존 캐시 로드 실패: {e}")

        config = {
            'char_id_counter': self.char_id_counter,
            'characters': [],
            'relationships': {},
            'dialogues': {},
            'gemini_api_key': self.gemini_api_key,  # API 키 저장
            'gemini_model': self.gemini_model,  # AI 모델 저장
            'ai_enabled': self.ai_enabled,  # AI 활성화 상태 저장
            'ai_dialogues_cache': ai_cache_to_save,  # AI 대사 캐시 저장
            'selected_monitor': getattr(self, '_selected_monitor', 0),  # 모니터 설정 저장
            'auto_backup_enabled': getattr(self, 'auto_backup_enabled', True),  # 자동 백업 설정
            'max_backups': getattr(self, 'max_backups', 12)  # 백업 보관 개수
        }
        
        # 관계 정보 저장 (정규화된 형식: {"min_id,max_id": {id1: "감정", id2: "감정"}})
        print(f"[저장] self.relationships 저장 전: {self.relationships}")
        for key, value in self.relationships.items():
            # key가 튜플인지 확인
            if not isinstance(key, tuple) or len(key) != 2:
                print(f"[저장] 잘못된 관계 키 무시: {key}")
                continue
            # 키를 항상 정렬하여 저장 (일관성 유지)
            sorted_key = tuple(sorted(key))
            key_str = f"{sorted_key[0]},{sorted_key[1]}"

            # value 정규화: {char_id: "감정", other_id: "감정"} 형식으로 통일
            if isinstance(value, dict):
                filtered_value = {}
                for k, v in value.items():
                    # 키를 int로 변환 시도
                    try:
                        k_int = int(k)
                    except (ValueError, TypeError):
                        continue
                    # 값이 문자열이면 그대로, 아니면 기본값
                    if isinstance(v, str):
                        filtered_value[k_int] = v
                    elif isinstance(v, dict) and 'my_feeling' in v:
                        # 레거시 중첩 dict 형식 처리
                        filtered_value[k_int] = v.get('my_feeling', '무관심')
                    else:
                        filtered_value[k_int] = "무관심"
                config['relationships'][key_str] = filtered_value
            elif isinstance(value, str):
                # 레거시 단순 문자열 형식 -> 현재 형식으로 변환
                config['relationships'][key_str] = {
                    sorted_key[0]: value,
                    sorted_key[1]: "무관심"
                }
            else:
                continue
            print(f"[저장] 관계 저장: {key_str} -> {config['relationships'][key_str]}")
        
        print(f"[저장] 관계 수: {len(config['relationships'])}")
        
        # 대사 정보 저장
        for char_id, dialogues in self.dialogues.items():
            config['dialogues'][str(char_id)] = dialogues
        
        print(f"[저장] 대사 수: {len(config['dialogues'])}")
        
        for char_id, data in self.character_data.items():
            # 이미지를 base64로 인코딩하여 저장
            import base64
            try:
                print(f"[저장] 캐릭터 {char_id}: {data.get('name', '이름없음')}")
                with open(data['image_path'], 'rb') as f:
                    image_data = base64.b64encode(f.read()).decode('utf-8')
                
                config['characters'].append({
                    'char_id': char_id,
                    'name': data['name'],
                    'scale': data['scale'],
                    'bubble_color': data['bubble_color'],
                    'bubble_size': data.get('bubble_size', 100),
                    'facing_direction': data['facing_direction'],
                    'image_data': image_data,
                    'image_ext': os.path.splitext(data['image_path'])[1],
                    'is_active': data.get('is_active', True),
                    'personality': data.get('personality', ''),
                    'nicknames': data.get('nicknames', {}),
                    'stories': data.get('stories', {}),
                    'background_story': data.get('background_story', ''),
                    'sample_dialogues': data.get('sample_dialogues', []),
                    'catchphrase': data.get('catchphrase', ''),
                    'ai_auto_generate': data.get('ai_auto_generate', True)  # AI 자동생성 여부
                })
            except Exception as e:
                print(f"[오류] 캐릭터 {char_id} 저장 실패: {e}")
        
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, ensure_ascii=False, indent=2)
                f.flush()  # 강제 플러시
                os.fsync(f.fileno())  # 디스크에 강제 쓰기
            
            file_size = os.path.getsize(self.config_file)
            file_size_mb = file_size / (1024 * 1024)
            print(f"[저장 완료] 파일: {self.config_file}")
            print(f"[저장 완료] 파일 크기: {file_size_mb:.2f} MB ({file_size} bytes)")
            
            if file_size_mb > 30:
                print(f"[경고] 설정 파일이 큽니다 ({file_size_mb:.2f} MB). 캐릭터 이미지 크기를 줄이는 것을 권장합니다.")
        except Exception as e:
            print(f"[오류] 저장 실패: {e}")
            import traceback
            print(traceback.format_exc())

    def create_auto_backup(self):
        """자동 백업 생성 (1시간마다 호출됨)"""
        # 자동 백업이 꺼져 있으면 스킵
        if not getattr(self, 'auto_backup_enabled', True):
            return

        if not os.path.exists(self.config_file):
            return

        try:
            from datetime import datetime

            # 백업 디렉토리 생성
            backup_dir = os.path.join(os.path.dirname(self.config_file), 'backups')
            os.makedirs(backup_dir, exist_ok=True)

            # 백업 파일명 생성 (타임스탬프 포함)
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            backup_filename = f"kiwipet_backup_{timestamp}.json"
            backup_path = os.path.join(backup_dir, backup_filename)

            # 현재 설정 파일 복사
            import shutil
            shutil.copy2(self.config_file, backup_path)

            print(f"[백업] 자동 백업 생성: {backup_filename}")

            # 오래된 백업 정리
            self.cleanup_old_backups(backup_dir)

        except Exception as e:
            print(f"[백업] 자동 백업 실패: {e}")

    def cleanup_old_backups(self, backup_dir):
        """오래된 백업 파일 삭제"""
        max_backups = getattr(self, 'max_backups', 12)
        try:
            backup_files = []
            for f in os.listdir(backup_dir):
                if f.startswith('kiwipet_backup_') and f.endswith('.json'):
                    full_path = os.path.join(backup_dir, f)
                    backup_files.append((full_path, os.path.getmtime(full_path)))

            # 수정 시간 기준 정렬 (최신순)
            backup_files.sort(key=lambda x: x[1], reverse=True)

            # 오래된 백업 삭제
            for backup_path, _ in backup_files[max_backups:]:
                os.remove(backup_path)
                print(f"[백업] 오래된 백업 삭제: {os.path.basename(backup_path)}")

        except Exception as e:
            print(f"[백업] 백업 정리 실패: {e}")

    def get_backup_list(self):
        """백업 파일 목록 조회"""
        backup_dir = os.path.join(os.path.dirname(self.config_file), 'backups')
        if not os.path.exists(backup_dir):
            return []

        backup_files = []
        try:
            from datetime import datetime
            for f in os.listdir(backup_dir):
                if f.startswith('kiwipet_backup_') and f.endswith('.json'):
                    full_path = os.path.join(backup_dir, f)
                    # 파일이 실제로 존재하는지 확인
                    if not os.path.exists(full_path):
                        continue
                    try:
                        mtime = os.path.getmtime(full_path)
                        size = os.path.getsize(full_path)
                    except (OSError, FileNotFoundError):
                        continue

                    # 파일명에서 날짜 추출
                    try:
                        timestamp_str = f.replace('kiwipet_backup_', '').replace('.json', '')
                        dt = datetime.strptime(timestamp_str, '%Y%m%d_%H%M%S')
                        display_time = dt.strftime('%Y-%m-%d %H:%M:%S')
                    except:
                        display_time = datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M:%S')

                    backup_files.append({
                        'path': full_path,
                        'filename': f,
                        'display_time': display_time,
                        'timestamp_str': timestamp_str if 'timestamp_str' in dir() else '',
                        'mtime': mtime,
                        'size': size,
                        'size_mb': size / (1024 * 1024)
                    })

            # 최신순 정렬 (파일명 타임스탬프 기준)
            backup_files.sort(key=lambda x: x['filename'], reverse=True)

        except Exception as e:
            print(f"[백업] 백업 목록 조회 실패: {e}")

        return backup_files

    def show_backup_restore_dialog(self):
        """백업 복원 다이얼로그 표시"""
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, QPushButton, QLabel, QMessageBox

        backup_list = self.get_backup_list()

        if not backup_list:
            QMessageBox.information(None, "백업 없음", "저장된 백업 파일이 없습니다.")
            return

        dialog = QDialog()
        dialog.setWindowTitle("백업에서 복원")
        dialog.setMinimumSize(500, 400)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #2b2b2b;
            }
            QLabel {
                color: white;
            }
            QListWidget {
                background-color: #3b3b3b;
                color: white;
                border: 1px solid #555;
                border-radius: 5px;
            }
            QListWidget::item {
                padding: 8px;
                border-bottom: 1px solid #444;
            }
            QListWidget::item:selected {
                background-color: #4a9eff;
            }
            QPushButton {
                background-color: #4a4a4a;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #5a5a5a;
            }
            QPushButton#restoreBtn {
                background-color: #4a9eff;
            }
            QPushButton#restoreBtn:hover {
                background-color: #5ab0ff;
            }
        """)

        layout = QVBoxLayout(dialog)

        # 설명 라벨
        desc_label = QLabel("예기치 못하게 대사가 사라진 경우, 아래 백업에서 복원할 수 있습니다.")
        desc_label.setWordWrap(True)
        layout.addWidget(desc_label)

        # 백업 목록
        list_widget = QListWidget()
        for backup in backup_list:
            item_text = f"{backup['display_time']} ({backup['size_mb']:.2f} MB)"
            item = QListWidgetItem(item_text)
            item.setData(256, backup['path'])  # Qt.UserRole = 256
            list_widget.addItem(item)
        layout.addWidget(list_widget)

        # 버튼
        btn_layout = QHBoxLayout()

        cancel_btn = QPushButton("취소")
        cancel_btn.clicked.connect(dialog.reject)
        btn_layout.addWidget(cancel_btn)

        btn_layout.addStretch()

        restore_btn = QPushButton("선택한 백업으로 복원")
        restore_btn.setObjectName("restoreBtn")

        def do_restore():
            current_item = list_widget.currentItem()
            if not current_item:
                QMessageBox.warning(dialog, "선택 필요", "복원할 백업을 선택해주세요.")
                return

            backup_path = current_item.data(256)

            reply = QMessageBox.question(
                dialog,
                "복원 확인",
                "선택한 백업으로 복원하시겠습니까?\n\n현재 데이터는 덮어씌워집니다.\n(현재 상태는 자동으로 백업됩니다)",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                try:
                    # 현재 상태 먼저 백업
                    self.create_auto_backup()

                    # 백업 파일로 복원
                    import shutil
                    shutil.copy2(backup_path, self.config_file)

                    # 종료 시 저장 방지 플래그 설정
                    self._skip_save_on_close = True

                    QMessageBox.information(dialog, "복원 완료", "백업에서 복원되었습니다.\n\n적용하려면 프로그램을 껐다 켜주세요.")
                    dialog.accept()

                except Exception as e:
                    QMessageBox.critical(dialog, "복원 실패", f"복원 중 오류가 발생했습니다:\n{e}")

        restore_btn.clicked.connect(do_restore)
        btn_layout.addWidget(restore_btn)

        layout.addLayout(btn_layout)

        dialog.exec_()

    def set_window_icon(self):
        """윈도우 아이콘 설정"""
        # 앱 아이콘은 QApplication에서 설정됨
        # 추가로 윈도우별 아이콘이 필요한 경우 여기서 설정
        app_icon = load_app_icon()
        if app_icon:
            self.setWindowIcon(app_icon)
    
    def _create_default_icon(self):
        """기본 아이콘 직접 생성 (더 이상 사용 안 함)"""
        pass
    
    def load_characters(self):
        """캐릭터 설정 로드"""
        print(f"[로드 시작] 설정 파일: {self.config_file}")
        
        if not os.path.exists(self.config_file):
            print("[로드] 설정 파일 없음 - 새로 시작")
            return
        
        try:
            import json
            import base64
            
            # 파일 크기 체크
            file_size = os.path.getsize(self.config_file)
            file_size_mb = file_size / (1024 * 1024)
            print(f"[로드] 설정 파일 크기: {file_size_mb:.2f} MB")
            
            if file_size_mb > 50:
                print(f"[경고] 설정 파일이 매우 큽니다 ({file_size_mb:.2f} MB). 로드에 시간이 걸릴 수 있습니다.")
            
            # JSON 로드
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                print(f"[로드] 설정 파일 읽기 성공")
            except json.JSONDecodeError as e:
                print(f"[로드 오류] JSON 파싱 실패: {e}")
                return
            
            self.char_id_counter = config.get('char_id_counter', 0)
            print(f"[로드] char_id_counter: {self.char_id_counter}")
            
            # API 키 로드 (제어 문자 제거)
            loaded_api_key = config.get('gemini_api_key', '')
            self.gemini_api_key = clean_api_key(loaded_api_key)
            if self.gemini_api_key:
                set_gemini_api_key(self.gemini_api_key)  # 글로벌 변수에도 설정
                print(f"[로드] API 키 로드됨")

            # AI 모델 로드
            self.gemini_model = config.get('gemini_model', 'gemini-2.5-flash-lite')
            set_gemini_model(self.gemini_model)
            print(f"[로드] AI 모델: {self.gemini_model}")

            # AI 활성화 상태 로드
            self.ai_enabled = config.get('ai_enabled', False)
            print(f"[로드] AI 활성화: {self.ai_enabled}")

            # 자동 백업 설정 로드
            self.auto_backup_enabled = config.get('auto_backup_enabled', True)
            self.max_backups = config.get('max_backups', 12)
            print(f"[로드] 자동 백업: {self.auto_backup_enabled}, 보관 개수: {self.max_backups}")

            # 타이머 상태 업데이트
            if hasattr(self, 'auto_backup_timer'):
                if self.auto_backup_enabled:
                    if not self.auto_backup_timer.isActive():
                        self.auto_backup_timer.start(60 * 60 * 1000)  # 1시간
                else:
                    self.auto_backup_timer.stop()

            # AI 대사 캐시 로드 (개별 try-except)
            try:
                global _ai_dialogues_cache
                saved_cache = config.get('ai_dialogues_cache', {})
                loaded_count = 0
                for char_id_str, cache_data in saved_cache.items():
                    try:
                        char_id = int(char_id_str)
                        
                        # interaction 키를 int로 변환 (JSON에서 문자열로 저장됨)
                        raw_interaction = cache_data.get('interaction', {})
                        converted_interaction = {}
                        for k, v in raw_interaction.items():
                            try:
                                converted_interaction[int(k)] = v
                            except (ValueError, TypeError):
                                # 'default' 같은 문자열 키는 그대로 유지
                                converted_interaction[k] = v
                        
                        solo_count = len(cache_data.get('solo', []))
                        interaction_count = sum(len(v) for v in converted_interaction.values())
                        fallback_count = len(cache_data.get('fallback', []))

                        _ai_dialogues_cache[char_id] = {
                            'solo': cache_data.get('solo', []),
                            'interaction': converted_interaction,
                            'fallback': cache_data.get('fallback', []),
                            'reference': cache_data.get('reference', {}),  # 참고용 수동 대사
                            'generated_at': time.time()  # 로드 시간으로 설정
                        }
                        loaded_count += 1
                        print(f"[로드] AI 캐시 캐릭터 {char_id}: solo={solo_count}, interaction={interaction_count}, fallback={fallback_count}")
                    except Exception as e:
                        print(f"[로드] AI 캐시 캐릭터 {char_id_str} 로드 오류: {e}")
                print(f"[로드] AI 캐시: {loaded_count}개 캐릭터 로드 완료")
            except Exception as e:
                print(f"[로드] AI 캐시 로드 오류 (계속 진행): {e}")
            
            # 관계 정보 로드 (레거시 형식 마이그레이션 포함)
            relationships_list = config.get('relationships', {})
            print(f"[로드] 관계 데이터 (JSON): {relationships_list}")
            for key_str, value in relationships_list.items():
                try:
                    # "0,1" -> (0, 1)
                    if ',' not in str(key_str):
                        print(f"[로드] 잘못된 관계 키 형식 무시: {key_str}")
                        continue
                    raw_ids = list(map(int, str(key_str).split(',')))
                    # 키를 항상 정렬 (일관성 유지)
                    ids = tuple(sorted(raw_ids))

                    # value 정규화: {char_id: "감정", other_id: "감정"} 형식으로 통일
                    if isinstance(value, dict):
                        converted_value = {}
                        for k, v in value.items():
                            try:
                                k_int = int(k)
                            except (ValueError, TypeError):
                                print(f"[로드] 관계 내부 키 변환 실패: {k}")
                                continue
                            # 값이 문자열이면 그대로, 중첩 dict면 my_feeling 추출
                            if isinstance(v, str):
                                converted_value[k_int] = v
                            elif isinstance(v, dict) and 'my_feeling' in v:
                                converted_value[k_int] = v.get('my_feeling', '무관심')
                            else:
                                converted_value[k_int] = "무관심"
                        value = converted_value
                    elif isinstance(value, str):
                        # 레거시 단순 문자열 형식 -> 현재 형식으로 변환
                        value = {ids[0]: value, ids[1]: "무관심"}
                    else:
                        continue

                    # 기존 데이터와 병합 (같은 키가 있으면 업데이트)
                    if ids in self.relationships:
                        self.relationships[ids].update(value)
                    else:
                        self.relationships[ids] = value
                    print(f"[로드] 관계 로드: {ids} -> {self.relationships[ids]}")
                except Exception as e:
                    print(f"[로드] 관계 로드 오류: key_str={key_str}, value={value}, error={e}")
            
            print(f"[로드] 관계 수: {len(self.relationships)}")
            print(f"[로드] self.relationships 로드 후: {self.relationships}")
            
            # 대사 정보 로드 (개별 try-except)
            try:
                dialogues_data = config.get('dialogues', {})
                for char_id_str, dialogues in dialogues_data.items():
                    try:
                        char_id_int = int(char_id_str)
                        
                        # 대사 키 형식 통일: int 키 → 'char_X' 형식으로 변환
                        if isinstance(dialogues, dict):
                            converted_dialogues = {}
                            for key, values in dialogues.items():
                                if key == '기본':
                                    converted_dialogues['기본'] = values
                                elif isinstance(key, int):
                                    # int → 'char_X'
                                    converted_dialogues[f'char_{key}'] = values
                                elif isinstance(key, str) and key.isdigit():
                                    # '0', '1' → 'char_0', 'char_1'
                                    converted_dialogues[f'char_{key}'] = values
                                else:
                                    # 이미 'char_X' 형식이거나 다른 형식
                                    converted_dialogues[key] = values
                            dialogues = converted_dialogues
                        
                        self.dialogues[char_id_int] = dialogues
                        # 수동 대사를 AI 캐시에 동기화
                        sync_dialogues_to_ai_cache(char_id_int, dialogues)
                    except Exception as e:
                        print(f"[로드] 대사 캐릭터 {char_id_str} 로드 오류: {e}")
                print(f"[로드] 대사 수: {len(self.dialogues)}")
            except Exception as e:
                print(f"[로드] 대사 로드 오류 (계속 진행): {e}")
            
            characters_count = len(config.get('characters', []))
            print(f"[로드] 캐릭터 수: {characters_count}")
            
            for char_config in config.get('characters', []):
                try:
                    char_id = char_config['char_id']
                    is_active = char_config.get('is_active', True)
                    print(f"[로드] 캐릭터 {char_id}: {char_config.get('name', '이름없음')}, active: {is_active}")
                    
                    # 임시 이미지 파일 생성 - app_dir 내에 저장
                    temp_dir = os.path.join(self.app_dir, 'temp_images')
                    os.makedirs(temp_dir, exist_ok=True)
                    
                    image_path = os.path.join(temp_dir, f"char_{char_id}{char_config['image_ext']}")
                    
                    # base64 디코딩하여 이미지 저장
                    image_data = base64.b64decode(char_config['image_data'])
                    with open(image_path, 'wb') as f:
                        f.write(image_data)
                    
                    # 캐릭터 위젯 생성
                    char_widget = CharacterWidget(
                        image_path,
                        char_id,
                        char_config['facing_direction'],
                        char_config['scale'],
                        char_config['bubble_color'],
                        char_config.get('bubble_size', 100)
                    )
                    self.characters.append(char_widget)
                    
                    # 비활성화 상태면 숨기기
                    if not is_active:
                        char_widget.hide()
                        char_widget.timer.stop()
                    
                    # 캐릭터 데이터 저장 (nicknames, stories 키를 int로 변환)
                    raw_nicknames = char_config.get('nicknames', {})
                    raw_stories = char_config.get('stories', {})
                    
                    # 키를 int로 변환 (실패하면 무시)
                    nicknames = {}
                    for k, v in raw_nicknames.items():
                        try:
                            nicknames[int(k)] = v
                        except (ValueError, TypeError):
                            pass
                    
                    stories = {}
                    for k, v in raw_stories.items():
                        try:
                            stories[int(k)] = v
                        except (ValueError, TypeError):
                            pass
                    
                    catchphrase = char_config.get('catchphrase', '')
                    bubble_size = char_config.get('bubble_size', 100)
                    
                    self.character_data[char_id] = {
                        'name': char_config['name'],
                        'scale': char_config['scale'],
                        'bubble_color': char_config['bubble_color'],
                        'bubble_size': bubble_size,
                        'facing_direction': char_config['facing_direction'],
                        'image_path': image_path,
                        'is_active': is_active,
                        'personality': char_config.get('personality', ''),
                        'nicknames': nicknames,
                        'stories': stories,
                        'background_story': char_config.get('background_story', ''),
                        'sample_dialogues': char_config.get('sample_dialogues', []),
                        'catchphrase': catchphrase,
                        'ai_auto_generate': char_config.get('ai_auto_generate', True)  # AI 자동생성 여부
                    }
                    
                    # 카드 생성 (is_active, catchphrase 전달)
                    card = CharacterCard(char_id, image_path, char_config['name'], is_active, catchphrase)
                    card.remove_clicked.connect(self.remove_character)
                    card.change_image_clicked.connect(self.change_character_image)
                    card.change_scale_clicked.connect(self.change_character_scale)
                    card.change_bubble_color_clicked.connect(self.change_bubble_color)
                    card.change_relationships_clicked.connect(self.change_relationships)
                    card.change_dialogues_clicked.connect(self.change_dialogues)
                    card.change_personality_clicked.connect(self.change_personality)
                    card.name_changed.connect(self.update_character_name)
                    card.catchphrase_changed.connect(self.update_character_catchphrase)
                    card.toggle_active.connect(self.toggle_character_active)
                    card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                    
                    # 크기 표시 업데이트
                    scale = char_config.get('scale', 100)
                    card.update_scale_display(scale)
                    
                    self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                except Exception as e:
                    print(f"[로드] 캐릭터 로드 오류 (건너뜀): {e}")
                    import traceback
                    print(traceback.format_exc())
            
            # 관계 정보를 캐릭터에 전달
            self.update_character_relationships()
            
            # 대사 정보를 캐릭터에 전달
            self.update_character_dialogues()
            
            # 성격 정보를 캐릭터에 전달
            self.update_character_personalities()
            
            # 모니터 설정 로드 및 적용
            saved_monitor = config.get('selected_monitor', 0)
            self._selected_monitor = saved_monitor
            self._apply_monitor_to_characters(saved_monitor)
            
            # API 버튼 스타일 업데이트
            self.update_api_button_style()
            
            print(f"[로드 완료] 캐릭터 {characters_count}개 로드됨")
                
        except Exception as e:
            import traceback
            print(f"[로드 오류] {e}")
            print(traceback.format_exc())
    
    def update_api_button_style(self):
        """API 버튼 스타일 업데이트 (활성화 상태 반영)"""
        if self.ai_enabled and self.gemini_api_key:
            # 활성화 상태: 초록색
            self.api_btn.setText(" API ✓")
            self.api_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: #81C784;
                    color: white;
                    font-weight: 700;
                    border-radius: 12px;
                    font-family: {KOREAN_FONT};
                }}
                QPushButton:hover {{
                    background-color: #66BB6A;
                }}
            """)
            self._set_button_icon(self.api_btn, SVG_KEY.replace('#317C75', '#FFFFFF'), 16)
        else:
            # 비활성화 상태: 민트색
            self.api_btn.setText(" API KEY")
            self.api_btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: #C5E8D8;
                    color: #317C75;
                    font-weight: 700;
                    border-radius: 12px;
                    font-family: {KOREAN_FONT};
                }}
                QPushButton:hover {{
                    background-color: #B0DBC8;
                }}
            """)
            self._set_button_icon(self.api_btn, SVG_KEY, 16)
    
    def show_settings(self):
        """환경설정 다이얼로그"""
        dialog = QDialog(self)
        dialog.setWindowTitle("환경설정")
        dialog.setMinimumSize(400, 300)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setSpacing(15)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # 타이틀
        title = QLabel("환경설정")
        title.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 22px; font-weight: 700; font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif; padding: 10px;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # 구분선
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line)
        
        # 모니터 선택 섹션
        monitor_section = QWidget()
        monitor_layout = QVBoxLayout(monitor_section)
        monitor_layout.setSpacing(10)
        
        monitor_label = QLabel("모니터 선택")
        monitor_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        monitor_layout.addWidget(monitor_label)
        
        # 사용 가능한 모니터 목록
        from PyQt5.QtWidgets import QApplication
        screens = QApplication.screens()
        
        self.monitor_combo = QComboBox()
        self.monitor_combo.setMinimumHeight(40)
        self.monitor_combo.setStyleSheet("""
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 8px 12px;
                font-size: 14px;
                font-weight: 700;
            }
            QComboBox:hover {
                border-color: #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                padding-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #D4F4DD;
            }
        """)
        
        # 현재 선택된 모니터 확인
        current_screen_idx = getattr(self, '_selected_monitor', 0)
        
        # "모든 모니터" 옵션 추가
        self.monitor_combo.addItem("🖥️ 모든 모니터 (자유 이동)", -1)
        
        for i, screen in enumerate(screens):
            geo = screen.availableGeometry()
            name = screen.name() if screen.name() else f"모니터 {i+1}"
            self.monitor_combo.addItem(f"{name} ({geo.width()}x{geo.height()})", i)
        
        # 현재 설정된 값 선택
        if current_screen_idx == -1:
            self.monitor_combo.setCurrentIndex(0)  # "모든 모니터" 선택
        elif current_screen_idx < len(screens):
            self.monitor_combo.setCurrentIndex(current_screen_idx + 1)  # +1 because "모든 모니터" is at index 0
        
        monitor_layout.addWidget(self.monitor_combo)
        
        # 모니터 설명
        monitor_info = QLabel("캐릭터가 활동할 모니터를 선택합니다.\n'모든 모니터'를 선택하면 캐릭터가 모든 화면을 자유롭게 이동합니다.")
        monitor_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        monitor_layout.addWidget(monitor_info)
        
        layout.addWidget(monitor_section)

        # 구분선
        line2 = QFrame()
        line2.setFrameShape(QFrame.HLine)
        line2.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line2)

        # 시작 프로그램 섹션
        startup_section = QWidget()
        startup_layout = QVBoxLayout(startup_section)
        startup_layout.setSpacing(8)
        
        startup_label = QLabel("시작 프로그램")
        startup_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        startup_layout.addWidget(startup_label)
        
        # 토글 행
        toggle_row = QHBoxLayout()
        toggle_row.setSpacing(10)
        
        startup_toggle = ToggleSwitch(checked=self.is_startup_enabled())
        toggle_row.addWidget(startup_toggle)
        
        toggle_text = QLabel("컴퓨터 재부팅 시 바로 프로그램 켜기")
        toggle_text.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
        toggle_row.addWidget(toggle_text)
        toggle_row.addStretch()
        
        startup_layout.addLayout(toggle_row)
        
        # 설명
        startup_info = QLabel("이 버튼을 활성화하면 컴퓨터를 껐다 켜도 프로그램이 바로 켜집니다.")
        startup_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        startup_layout.addWidget(startup_info)
        
        layout.addWidget(startup_section)

        # 토글 참조 저장 (apply에서 사용)
        dialog.startup_toggle = startup_toggle

        # 구분선
        line3 = QFrame()
        line3.setFrameShape(QFrame.HLine)
        line3.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line3)

        # 자동 백업 설정 섹션
        auto_backup_section = QWidget()
        auto_backup_layout = QVBoxLayout(auto_backup_section)
        auto_backup_layout.setSpacing(8)

        auto_backup_label = QLabel("자동 백업")
        auto_backup_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        auto_backup_layout.addWidget(auto_backup_label)

        # 자동 백업 토글 행
        backup_toggle_row = QHBoxLayout()
        backup_toggle_row.setSpacing(10)

        auto_backup_toggle = ToggleSwitch(checked=getattr(self, 'auto_backup_enabled', True))
        backup_toggle_row.addWidget(auto_backup_toggle)

        backup_toggle_text = QLabel("1시간마다 자동 백업")
        backup_toggle_text.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
        backup_toggle_row.addWidget(backup_toggle_text)
        backup_toggle_row.addStretch()

        auto_backup_layout.addLayout(backup_toggle_row)

        # 백업 보관 개수 설정
        backup_count_row = QHBoxLayout()
        backup_count_row.setSpacing(10)

        backup_count_label = QLabel("백업 보관 개수:")
        backup_count_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
        backup_count_row.addWidget(backup_count_label)

        backup_count_combo = QComboBox()
        backup_count_combo.setMinimumHeight(32)
        backup_count_combo.setStyleSheet("""
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 8px;
                padding: 4px 10px;
                font-size: 13px;
                font-weight: 700;
                min-width: 80px;
            }
            QComboBox:hover {
                border-color: #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #D4F4DD;
            }
        """)
        backup_counts = [6, 12, 24, 48]
        current_max = getattr(self, 'max_backups', 12)
        for count in backup_counts:
            backup_count_combo.addItem(f"{count}개", count)
        # 현재 값 선택
        try:
            idx = backup_counts.index(current_max)
            backup_count_combo.setCurrentIndex(idx)
        except ValueError:
            backup_count_combo.setCurrentIndex(1)  # 기본 12개

        backup_count_row.addWidget(backup_count_combo)
        backup_count_row.addStretch()

        auto_backup_layout.addLayout(backup_count_row)

        # 설명
        auto_backup_info = QLabel("자동 백업은 1시간마다 현재 데이터를 저장합니다.\n백업 보관 개수를 초과하면 오래된 백업이 삭제됩니다.")
        auto_backup_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        auto_backup_layout.addWidget(auto_backup_info)

        layout.addWidget(auto_backup_section)

        # 토글/콤보 참조 저장 (apply에서 사용)
        dialog.auto_backup_toggle = auto_backup_toggle
        dialog.backup_count_combo = backup_count_combo

        # 구분선
        line4 = QFrame()
        line4.setFrameShape(QFrame.HLine)
        line4.setStyleSheet("background-color: #C5E8D8;")
        layout.addWidget(line4)

        # 백업 복원 섹션
        backup_section = QWidget()
        backup_layout = QVBoxLayout(backup_section)
        backup_layout.setSpacing(8)

        backup_label = QLabel("백업 복원")
        backup_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        backup_layout.addWidget(backup_label)

        backup_info = QLabel("예기치 못하게 대사가 사라진 경우, 이 부분에서 백업된 데이터를 확인할 수 있습니다.")
        backup_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        backup_info.setWordWrap(True)
        backup_layout.addWidget(backup_info)

        backup_btn = QPushButton("데이터 복원하기")
        backup_btn.setMinimumHeight(36)
        backup_btn.clicked.connect(self.show_backup_restore_dialog)
        backup_btn.setStyleSheet("""
            QPushButton {
                background-color: #C5E8D8;
                color: #5A9C85;
                font-weight: 700;
                border-radius: 10px;
                padding: 8px 20px;
            }
            QPushButton:hover {
                background-color: #8ECFB5;
            }
        """)
        backup_layout.addWidget(backup_btn)

        layout.addWidget(backup_section)

        layout.addStretch()
        
        # 버튼
        btn_layout = QHBoxLayout()
        
        cancel_btn = QPushButton("취소")
        cancel_btn.setMinimumHeight(40)
        cancel_btn.clicked.connect(dialog.reject)
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                font-weight: 700;
                border-radius: 12px;
                padding: 10px 25px;
            }
            QPushButton:hover {
                background-color: #D0D0D0;
            }
        """)
        
        apply_btn = QPushButton("적용")
        apply_btn.setMinimumHeight(40)
        apply_btn.clicked.connect(lambda: self.apply_monitor_setting(dialog))
        apply_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                font-weight: 700;
                border-radius: 12px;
                padding: 10px 25px;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
        """)
        
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(apply_btn)
        layout.addLayout(btn_layout)
        
        dialog.exec_()
    
    def apply_monitor_setting(self, dialog):
        """환경설정 적용"""
        # 모니터 설정 적용
        selected_idx = self.monitor_combo.currentData()
        if selected_idx is None:
            selected_idx = 0  # 기본값: 첫 번째 모니터
        self._selected_monitor = selected_idx
        
        # 시작 프로그램 설정 적용
        if hasattr(dialog, 'startup_toggle'):
            startup_enabled = dialog.startup_toggle.isChecked()
            self.set_startup_enabled(startup_enabled)

        # 자동 백업 설정 적용
        if hasattr(dialog, 'auto_backup_toggle'):
            self.auto_backup_enabled = dialog.auto_backup_toggle.isChecked()
            # 타이머 제어
            if self.auto_backup_enabled:
                if not self.auto_backup_timer.isActive():
                    self.auto_backup_timer.start(60 * 60 * 1000)  # 1시간
            else:
                self.auto_backup_timer.stop()

        if hasattr(dialog, 'backup_count_combo'):
            self.max_backups = dialog.backup_count_combo.currentData()

        from PyQt5.QtWidgets import QApplication
        screens = QApplication.screens()
        
        if selected_idx == -1:
            # 모든 모니터 선택 - 전체 가상 화면 사용
            print(f"[모니터 설정] 모든 모니터 선택 (자유 이동)")
            
            # 전체 화면 영역 계산
            min_x = min(s.geometry().x() for s in screens)
            min_y = min(s.geometry().y() for s in screens)
            max_x = max(s.geometry().x() + s.geometry().width() for s in screens)
            max_y = max(s.geometry().y() + s.geometry().height() for s in screens)
            
            total_width = max_x - min_x
            total_height = max_y - min_y
            
            for char in self.characters:
                char.screen_x = min_x
                char.screen_y = min_y
                char.screen_width = total_width
                char.screen_height = total_height
                char.use_all_monitors = True  # 전체 모니터 모드 플래그
                
                # 각 캐릭터가 있는 모니터의 ground_level 사용
                char_center_x = char.x() + char.width() // 2
                for screen in screens:
                    geo = screen.availableGeometry()
                    if geo.x() <= char_center_x <= geo.x() + geo.width():
                        foot_offset = getattr(char, 'foot_offset', 0)
                        max_foot_offset = char.pixmap.height() // 2
                        foot_offset = min(foot_offset, max_foot_offset)
                        char.ground_level = geo.y() + geo.height() - char.height()
                        break
                
                char.on_ground = True
                char.velocity_y = 0
                
                # 활성화된 캐릭터만 표시
                is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
                if is_active:
                    char.raise_()
                    char.activateWindow()
                    char.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
                    char.show()
        
        elif selected_idx < len(screens):
            screen = screens[selected_idx]
            geo = screen.availableGeometry()
            
            print(f"[모니터 설정] 모니터 {selected_idx} 선택: {geo.x()}, {geo.y()}, {geo.width()}x{geo.height()}")
            
            for char in self.characters:
                # 캐릭터의 화면 정보 전체 업데이트
                char.screen_geometry = geo
                char.screen_width = geo.width()
                char.screen_height = geo.height()
                char.screen_x = geo.x()  # 모니터 시작 X 좌표
                char.screen_y = geo.y()  # 모니터 시작 Y 좌표
                char.use_all_monitors = False  # 단일 모니터 모드
                
                # foot_offset 제한 및 ground_level 재계산
                foot_offset = getattr(char, 'foot_offset', 0)
                max_foot_offset = char.pixmap.height() // 2
                foot_offset = min(foot_offset, max_foot_offset)
                char.ground_level = geo.y() + geo.height() - char.height()
                
                # ground_level이 화면 안에 있도록 보장
                max_y = geo.y() + geo.height() - char.height()
                char.ground_level = min(char.ground_level, max_y)
                
                # 현재 위치가 선택한 모니터 밖이면 이동
                char_pos = char.pos()
                char_in_monitor = (geo.x() <= char_pos.x() <= geo.x() + geo.width() - char.width() and
                                   geo.y() <= char_pos.y() <= geo.y() + geo.height() - char.height())
                
                if not char_in_monitor:
                    # 모니터 중앙 근처 랜덤 위치로 이동
                    import random
                    new_x = geo.x() + random.randint(100, max(150, geo.width() - 200))
                    new_y = char.ground_level
                    char.move(new_x, new_y)
                    print(f"[모니터 설정] 캐릭터 {char.char_id} 이동: ({new_x}, {new_y})")
                
                # 바닥에 착지
                char.on_ground = True
                char.velocity_y = 0
                
                # 활성화된 캐릭터만 표시
                is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
                if is_active:
                    # 캐릭터를 최상위로 다시 올리기
                    char.raise_()
                    char.activateWindow()
                    char.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.FramelessWindowHint | Qt.Tool)
                    char.show()

        dialog.accept()

    def restart_app(self):
        """앱 재시작"""
        import subprocess
        try:
            if getattr(sys, 'frozen', False):
                exe_path = sys.executable
                # start 명령어로 새 프로세스 시작
                os.system(f'start "" "{exe_path}"')
            else:
                script_path = os.path.abspath(__file__)
                subprocess.Popen([sys.executable, script_path])
            QApplication.quit()
        except Exception as e:
            print(f"[재시작 오류] {e}")

    def is_startup_enabled(self):
        """시작 프로그램 등록 여부 확인"""
        try:
            import winreg
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0,
                winreg.KEY_READ
            )
            try:
                winreg.QueryValueEx(key, "Kiwipet")
                winreg.CloseKey(key)
                return True
            except FileNotFoundError:
                winreg.CloseKey(key)
                return False
            except Exception:
                winreg.CloseKey(key)
                return False
        except ImportError:
            # Windows가 아닌 환경
            print("[시작 프로그램] Windows가 아닌 환경입니다.")
            return False
        except Exception as e:
            print(f"[시작 프로그램] 확인 오류: {e}")
            return False
    
    def set_startup_enabled(self, enabled):
        """시작 프로그램 등록/해제"""
        try:
            import winreg
            import sys
            
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                r"Software\Microsoft\Windows\CurrentVersion\Run",
                0,
                winreg.KEY_SET_VALUE | winreg.KEY_READ
            )
            
            if enabled:
                # 현재 실행 중인 exe 경로
                if getattr(sys, 'frozen', False):
                    # PyInstaller로 빌드된 exe
                    exe_path = sys.executable
                else:
                    # 개발 모드 (python 스크립트)
                    exe_path = f'"{sys.executable}" "{os.path.abspath(__file__)}"'
                
                winreg.SetValueEx(key, "Kiwipet", 0, winreg.REG_SZ, exe_path)
                print(f"[시작 프로그램] 등록 완료: {exe_path}")
            else:
                try:
                    winreg.DeleteValue(key, "Kiwipet")
                    print("[시작 프로그램] 해제 완료")
                except FileNotFoundError:
                    pass  # 이미 없음
            
            winreg.CloseKey(key)
        except Exception as e:
            print(f"[시작 프로그램] 설정 오류: {e}")
            QMessageBox.warning(self, "오류", f"시작 프로그램 설정 중 오류가 발생했습니다.\n{str(e)}")
    
    def _export_all_characters(self):
        """모든 캐릭터 전체 백업 (폴더 + 이미지 + JSON 방식)"""
        import shutil
        import re
        import datetime
        
        if not self.character_data:
            QMessageBox.information(self, "백업", "백업할 캐릭터가 없습니다.")
            return
        
        # 저장 위치 선택
        folder = QFileDialog.getExistingDirectory(self, "백업 저장 위치 선택")
        if not folder:
            return
        
        try:
            # 날짜_백업 폴더 생성
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_folder = os.path.join(folder, f"{timestamp}_백업")
            os.makedirs(backup_folder, exist_ok=True)
            
            # 각 캐릭터 데이터 저장
            for char_id, char_data in self.character_data.items():
                char_name = char_data.get('name', f'캐릭터_{char_id}')

                # 파일명용 안전한 이름 (char_id 포함으로 중복 방지)
                safe_name = re.sub(r'[<>:"/\\|?*]', '', char_name).strip()
                if not safe_name:
                    safe_name = f'캐릭터_{char_id}'
                unique_name = f"{char_id}_{safe_name}"

                # 이미지 복사
                image_file = f"{unique_name}_image.png"
                image_path = char_data.get('image_path', '')
                if image_path and os.path.exists(image_path):
                    ext = os.path.splitext(image_path)[1] or '.png'
                    image_file = f"{unique_name}_image{ext}"
                    shutil.copy2(image_path, os.path.join(backup_folder, image_file))
                
                # AI 캐시 가져오기
                ai_cache = {}
                if char_id in _ai_dialogues_cache:
                    cache = _ai_dialogues_cache[char_id]
                    ai_cache = {
                        'solo': cache.get('solo', []),
                        'interaction': cache.get('interaction', {}),
                        'fallback': cache.get('fallback', []),
                        'reference': cache.get('reference', {})  # 참고용 수동 대사
                    }
                
                char_backup = {
                    'char_id': char_id,
                    'char_name': char_name,
                    'image_file': image_file,
                    'scale': char_data.get('scale', 100),
                    'bubble_color': char_data.get('bubble_color', '#A8D5BA'),
                    'bubble_size': char_data.get('bubble_size', 100),
                    'facing_direction': char_data.get('facing_direction', 'right'),
                    'is_active': char_data.get('is_active', True),
                    'personality': char_data.get('personality', ''),
                    'background_story': char_data.get('background_story', ''),
                    'nicknames': char_data.get('nicknames', {}),
                    'stories': char_data.get('stories', {}),
                    'sample_dialogues': char_data.get('sample_dialogues', []),
                    'catchphrase': char_data.get('catchphrase', ''),
                    'ai_cache': ai_cache,
                    'dialogues': self.dialogues.get(char_id, {'기본': []})
                }
                
                # 캐릭터별 JSON 저장 (char_id 포함 파일명)
                json_path = os.path.join(backup_folder, f"{unique_name}.json")
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(char_backup, f, ensure_ascii=False, indent=2)
            
            # 관계 정보 및 설정 저장 (_backup_info.json)
            # 캐릭터 순서 저장 (char_id 순서대로)
            character_order = []
            for char_id, char_data in self.character_data.items():
                char_name = char_data.get('name', f'캐릭터_{char_id}')
                safe_name = re.sub(r'[<>:"/\\|?*]', '', char_name).strip()
                if not safe_name:
                    safe_name = f'캐릭터_{char_id}'
                unique_name = f"{char_id}_{safe_name}"
                character_order.append({
                    'char_id': char_id,
                    'char_name': char_name,
                    'json_file': f"{unique_name}.json"
                })
            
            backup_info = {
                'version': '3.0',
                'backup_type': 'all_characters',
                'character_order': character_order,  # 순서 정보 추가
                'relationships': {},
                'ai_enabled': self.ai_enabled,
                'gemini_api_key': self.gemini_api_key,
            }
            
            for key, value in self.relationships.items():
                if isinstance(key, tuple) and len(key) == 2:
                    # 현재 존재하는 캐릭터들의 관계만 백업
                    if key[0] in self.character_data and key[1] in self.character_data:
                        key_str = f"{key[0]},{key[1]}"
                        backup_info['relationships'][key_str] = value
            
            info_path = os.path.join(backup_folder, "_backup_info.json")
            with open(info_path, 'w', encoding='utf-8') as f:
                json.dump(backup_info, f, ensure_ascii=False, indent=2)
            
            # 관계 수 계산
            rel_count = len(backup_info['relationships'])
            
            QMessageBox.information(self, "백업 완료", 
                f"백업이 완료되었습니다!\n\n"
                f"📁 저장 위치:\n{backup_folder}")
            
        except Exception as e:
            import traceback
            print(f"[전체 백업 오류] {e}")
            print(traceback.format_exc())
            QMessageBox.critical(self, "백업 실패", f"백업 중 오류가 발생했습니다.\n\n{str(e)}")
    
    def _import_all_characters(self):
        """모든 캐릭터 전체 불러오기 (폴더 선택 → 자동 찾기)"""
        import shutil
        
        # 안내 팝업
        QMessageBox.information(self, "전체 캐릭터 불러오기", "백업 폴더를 선택해주세요.")
        
        # 폴더 선택
        folder_path = QFileDialog.getExistingDirectory(
            self,
            "전체 백업 폴더 선택"
        )
        
        if not folder_path:
            return
        
        try:
            # _backup_info.json 확인 (전체 백업 폴더인지 확인)
            info_path = os.path.join(folder_path, "_backup_info.json")
            backup_info = {}
            
            if os.path.exists(info_path):
                with open(info_path, 'r', encoding='utf-8') as f:
                    backup_info = json.load(f)
            
            # 폴더 내 모든 캐릭터 JSON 파일 찾기 (_backup_info.json 제외)
            json_files = [f for f in os.listdir(folder_path) 
                         if f.endswith('.json') and not f.startswith('_')]
            
            if not json_files:
                QMessageBox.warning(self, "불러오기 실패", "선택한 폴더에 캐릭터 데이터가 없습니다.")
                return
            
            # 순서 정보가 있으면 해당 순서대로 정렬
            character_order = backup_info.get('character_order', [])
            if character_order:
                # character_order에 있는 순서대로 정렬
                order_map = {item['json_file']: idx for idx, item in enumerate(character_order)}
                json_files.sort(key=lambda f: order_map.get(f, 999))
                print(f"[불러오기] 순서 정보 사용: {[item['char_name'] for item in character_order]}")
            
            # 확인 팝업
            current_count = len(self.character_data)
            reply = QMessageBox.question(
                self,
                "전체 캐릭터 불러오기",
                f"{len(json_files)}개 캐릭터를 추가합니다.\n\n현재 {current_count}개 캐릭터는 유지됩니다.\n\n계속하시겠습니까?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # temp_images 폴더 준비
            temp_dir = os.path.join(self.app_dir, 'temp_images')
            os.makedirs(temp_dir, exist_ok=True)
            
            # 백업 파일의 old_id -> new_id 매핑
            id_mapping = {}
            
            # 각 캐릭터 추가
            loaded_count = 0
            global _ai_dialogues_cache  # 전역 AI 캐시 사용
            
            for json_file in json_files:
                try:
                    json_path = os.path.join(folder_path, json_file)
                    with open(json_path, 'r', encoding='utf-8') as f:
                        char_backup = json.load(f)
                    
                    old_char_id = char_backup.get('char_id', loaded_count)
                    char_name = char_backup.get('char_name', '캐릭터')
                    
                    # 새 char_id 할당
                    new_char_id = self.char_id_counter
                    self.char_id_counter += 1
                    
                    # ID 매핑 저장
                    id_mapping[old_char_id] = new_char_id
                    
                    # 이미지 파일 찾기
                    image_file = char_backup.get('image_file', '')
                    image_path = ""
                    
                    if image_file:
                        possible_path = os.path.join(folder_path, image_file)
                        if os.path.exists(possible_path):
                            image_path = possible_path
                    
                    # 이미지 못 찾으면 파일명 기반으로 검색
                    if not image_path:
                        base_name = os.path.splitext(json_file)[0]
                        for ext in ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.PNG', '.JPG']:
                            test_path = os.path.join(folder_path, f"{base_name}_image{ext}")
                            if os.path.exists(test_path):
                                image_path = test_path
                                break
                    
                    # 그래도 없으면 placeholder 사용
                    if not image_path or not os.path.exists(image_path):
                        from PyQt5.QtSvg import QSvgRenderer
                        from PyQt5.QtGui import QImage, QPainter
                        from PyQt5.QtCore import Qt
                        import uuid
                        
                        unique_filename = f"placeholder_{uuid.uuid4().hex[:8]}.png"
                        image_path = os.path.join(temp_dir, unique_filename)
                        
                        renderer = QSvgRenderer(PLACEHOLDER_SVG.encode('utf-8'))
                        if renderer.isValid():
                            img = QImage(200, 200, QImage.Format_ARGB32)
                            img.fill(Qt.transparent)
                            painter = QPainter(img)
                            renderer.render(painter)
                            painter.end()
                            img.save(image_path, 'PNG')
                    else:
                        # 이미지를 temp_images에 복사
                        import uuid
                        ext = os.path.splitext(image_path)[1]
                        unique_filename = f"img_{uuid.uuid4().hex[:8]}{ext}"
                        copied_path = os.path.join(temp_dir, unique_filename)
                        shutil.copy2(image_path, copied_path)
                        image_path = copied_path
                    
                    # 캐릭터 설정
                    direction = char_backup.get('facing_direction', 'right')
                    scale = char_backup.get('scale', 100)
                    bubble_color = char_backup.get('bubble_color', '#A8D5BA')
                    bubble_size = char_backup.get('bubble_size', 100)
                    is_active = char_backup.get('is_active', True)
                    catchphrase = char_backup.get('catchphrase', '')
                    
                    # 캐릭터 위젯 생성
                    char_widget = CharacterWidget(image_path, new_char_id, direction, scale, bubble_color, bubble_size)
                    if not is_active:
                        char_widget.hide()
                    self.characters.append(char_widget)
                    
                    # 캐릭터 데이터 저장 (nicknames/stories는 나중에 매핑)
                    self.character_data[new_char_id] = {
                        'name': char_name,
                        'scale': scale,
                        'bubble_color': bubble_color,
                        'bubble_size': bubble_size,
                        'facing_direction': direction,
                        'image_path': image_path,
                        'is_active': is_active,
                        'catchphrase': catchphrase,
                        'personality': char_backup.get('personality', ''),
                        'background_story': char_backup.get('background_story', ''),
                        'nicknames': {},  # 나중에 이름->ID 매핑 후 설정
                        'stories': {},  # 나중에 이름->ID 매핑 후 설정
                        'sample_dialogues': char_backup.get('sample_dialogues', [])
                    }
                    
                    # 대사 데이터 (키 형식 통일) - 나중에 id_mapping으로 변환
                    dialogues_data = char_backup.get('dialogues', {'기본': []})
                    if isinstance(dialogues_data, dict):
                        # 일단 키 형식만 통일 (old_id 그대로 유지, 나중에 변환)
                        converted = {}
                        for key, values in dialogues_data.items():
                            if key == '기본':
                                converted['기본'] = values
                            elif isinstance(key, int):
                                # 일단 old_id 그대로 저장 (나중에 변환)
                                converted[f'char_{key}'] = values
                            elif isinstance(key, str) and key.isdigit():
                                converted[f'char_{key}'] = values
                            else:
                                converted[key] = values
                        self.dialogues[new_char_id] = converted
                        # pending으로 old_id 기반 키 저장 (나중에 변환용)
                        char_widget._pending_dialogues_keys = True
                    else:
                        self.dialogues[new_char_id] = {'기본': dialogues_data}
                    
                    # 캐릭터 위젯에 데이터 전달
                    char_widget.dialogues = self.dialogues.get(new_char_id, {'기본': []})
                    char_widget.personality = char_backup.get('personality', '')
                    char_widget.background_story = char_backup.get('background_story', '')
                    char_widget.char_name = char_name
                    char_widget.catchphrase = catchphrase
                    
                    # nicknames와 stories는 나중에 모든 캐릭터 로드 후 매핑
                    # 일단 이름 기반으로 저장해둠
                    char_widget._pending_nicknames = char_backup.get('nicknames', {})
                    char_widget._pending_stories = char_backup.get('stories', {})
                    char_widget.nicknames = {}
                    char_widget.stories = {}
                    char_widget.sample_dialogues = char_backup.get('sample_dialogues', [])
                    
                    # AI 캐시 복원 (새 ID로, interaction 키를 int로 변환)
                    if char_backup.get('ai_cache'):
                        raw_interaction = char_backup['ai_cache'].get('interaction', {})
                        converted_interaction = {}
                        for k, v in raw_interaction.items():
                            try:
                                converted_interaction[int(k)] = v
                            except (ValueError, TypeError):
                                converted_interaction[k] = v

                        _ai_dialogues_cache[new_char_id] = {
                            'solo': char_backup['ai_cache'].get('solo', []),
                            'interaction': converted_interaction,
                            'fallback': char_backup['ai_cache'].get('fallback', []),
                            'reference': char_backup['ai_cache'].get('reference', {}),  # 참고용 수동 대사
                            'generated_at': time.time()
                        }
                    
                    # 수동 대사를 AI 캐시에 동기화
                    sync_dialogues_to_ai_cache(new_char_id, self.dialogues[new_char_id])
                    
                    # 카드 생성
                    card = CharacterCard(new_char_id, image_path, char_name, is_active=is_active, catchphrase=catchphrase)
                    card.remove_clicked.connect(self.remove_character)
                    card.change_image_clicked.connect(self.change_character_image)
                    card.change_scale_clicked.connect(self.change_character_scale)
                    card.change_bubble_color_clicked.connect(self.change_bubble_color)
                    card.change_relationships_clicked.connect(self.change_relationships)
                    card.change_dialogues_clicked.connect(self.change_dialogues)
                    card.change_personality_clicked.connect(self.change_personality)
                    card.name_changed.connect(self.update_character_name)
                    card.catchphrase_changed.connect(self.update_character_catchphrase)
                    card.toggle_active.connect(self.toggle_character_active)
                    card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
                    card.update_scale_display(scale)
                    
                    self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
                    
                    loaded_count += 1
                    
                except Exception as e:
                    print(f"[불러오기] 캐릭터 복원 실패: {e}")
                    continue
            
            # 관계 정보 복원 (새 ID로 매핑, 레거시 형식 마이그레이션 포함)
            relationships_data = backup_info.get('relationships', {})
            for key_str, value in relationships_data.items():
                try:
                    if ',' not in str(key_str):
                        continue
                    old_ids = list(map(int, str(key_str).split(',')))
                    # 새 ID로 매핑
                    if old_ids[0] not in id_mapping or old_ids[1] not in id_mapping:
                        continue
                    new_ids = tuple(sorted([id_mapping[old_ids[0]], id_mapping[old_ids[1]]]))

                    # value 정규화: {char_id: "감정", other_id: "감정"} 형식으로 통일
                    if isinstance(value, dict):
                        new_value = {}
                        for k, v in value.items():
                            try:
                                old_k = int(k)
                            except (ValueError, TypeError):
                                continue
                            if old_k not in id_mapping:
                                continue
                            new_k = id_mapping[old_k]
                            # 값이 문자열이면 그대로, 중첩 dict면 my_feeling 추출
                            if isinstance(v, str):
                                new_value[new_k] = v
                            elif isinstance(v, dict) and 'my_feeling' in v:
                                new_value[new_k] = v.get('my_feeling', '무관심')
                            else:
                                new_value[new_k] = "무관심"
                        if new_value:
                            self.relationships[new_ids] = new_value
                    elif isinstance(value, str):
                        # 레거시 단순 문자열 형식 -> 현재 형식으로 변환
                        self.relationships[new_ids] = {
                            new_ids[0]: value,
                            new_ids[1]: "무관심"
                        }
                    print(f"[불러오기] 관계 복원: {new_ids} -> {self.relationships.get(new_ids, {})}")
                except Exception as e:
                    print(f"[불러오기] 관계 복원 실패: {e}")
                    continue
            
            # 호칭/서사 매핑 (이름 -> ID)
            # 현재 앱의 모든 캐릭터 이름->ID 매핑 생성
            name_to_id = {}
            for cid, cdata in self.character_data.items():
                cname = cdata.get('name', '')
                if cname:
                    name_to_id[cname] = cid
            
            # 각 캐릭터의 pending nicknames/stories를 ID로 변환
            for char in self.characters:
                if hasattr(char, '_pending_nicknames') and char._pending_nicknames:
                    new_nicknames = {}
                    for other_name, nickname in char._pending_nicknames.items():
                        # 이름이 숫자(ID)인 경우 (구버전 백업)
                        try:
                            old_id = int(other_name)
                            if old_id in id_mapping:
                                new_nicknames[id_mapping[old_id]] = nickname
                            continue
                        except ValueError:
                            pass
                        # 이름으로 ID 찾기
                        if other_name in name_to_id:
                            new_nicknames[name_to_id[other_name]] = nickname
                    char.nicknames = new_nicknames
                    self.character_data[char.char_id]['nicknames'] = new_nicknames
                    delattr(char, '_pending_nicknames')
                
                if hasattr(char, '_pending_stories') and char._pending_stories:
                    new_stories = {}
                    for other_name, story in char._pending_stories.items():
                        # 이름이 숫자(ID)인 경우 (구버전 백업)
                        try:
                            old_id = int(other_name)
                            if old_id in id_mapping:
                                new_stories[id_mapping[old_id]] = story
                            continue
                        except ValueError:
                            pass
                        # 이름으로 ID 찾기
                        if other_name in name_to_id:
                            new_stories[name_to_id[other_name]] = story
                    char.stories = new_stories
                    self.character_data[char.char_id]['stories'] = new_stories
                    delattr(char, '_pending_stories')
            
            # AI 캐시의 interaction 키를 old_id → new_id로 변환
            for char_id in list(_ai_dialogues_cache.keys()):
                if char_id in _ai_dialogues_cache:
                    cache = _ai_dialogues_cache[char_id]
                    if 'interaction' in cache and isinstance(cache['interaction'], dict):
                        new_interaction = {}
                        for old_key, dialogues in cache['interaction'].items():
                            if old_key == 'default':
                                new_interaction['default'] = dialogues
                            elif isinstance(old_key, int) and old_key in id_mapping:
                                new_interaction[id_mapping[old_key]] = dialogues
                            elif isinstance(old_key, str):
                                try:
                                    old_key_int = int(old_key)
                                    if old_key_int in id_mapping:
                                        new_interaction[id_mapping[old_key_int]] = dialogues
                                    else:
                                        new_interaction[old_key_int] = dialogues
                                except ValueError:
                                    new_interaction[old_key] = dialogues
                            else:
                                new_interaction[old_key] = dialogues
                        cache['interaction'] = new_interaction
                        print(f"[불러오기] AI 캐시 interaction 키 변환: char_id={char_id}, keys={list(new_interaction.keys())}")
            
            # 대사(dialogues)의 'char_X' 키를 old_id → new_id로 변환
            for char in self.characters:
                if hasattr(char, '_pending_dialogues_keys') and char._pending_dialogues_keys:
                    char_id = char.char_id
                    if char_id in self.dialogues:
                        old_dialogues = self.dialogues[char_id]
                        new_dialogues = {}
                        for key, values in old_dialogues.items():
                            if key == '기본':
                                new_dialogues['기본'] = values
                            elif key.startswith('char_'):
                                try:
                                    old_id = int(key.replace('char_', ''))
                                    if old_id in id_mapping:
                                        new_dialogues[f'char_{id_mapping[old_id]}'] = values
                                    else:
                                        new_dialogues[key] = values
                                except ValueError:
                                    new_dialogues[key] = values
                            else:
                                new_dialogues[key] = values
                        self.dialogues[char_id] = new_dialogues
                        char.dialogues = new_dialogues
                        print(f"[불러오기] 대사 키 변환: char_id={char_id}, keys={list(new_dialogues.keys())}")
                    delattr(char, '_pending_dialogues_keys')
            
            # API 설정 복원
            if backup_info.get('gemini_api_key'):
                self.gemini_api_key = backup_info['gemini_api_key']
            if 'ai_enabled' in backup_info:
                self.ai_enabled = backup_info['ai_enabled']

            # 캐릭터 위젯에 감정 정보 전달
            self.update_character_relationships()

            self.save_characters()
            
            # 관계 수 계산
            rel_count = len(relationships_data)
            
            QMessageBox.information(self, "불러오기 완료", 
                f"{loaded_count}개 캐릭터를 불러왔습니다.")
            
        except Exception as e:
            import traceback
            print(f"[전체 불러오기 오류] {e}")
            print(traceback.format_exc())
            QMessageBox.critical(self, "불러오기 실패", f"불러오기 중 오류가 발생했습니다.\n\n{str(e)}")

    def _apply_monitor_to_characters(self, monitor_idx):
        """저장된 모니터 설정을 모든 캐릭터에 적용 (로드 시 사용)"""
        from PyQt5.QtWidgets import QApplication
        screens = QApplication.screens()
        
        if monitor_idx == -1:
            # 모든 모니터 선택 - 전체 가상 화면 사용
            print(f"[모니터 로드] 모든 모니터 (자유 이동)")
            
            min_x = min(s.geometry().x() for s in screens)
            min_y = min(s.geometry().y() for s in screens)
            max_x = max(s.geometry().x() + s.geometry().width() for s in screens)
            max_y = max(s.geometry().y() + s.geometry().height() for s in screens)
            
            total_width = max_x - min_x
            total_height = max_y - min_y
            
            for char in self.characters:
                char.screen_x = min_x
                char.screen_y = min_y
                char.screen_width = total_width
                char.screen_height = total_height
                char.use_all_monitors = True  # 전체 모니터 모드 플래그
                
                # 현재 캐릭터 위치 기준으로 해당 모니터의 ground_level 사용
                char_center_x = char.x() + char.width() // 2
                target_geo = screens[0].availableGeometry()  # 기본값
                for screen in screens:
                    geo = screen.availableGeometry()
                    if geo.x() <= char_center_x <= geo.x() + geo.width():
                        target_geo = geo
                        break
                
                foot_offset = getattr(char, 'foot_offset', 0)
                max_foot_offset = char.pixmap.height() // 2
                foot_offset = min(foot_offset, max_foot_offset)
                char.ground_level = target_geo.y() + target_geo.height() - char.height()
                
                # 활성화된 캐릭터만 이동
                is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
                if is_active:
                    import random
                    new_x = target_geo.x() + random.randint(50, max(100, target_geo.width() - 150))
                    new_y = char.ground_level
                    char.move(new_x, new_y)
                    char.on_ground = True
                    char.velocity_y = 0
                    char.on_window = False
            return
        
        # 저장된 모니터가 더 이상 없으면 기본 모니터(0) 사용
        if monitor_idx >= len(screens):
            monitor_idx = 0
            self._selected_monitor = 0
            print(f"[모니터 로드] 저장된 모니터 없음, 기본 모니터 사용")
        
        screen = screens[monitor_idx]
        geo = screen.availableGeometry()
        
        print(f"[모니터 로드] 모니터 {monitor_idx} 적용: {geo.x()}, {geo.y()}, {geo.width()}x{geo.height()}")
        
        for char in self.characters:
            # 캐릭터의 화면 정보 전체 업데이트
            char.screen_geometry = geo
            char.screen_width = geo.width()
            char.screen_height = geo.height()
            char.screen_x = geo.x()
            char.screen_y = geo.y()
            char.use_all_monitors = False  # 단일 모니터 모드
            
            # foot_offset 제한 (캐릭터 높이의 절반 이하로)
            foot_offset = getattr(char, 'foot_offset', 0)
            max_foot_offset = char.pixmap.height() // 2  # 최대 1/3까지만
            foot_offset = min(foot_offset, max_foot_offset)
            
            # ground_level 재계산
            char.ground_level = geo.y() + geo.height() - char.height()
            
            # ground_level이 화면 안에 있도록 보장
            min_y = geo.y()
            max_y = geo.y() + geo.height() - char.height()
            char.ground_level = max(min_y, min(char.ground_level, max_y))
            
            # 활성화된 캐릭터만 이동 (비활성화된 캐릭터는 숨겨져 있음)
            is_active = self.character_data.get(char.char_id, {}).get('is_active', True)
            if is_active:
                # 캐릭터를 모니터 안의 랜덤 위치로 이동
                import random
                new_x = geo.x() + random.randint(50, max(100, geo.width() - 150))
                new_y = char.ground_level
                char.move(new_x, new_y)
                
                # 바닥에 착지
                char.on_ground = True
                char.velocity_y = 0
                char.on_window = False
                
                print(f"[모니터 로드] 캐릭터 {char.char_id} 배치: ({new_x}, {new_y}), ground_level={char.ground_level}") 
    
    def show_api_settings(self):
        """API 키 설정 다이얼로그"""
        dialog = QDialog(self)
        dialog.setWindowTitle("AI API 설정")
        dialog.setMinimumSize(480, 700)
        dialog.setMaximumWidth(600)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLineEdit {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                padding: 14px;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                font-size: 14px;
            }
            QLineEdit:focus {
                border: 2px solid #8ECFB5;
            }
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 12px;
                font-weight: 700;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                font-size: 13px;
                min-height: 36px;
                min-width: 80px;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)

        layout = QVBoxLayout()
        layout.setSpacing(15)
        layout.setContentsMargins(35, 35, 35, 35)
        
        # 타이틀
        title = QLabel("🔑 Gemini API 키 설정")
        title.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 24px; font-weight: 700; font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        layout.addSpacing(10)
        
        # 설명
        info = QLabel("캐릭터의 성격을 설정하면 AI가 자동으로 대사를 생성합니다.\n"
                     "Google AI Studio에서 무료 API 키를 발급받을 수 있습니다.")
        info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #666; padding: 5px 0;")
        info.setWordWrap(True)
        info.setMinimumHeight(50)
        layout.addWidget(info)

        # 링크
        link_label = QLabel('<a href="https://aistudio.google.com/apikey">Google AI Studio에서 API 키 발급받기</a>')
        link_label.setOpenExternalLinks(True)
        link_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700;")
        layout.addWidget(link_label)

        # 대기/한도 초과 안내 (주황색, 붙여서)
        wait_info = QLabel("API 키를 새로 발급받았다면 10분 정도 기다려 주세요.\n"
                          "새로운 키가 아닌데 요청 한도가 초과되었다면 1~2시간(최대 하루) 기다려 주세요.")
        wait_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #e67e22; line-height: 1.4;")
        layout.addWidget(wait_info)

        layout.addSpacing(15)

        # API 키 입력
        key_label = QLabel("API 키:")
        key_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        layout.addWidget(key_label)
        
        key_input = QLineEdit()
        key_input.setPlaceholderText("AIza... (Google AI Studio에서 발급)")
        key_input.setText(self.gemini_api_key)
        key_input.setEchoMode(QLineEdit.Password)
        key_input.setMinimumHeight(45)
        layout.addWidget(key_input)
        
        # 키 보기 체크박스
        show_key = QCheckBox("키 보기")
        show_key.toggled.connect(lambda checked: key_input.setEchoMode(
            QLineEdit.Normal if checked else QLineEdit.Password))
        show_key.setStyleSheet("color: #666; font-size: 13px; font-weight: 700;")
        layout.addWidget(show_key)

        layout.addSpacing(10)

        # 구분선
        separator_key = QFrame()
        separator_key.setFrameShape(QFrame.HLine)
        separator_key.setStyleSheet("background-color: #C5E8D8;")
        separator_key.setFixedHeight(1)
        layout.addWidget(separator_key)

        layout.addSpacing(10)

        # AI 활성화 토글
        ai_toggle_layout = QHBoxLayout()
        ai_toggle_label = QLabel("대사 생성:")
        ai_toggle_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        ai_toggle_layout.addWidget(ai_toggle_label)
        
        ai_toggle = ToggleSwitch(self.ai_enabled)
        ai_toggle_layout.addWidget(ai_toggle)
        ai_toggle_layout.addStretch()
        layout.addLayout(ai_toggle_layout)
        
        # AI 설명
        ai_info = QLabel("활성화하면 1시간마다 캐릭터별 대사를 생성합니다.\n"
                        "(성격이 설정된 캐릭터만 적용)")
        ai_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        ai_info.setWordWrap(True)
        layout.addWidget(ai_info)

        # 캐릭터 선택 버튼
        char_select_btn = QPushButton("캐릭터 선택")
        char_select_btn.setStyleSheet("""
            QPushButton {
                background-color: #D4E8DC;
                color: #5A9C85;
                border: 1px solid #9DD4BA;
                padding: 8px 16px;
                border-radius: 10px;
                font-size: 13px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #C5E0CE;
            }
        """)
        char_select_btn.clicked.connect(lambda: self.show_ai_character_select_dialog())
        layout.addWidget(char_select_btn)
        
        # 캐릭터 선택 설명
        char_select_info = QLabel("AI 대사를 자동 생성할 캐릭터를 선택합니다.\n대사가 적은 캐릭터가 우선 생성됩니다.")
        char_select_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        char_select_info.setWordWrap(True)
        layout.addWidget(char_select_info)
        
        layout.addSpacing(5)
        
        # 즉시 대사 생성 버튼
        generate_now_btn = QPushButton("즉시 대사 생성")
        generate_now_btn.setStyleSheet("""
            QPushButton {
                background-color: #5A9C85;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 12px;
                font-size: 14px;
                font-weight: 700;
            }
            QPushButton:hover {
                background-color: #4A8C75;
            }
            QPushButton:disabled {
                background-color: #ccc;
                color: #888;
            }
        """)
        generate_now_btn.clicked.connect(lambda: self.generate_dialogues_now(generate_now_btn))
        layout.addWidget(generate_now_btn)
        
        # 이미 생성 중이면 버튼 상태 동기화
        if getattr(self, '_is_generating_now', False):
            generate_now_btn.setEnabled(False)
            idx = getattr(self, '_generate_now_index', 0) + 1
            total = len(getattr(self, '_generate_now_queue', []))
            generate_now_btn.setText(f"생성 중... {idx}/{total}")
            # 버튼 참조 업데이트
            self._generate_now_btn = generate_now_btn
        
        # 즉시 대사 생성 설명
        generate_now_info = QLabel("버튼을 누르면 즉시 대사를 생성합니다.\n(캐릭터가 여러 명이면 1분 간격으로 순차 생성)")
        generate_now_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        layout.addWidget(generate_now_info)
        
        layout.addSpacing(10)

        # 구분선
        separator = QFrame()
        separator.setFrameShape(QFrame.HLine)
        separator.setStyleSheet("background-color: #C5E8D8;")
        separator.setFixedHeight(1)
        layout.addWidget(separator)

        layout.addSpacing(10)

        # 모델 선택
        model_label = QLabel("AI 모델:")
        model_label.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 15px; font-weight: 700;")
        layout.addWidget(model_label)

        from PyQt5.QtWidgets import QComboBox
        model_combo = QComboBox()
        model_combo.setStyleSheet("""
            QComboBox {
                background-color: white;
                border: 1px solid #C5E8D8;
                border-radius: 10px;
                padding: 8px 12px;
                font-family: 'Pretendard', sans-serif;
                font-size: 13px;
                font-weight: 700;
                min-height: 20px;
            }
            QComboBox:hover {
                border: 1px solid #8ECFB5;
            }
            QComboBox::drop-down {
                border: none;
                width: 30px;
            }
            QComboBox::down-arrow {
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 6px solid #5A9C85;
                margin-right: 10px;
            }
            QComboBox QAbstractItemView {
                background-color: white;
                border: 1px solid #C5E8D8;
                selection-background-color: #E8F5EE;
                selection-color: #5A9C85;
                font-weight: 700;
            }
        """)

        # 모델 목록 추가
        current_model_index = 0
        for i, (model_id, model_name) in enumerate(GEMINI_MODELS):
            model_combo.addItem(model_name, model_id)
            if model_id == self.gemini_model:
                current_model_index = i
        model_combo.setCurrentIndex(current_model_index)
        layout.addWidget(model_combo)

        # 모델 선택 안내
        model_info = QLabel("한도 초과가 반복되는 경우, 다른 모델로 바꿔서 대사 생성을 시도해주세요.\n"
                           "단, 전체 사용량을 모두 소비한 경우 모델을 바꿔도 생성되지 않을 수 있습니다.\n"
                           "저장 버튼을 누른 이후에 선택한 모델이 적용됩니다.")
        model_info.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 12px; font-weight: 700; color: #888;")
        model_info.setWordWrap(True)
        layout.addWidget(model_info)

        layout.addSpacing(10)

        # 테스트 결과 라벨
        test_result = QLabel("")
        test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #666;")
        test_result.setWordWrap(True)
        test_result.setMinimumHeight(25)
        layout.addWidget(test_result)
        
        layout.addStretch()
        
        # 버튼
        btn_layout = QHBoxLayout()
        btn_layout.setSpacing(12)
        
        # 테스트 버튼
        test_btn = QPushButton("테스트")
        test_btn.setStyleSheet("""
            QPushButton { background-color: #B5DEFF; color: white; }
            QPushButton:hover { background-color: #9ED0FF; }
        """)
        def test_api():
            test_key = key_input.text().strip()
            original_len = len(test_key)
            # clean_api_key 함수로 모든 비정상 문자 제거
            test_key = clean_api_key(test_key)
            cleaned_len = len(test_key)
            print(f"[API 테스트] 원본 길이: {original_len}, 정리 후 길이: {cleaned_len}")
            print(f"[API 테스트] 키 시작: {test_key[:15] if len(test_key) >= 15 else test_key}...")
            
            # 길이가 줄어들었으면 특수문자가 있었던 것
            if original_len != cleaned_len:
                print(f"[API 테스트] 특수문자 제거됨: {original_len - cleaned_len}자")
            
            if not test_key:
                test_result.setText("❌ API 키를 입력하세요.")
                test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
                return
            
            if not test_key.startswith("AIza"):
                test_result.setText("❌ API 키는 'AIza'로 시작해야 합니다.")
                test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
                return
            
            if len(test_key) != 39:
                test_result.setText(f"❌ API 키 길이 오류 ({len(test_key)}자, 39자 필요)")
                test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
                return
            
            test_result.setText("⏳ 테스트 중...")
            test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #666;")
            QApplication.processEvents()
            
            try:
                import urllib.request
                # URL 직접 구성 (선택된 모델 사용)
                selected_model = model_combo.currentData()
                url = f"https://generativelanguage.googleapis.com/v1beta/models/{selected_model}:generateContent?key={test_key}"
                print(f"[API 테스트] URL 생성 완료 (모델: {selected_model}), 길이: {len(url)}")
                data = {
                    "contents": [{"parts": [{"text": "Hi"}]}],
                    "generationConfig": {"maxOutputTokens": 10}
                }
                req = urllib.request.Request(
                    url,
                    data=json.dumps(data).encode('utf-8'),
                    headers={'Content-Type': 'application/json'},
                    method='POST'
                )
                with urllib.request.urlopen(req, timeout=15, context=_ssl_context) as response:
                    result = json.loads(response.read().decode('utf-8'))
                    if 'candidates' in result:
                        test_result.setText("✅ API 키가 정상 작동합니다!")
                        test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #5A9C85;")
                    else:
                        test_result.setText("❌ 응답 형식 오류")
                        test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
            except urllib.error.HTTPError as e:
                error_body = ""
                try:
                    error_body = e.read().decode('utf-8')
                except:
                    pass
                print(f"[API 테스트] HTTP {e.code}: {error_body[:500]}")
                
                if e.code == 400:
                    if "API_KEY_INVALID" in error_body:
                        test_result.setText("❌ API 키가 유효하지 않습니다.")
                    elif "INVALID_ARGUMENT" in error_body:
                        test_result.setText("❌ API 키 형식이 잘못되었습니다.")
                    else:
                        test_result.setText(f"❌ 요청 오류 (400)")
                elif e.code == 403:
                    test_result.setText("❌ API 키 권한이 없습니다.")
                elif e.code == 429:
                    test_result.setText("⚠️ 요청 한도 초과 (잠시 후 다시 시도)")
                elif e.code == 404:
                    # 모델이 없어도 키는 유효할 수 있음
                    test_result.setText("✅ API 키 인증 성공 (모델 확인 필요)")
                    test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #FF9800;")
                    return
                else:
                    test_result.setText(f"❌ 서버 오류: {e.code}")
                test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
            except urllib.error.URLError as e:
                print(f"[API 테스트] URLError: {e.reason}")
                test_result.setText(f"❌ 네트워크 오류 - 인터넷 연결을 확인하세요")
                test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
            except Exception as e:
                error_msg = str(e)
                error_type = type(e).__name__
                print(f"[API 테스트] {error_type}: {error_msg}")
                test_result.setText(f"❌ 오류: {error_type}")
                test_result.setStyleSheet("font-family: 'Pretendard', sans-serif; font-size: 14px; font-weight: 700; color: #E57373;")
        
        test_btn.clicked.connect(test_api)
        
        cancel_btn = QPushButton("취소")
        cancel_btn.setStyleSheet("""
            QPushButton { background-color: #E0E0E0; color: #666; }
            QPushButton:hover { background-color: #D0D0D0; }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        
        save_btn = QPushButton("저장")
        save_btn.clicked.connect(dialog.accept)
        
        btn_layout.addWidget(test_btn)
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)

        dialog.setLayout(layout)

        if dialog.exec_() == QDialog.Accepted:
            try:
                new_key = key_input.text().strip()
                # clean_api_key 함수로 모든 비정상 문자 제거
                new_key = clean_api_key(new_key)
                new_ai_enabled = ai_toggle.checked
                new_model = model_combo.currentData()

                # 상태 변경 확인
                key_changed = new_key != self.gemini_api_key
                enabled_changed = new_ai_enabled != self.ai_enabled
                model_changed = new_model != self.gemini_model

                self.gemini_api_key = new_key
                self.ai_enabled = new_ai_enabled
                self.gemini_model = new_model

                set_gemini_api_key(new_key)
                set_ai_enabled(new_ai_enabled)
                set_gemini_model(new_model)
                self.save_characters()
                
                # 버튼 스타일 업데이트
                self.update_api_button_style()
                
                # AI 활성화되고 키가 있으면 캐시 생성
                if new_ai_enabled and new_key:
                    if key_changed or enabled_changed:
                        # 캐시가 없으면 생성
                        if not _ai_dialogues_cache:
                            self.generate_ai_cache()
                            QMessageBox.information(self, "저장 완료", "API 설정이 저장되었습니다.\n대사 생성이 시작됩니다.")
                        else:
                            QMessageBox.information(self, "저장 완료", "API 설정이 저장되었습니다.")
                    else:
                        QMessageBox.information(self, "저장 완료", "API 설정이 저장되었습니다.")
                elif new_key and not new_ai_enabled:
                    QMessageBox.information(self, "저장 완료", "API 키가 저장되었습니다.\n대사 생성 기능이 비활성화되었습니다.")
                else:
                    QMessageBox.information(self, "저장 완료", "API 키가 제거되었습니다.")
            except Exception as e:
                import traceback
                print(f"[API 저장 오류] {e}")
                print(traceback.format_exc())
                QMessageBox.warning(self, "오류", f"저장 중 오류 발생:\n{str(e)}")
    
    def toggle_minimize(self):
        """최소화/복원 토글 (미사용 - 호환성 유지용)"""
        pass
    
    def show_ai_character_select_dialog(self):
        """AI 대사 자동생성 캐릭터 선택 다이얼로그"""
        from PyQt5.QtWidgets import QCheckBox, QScrollArea
        
        if not self.character_data:
            QMessageBox.information(self, "캐릭터 없음", "등록된 캐릭터가 없습니다.")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("AI 대사 생성 캐릭터 선택")
        dialog.setMinimumSize(350, 400)
        dialog.setMaximumWidth(450)
        dialog.setStyleSheet("""
            QDialog {
                background-color: #E8F5EE;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QLabel {
                color: #5A9C85;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
            }
            QCheckBox {
                font-size: 13px;
                color: #333;
                spacing: 8px;
                padding: 8px 4px;
            }
            QCheckBox::indicator {
                width: 18px;
                height: 18px;
            }
        """)
        
        layout = QVBoxLayout()
        layout.setSpacing(12)
        layout.setContentsMargins(25, 25, 25, 25)
        
        # 타이틀
        title = QLabel("AI 대사 자동생성 캐릭터")
        title.setStyleSheet("font-size: 18px; font-weight: 700; color: #317C75;")
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)
        
        # 설명
        info = QLabel("선택한 캐릭터만 AI 대사가 자동 생성됩니다.\n대사가 적은 캐릭터가 우선 생성됩니다.")
        info.setStyleSheet("font-size: 12px; color: #666; font-weight: 500;")
        info.setWordWrap(True)
        info.setAlignment(Qt.AlignCenter)
        layout.addWidget(info)
        
        layout.addSpacing(5)
        
        # 모두 선택/해제 버튼
        select_all_layout = QHBoxLayout()
        
        select_all_btn = QPushButton("모두 선택")
        select_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 600;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        
        deselect_all_btn = QPushButton("모두 해제")
        deselect_all_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                border: none;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 600;
            }
            QPushButton:hover { background-color: #D0D0D0; }
        """)
        
        select_all_layout.addWidget(select_all_btn)
        select_all_layout.addWidget(deselect_all_btn)
        select_all_layout.addStretch()
        layout.addLayout(select_all_layout)
        
        # 스크롤 영역
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("""
            QScrollArea {
                border: 1px solid #C5E8D8;
                border-radius: 10px;
                background-color: white;
            }
        """)
        
        scroll_widget = QWidget()
        scroll_widget.setStyleSheet("background-color: white;")
        scroll_layout = QVBoxLayout(scroll_widget)
        scroll_layout.setSpacing(2)
        scroll_layout.setContentsMargins(10, 10, 10, 10)
        
        checkboxes = {}
        
        # 캐릭터별 대사 수 계산 및 정렬
        char_dialogue_counts = []
        for char_id, char_data in self.character_data.items():
            char_name = char_data.get('name', f'캐릭터 {char_id + 1}')
            personality = char_data.get('personality', '')
            
            # 대사 수 계산
            cache = _ai_dialogues_cache.get(char_id, {})
            solo_count = len(cache.get('solo', []))
            interaction_count = sum(len(v) for v in cache.get('interaction', {}).values())
            total_count = solo_count + interaction_count
            
            # 현재 AI 자동생성 활성화 여부
            ai_auto = char_data.get('ai_auto_generate', True)  # 기본값 True
            
            char_dialogue_counts.append({
                'char_id': char_id,
                'name': char_name,
                'personality': personality,
                'total_count': total_count,
                'ai_auto': ai_auto
            })
        
        # 대사 수가 적은 순서로 정렬
        char_dialogue_counts.sort(key=lambda x: x['total_count'])
        
        for item in char_dialogue_counts:
            char_id = item['char_id']
            char_name = item['name']
            personality = item['personality']
            total_count = item['total_count']
            ai_auto = item['ai_auto']
            
            # 체크박스 생성
            cb = QCheckBox()
            cb.setChecked(ai_auto)
            
            # 성격 유무에 따른 표시
            if personality:
                label_text = f"{char_name} (대사 {total_count}개)"
                cb.setStyleSheet("QCheckBox { color: #333; }")
            else:
                label_text = f"{char_name} (성격 미설정)"
                cb.setStyleSheet("QCheckBox { color: #999; }")
            
            cb.setText(label_text)
            checkboxes[char_id] = cb
            scroll_layout.addWidget(cb)
        
        scroll_layout.addStretch()
        scroll.setWidget(scroll_widget)
        layout.addWidget(scroll)
        
        # 모두 선택/해제 기능
        def select_all():
            for cb in checkboxes.values():
                cb.setChecked(True)
        
        def deselect_all():
            for cb in checkboxes.values():
                cb.setChecked(False)
        
        select_all_btn.clicked.connect(select_all)
        deselect_all_btn.clicked.connect(deselect_all)
        
        # 버튼
        btn_layout = QHBoxLayout()
        
        cancel_btn = QPushButton("취소")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #E0E0E0;
                color: #666;
                border: none;
                padding: 10px 20px;
                border-radius: 10px;
                font-weight: 600;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #D0D0D0; }
        """)
        cancel_btn.clicked.connect(dialog.reject)
        
        save_btn = QPushButton("저장")
        save_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 10px;
                font-weight: 700;
                font-size: 13px;
            }
            QPushButton:hover { background-color: #7BC4A8; }
        """)
        save_btn.clicked.connect(dialog.accept)
        
        btn_layout.addWidget(cancel_btn)
        btn_layout.addWidget(save_btn)
        layout.addLayout(btn_layout)
        
        dialog.setLayout(layout)
        
        if dialog.exec_() == QDialog.Accepted:
            # 설정 저장
            for char_id, cb in checkboxes.items():
                if char_id in self.character_data:
                    self.character_data[char_id]['ai_auto_generate'] = cb.isChecked()
                
                # CharacterWidget에도 반영
                for char in self.characters:
                    if char.char_id == char_id:
                        char.ai_auto_generate = cb.isChecked()
                        break
            
            self.save_characters()
            
            # 활성화된 캐릭터 수 계산
            enabled_count = sum(1 for cb in checkboxes.values() if cb.isChecked())
            total_count = len(checkboxes)
            
            QMessageBox.information(self, "저장 완료", 
                f"설정이 저장되었습니다.\n\n{enabled_count}/{total_count}개 캐릭터가 AI 대사 자동생성 대상입니다.")
    
    def close_all(self):
        """모든 캐릭터와 프로그램 종료"""
        self.save_characters()
        for char in self.characters:
            char.close()
        self.close()
    
    def _set_svg_icon(self, button, svg_data, size):
        """SVG 데이터로 버튼 아이콘 설정 (비율 유지)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 원본 크기 가져오기
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 비율 유지하면서 size에 맞게 스케일
            if orig_w >= orig_h:
                scale = size / orig_w
                new_w = size
                new_h = int(orig_h * scale)
            else:
                scale = size / orig_h
                new_h = size
                new_w = int(orig_w * scale)
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
    
    def _set_button_icon(self, button, svg_data, size):
        """버튼에 SVG 아이콘 설정 (비율 유지, 텍스트 유지)"""
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        if renderer.isValid():
            # SVG 원본 크기 가져오기
            default_size = renderer.defaultSize()
            orig_w = default_size.width()
            orig_h = default_size.height()
            
            # 비율 유지하면서 size에 맞게 스케일
            if orig_w >= orig_h:
                scale = size / orig_w
                new_w = size
                new_h = int(orig_h * scale)
            else:
                scale = size / orig_h
                new_h = size
                new_w = int(orig_w * scale)
            
            pixmap = QPixmap(new_w, new_h)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            button.setIcon(QIcon(pixmap))
            button.setIconSize(QSize(new_w, new_h))
    
    def show_tutorial(self):
        """튜토리얼 다이얼로그 표시"""
        from PyQt5.QtWidgets import QMessageBox
        msg = QMessageBox(self)
        msg.setWindowTitle("Kiwipet 사용법")
        msg.setText(
            "<b>Kiwipet 사용 가이드</b><br><br>"
            "<b>1. 캐릭터 추가</b><br>"
            "• '캐릭터 추가하기' 버튼으로 이미지를 넣어주세요.<br>"
            "• 캐릭터가 바라보는 방향을 선택하세요.<br><br>"
            "<b>2. 성격 설정</b><br>"
            "• 이름을 설정합니다.<br>"
            "• '캐릭터 대사&amp;성격 설정'에 들어갑니다.<br>"
            "• 기본 대사와 성격을 입력합니다.<br><br>"
            "<b>3. 관계 설정</b><br>"
            "• '캐릭터 간 감정 설정'에서 다른 캐릭터에게 느끼는 감정을 지정합니다.<br>"
            "• 감정에 따라 상호작용이 달라집니다.<br><br>"
            "<b>4. API 활성화</b><br>"
            "• 가이드를 따라 API 키를 발급받아 주세요.<br>"
            "• 키를 입력한 후 활성화하고 잠시간 기다립니다.<br><br>"
            "<b>5. 백업</b><br>"
            "• '캐릭터 백업'으로 모든 캐릭터 데이터를 저장할 수 있습니다."
        )
        msg.setStyleSheet("""
            QMessageBox {
                background-color: #E8F5EE;
            }
            QLabel {
                color: #3D7A5F;
                font-size: 13px;
            }
        """)
        msg.exec_()
    
    def backup_all_characters(self):
        """캐릭터 일괄 백업 다이얼로그"""
        # 캐릭터가 없으면 불러오기 옵션 제공
        if not self.character_data:
            from PyQt5.QtWidgets import QMessageBox
            reply = QMessageBox.question(
                self,
                "캐릭터 백업",
                "백업할 캐릭터가 없습니다.\n\n전체 백업 파일에서 캐릭터를 불러오시겠습니까?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                self._import_all_characters()
            return
        
        from PyQt5.QtWidgets import QCheckBox
        from PyQt5.QtSvg import QSvgRenderer
        import subprocess
        
        # 백업 다이얼로그 생성
        dialog = QDialog(self)
        dialog.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        dialog.setFixedWidth(340)
        
        # 메인 컨테이너
        container = QWidget()
        container.setStyleSheet("""
            QWidget#backupContainer {
                background-color: #E8F5EE;
                border-radius: 20px;
                border: 1px solid #9DD4BA;
            }
        """)
        container.setObjectName("backupContainer")
        
        main_layout = QVBoxLayout(container)
        main_layout.setContentsMargins(20, 16, 20, 20)
        main_layout.setSpacing(12)
        
        # X 버튼 (오른쪽 상단)
        close_layout = QHBoxLayout()
        close_layout.addStretch()
        
        close_btn = QPushButton()
        close_btn.setFixedSize(24, 24)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(dialog.reject)
        
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        
        close_btn.setStyleSheet("QPushButton { background: transparent; border: none; }")
        close_layout.addWidget(close_btn)
        main_layout.addLayout(close_layout)
        
        # 타이틀
        title = QLabel("캐릭터 일괄 백업")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("""
            font-size: 18px;
            font-weight: 700;
            color: #317C75;
            background: transparent;
        """)
        main_layout.addWidget(title)
        
        # 설명 박스
        desc_box = QWidget()
        desc_box.setStyleSheet("""
            background-color: white;
            border-radius: 12px;
            border: 1px solid #9DD4BA;
        """)
        desc_layout = QVBoxLayout(desc_box)
        desc_layout.setContentsMargins(15, 12, 15, 12)
        
        desc_text = QLabel("백업할 캐릭터를 선택한 후,\n'캐릭터 백업하기' 버튼으로 내보내주세요.\n\n각 캐릭터가 (이름)_백업 폴더로\n저장됩니다. (이미지+JSON)")
        desc_text.setAlignment(Qt.AlignCenter)
        desc_text.setStyleSheet("""
            font-size: 12px;
            color: #5A9C85;
            background: transparent;
            border: none;
        """)
        desc_layout.addWidget(desc_text)
        main_layout.addWidget(desc_box)
        
        # 모두 선택 + 내보내기 경로 버튼
        top_btn_layout = QHBoxLayout()
        
        select_all_cb = QCheckBox("모두 선택")
        select_all_cb.setChecked(True)
        select_all_cb.setStyleSheet("""
            QCheckBox {
                font-size: 13px;
                color: #317C75;
                spacing: 6px;
                background: transparent;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
                border-radius: 4px;
                border: 2px solid #8ECFB5;
            }
            QCheckBox::indicator:checked {
                background-color: #8ECFB5;
                border: 2px solid #8ECFB5;
            }
        """)
        top_btn_layout.addWidget(select_all_cb)
        top_btn_layout.addStretch()
        
        export_path_btn = QPushButton("📁 내보내기 경로")
        export_path_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #317C75;
                border: 1px solid #9DD4BA;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        
        # 내보내기 경로 저장 변수 (설정 파일에서 읽기)
        last_backup = ''
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config_data = json.load(f)
                    last_backup = config_data.get('last_backup_folder', '')
            except:
                pass
        self._backup_export_path = last_backup
        
        def select_export_path():
            from PyQt5.QtWidgets import QFileDialog
            folder = QFileDialog.getExistingDirectory(dialog, "내보내기 경로 선택", self._backup_export_path or "")
            if folder:
                self._backup_export_path = folder
        
        export_path_btn.clicked.connect(select_export_path)
        top_btn_layout.addWidget(export_path_btn)
        main_layout.addLayout(top_btn_layout)
        
        # 캐릭터 체크박스 목록
        checkbox_container = QWidget()
        checkbox_container.setStyleSheet("""
            background-color: white;
            border-radius: 12px;
            border: 1px solid #9DD4BA;
        """)
        checkbox_layout = QVBoxLayout(checkbox_container)
        checkbox_layout.setContentsMargins(15, 12, 15, 12)
        checkbox_layout.setSpacing(8)
        
        checkboxes = {}
        for char_id, data in self.character_data.items():
            char_name = data.get('name', f'캐릭터 {char_id + 1}')
            cb = QCheckBox(char_name)
            cb.setChecked(True)
            cb.setStyleSheet("""
                QCheckBox {
                    font-size: 13px;
                    color: #317C75;
                    spacing: 8px;
                    border: none;
                    background: transparent;
                }
                QCheckBox::indicator {
                    width: 16px;
                    height: 16px;
                    border-radius: 4px;
                    border: 2px solid #C5E8D8;
                }
                QCheckBox::indicator:checked {
                    background-color: #8ECFB5;
                    border: 2px solid #8ECFB5;
                }
            """)
            checkboxes[char_id] = cb
            checkbox_layout.addWidget(cb)
        
        # 모두 선택 체크박스 연동
        def toggle_all(checked):
            for cb in checkboxes.values():
                cb.setChecked(checked)
        select_all_cb.toggled.connect(toggle_all)
        
        # 개별 체크박스 변경 시 모두 선택 상태 업데이트
        def update_select_all():
            all_checked = all(cb.isChecked() for cb in checkboxes.values())
            select_all_cb.blockSignals(True)
            select_all_cb.setChecked(all_checked)
            select_all_cb.blockSignals(False)
        
        for cb in checkboxes.values():
            cb.toggled.connect(update_select_all)
        
        main_layout.addWidget(checkbox_container)
        
        # 캐릭터 백업하기 버튼
        backup_btn = QPushButton("캐릭터 백업하기")
        backup_btn.setMinimumHeight(42)
        backup_btn.setStyleSheet("""
            QPushButton {
                background-color: #8ECFB5;
                color: white;
                border: none;
                border-radius: 12px;
                font-weight: 700;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #7BC4A8;
            }
        """)
        
        def do_backup():
            selected = [cid for cid, cb in checkboxes.items() if cb.isChecked()]
            if not selected:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.warning(dialog, "백업", "백업할 캐릭터를 선택해주세요.")
                return
            
            dialog.accept()
            self._backup_selected_characters(selected, self._backup_export_path)
        
        backup_btn.clicked.connect(do_backup)
        main_layout.addWidget(backup_btn)
        
        # 앱 전체 백업/불러오기 버튼
        app_backup_btn = QPushButton("앱 전체 백업/불러오기")
        app_backup_btn.setMinimumHeight(42)
        app_backup_btn.setCursor(Qt.PointingHandCursor)
        app_backup_btn.setStyleSheet("""
            QPushButton {
                background-color: #E8F5EE;
                color: #5A9C85;
                border: 1px solid #C5E8D8;
                border-radius: 12px;
                font-weight: 700;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #D8EBE0;
            }
        """)
        app_backup_btn.clicked.connect(lambda: self._show_app_backup_dialog_from_batch(dialog))
        main_layout.addWidget(app_backup_btn)
        
        # 백업된 경로 열기 버튼
        open_folder_btn = QPushButton("백업된 경로 열기")
        open_folder_btn.setMinimumHeight(42)
        open_folder_btn.setStyleSheet("""
            QPushButton {
                background-color: white;
                color: #5A9C85;
                border: 1px solid #9DD4BA;
                border-radius: 12px;
                font-weight: 700;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #F0FAF5;
            }
        """)
        
        def open_backup_folder():
            import subprocess
            # 설정 파일에서 경로 읽기
            backup_path = ''
            if os.path.exists(self.config_file):
                try:
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        config_data = json.load(f)
                        backup_path = config_data.get('last_backup_folder', '')
                except:
                    pass
            
            if backup_path and os.path.exists(backup_path):
                try:
                    if sys.platform == 'win32':
                        os.startfile(backup_path)
                    elif sys.platform == 'darwin':
                        subprocess.run(['open', backup_path])
                    else:
                        subprocess.run(['xdg-open', backup_path])
                except Exception as e:
                    print(f"폴더 열기 실패: {e}")
            else:
                from PyQt5.QtWidgets import QMessageBox
                QMessageBox.information(dialog, "알림", "아직 백업된 폴더가 없습니다.\n먼저 백업을 진행해주세요.")
        
        open_folder_btn.clicked.connect(open_backup_folder)
        main_layout.addWidget(open_folder_btn)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()
    
    def _backup_selected_characters(self, char_ids, export_path=''):
        """선택된 캐릭터들 백업 (폴더 + 이미지 + JSON 방식)"""
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        import json
        import shutil
        import re
        
        # 폴더 선택 (export_path가 없으면 다이얼로그로 선택)
        folder = export_path if export_path and os.path.exists(export_path) else QFileDialog.getExistingDirectory(self, "백업 저장 위치 선택")
        if not folder:
            return
        
        try:
            backup_count = 0
            created_folders = []
            
            # 선택된 캐릭터 각각 폴더로 백업
            for char_id in char_ids:
                if char_id not in self.character_data:
                    continue
                    
                data = self.character_data[char_id]
                char_name = data.get('name', f'캐릭터_{char_id}')
                
                # 폴더명 생성 (특수문자 제거)
                safe_name = re.sub(r'[<>:"/\\|?*]', '', char_name).strip()
                if not safe_name:
                    safe_name = f'캐릭터_{char_id}'
                
                backup_folder = os.path.join(folder, f"{safe_name}_백업")
                
                # 같은 이름 폴더가 있으면 숫자 붙이기
                counter = 1
                original_folder = backup_folder
                while os.path.exists(backup_folder):
                    backup_folder = f"{original_folder}_{counter}"
                    counter += 1
                
                os.makedirs(backup_folder, exist_ok=True)
                created_folders.append(backup_folder)
                
                # 이미지 복사
                image_file = "image.png"
                image_path = data.get('image_path', '')
                if image_path and os.path.exists(image_path):
                    ext = os.path.splitext(image_path)[1] or '.png'
                    image_file = f"image{ext}"
                    shutil.copy2(image_path, os.path.join(backup_folder, image_file))
                
                # AI 캐시 가져오기
                ai_cache = {}
                if char_id in _ai_dialogues_cache:
                    cache = _ai_dialogues_cache[char_id]
                    ai_cache = {
                        'solo': cache.get('solo', []),
                        'interaction': cache.get('interaction', {}),
                        'fallback': cache.get('fallback', []),
                        'reference': cache.get('reference', {})  # 참고용 수동 대사
                    }
                
                # 백업 데이터 생성 (이미지 파일명만 저장, base64 없음)
                # nicknames와 stories의 키를 char_id에서 char_name으로 변환
                nicknames_by_name = {}
                stories_by_name = {}
                
                raw_nicknames = data.get('nicknames', {})
                raw_stories = data.get('stories', {})
                
                for other_id, nickname in raw_nicknames.items():
                    try:
                        other_id_int = int(other_id) if isinstance(other_id, str) else other_id
                        if other_id_int in self.character_data:
                            other_name = self.character_data[other_id_int].get('name', f'캐릭터_{other_id_int}')
                            nicknames_by_name[other_name] = nickname
                    except:
                        pass
                
                for other_id, story in raw_stories.items():
                    try:
                        other_id_int = int(other_id) if isinstance(other_id, str) else other_id
                        if other_id_int in self.character_data:
                            other_name = self.character_data[other_id_int].get('name', f'캐릭터_{other_id_int}')
                            stories_by_name[other_name] = story
                    except:
                        pass
                
                backup_data = {
                    'version': '3.1',  # 버전 업 (이름 기반 호칭/서사)
                    'backup_type': 'single_character',
                    'char_name': char_name,
                    'image_file': image_file,
                    'catchphrase': data.get('catchphrase', ''),
                    'personality': data.get('personality', ''),
                    'background_story': data.get('background_story', ''),
                    'nicknames': nicknames_by_name,  # 이름 기반
                    'stories': stories_by_name,  # 이름 기반
                    'nicknames_by_id': data.get('nicknames', {}),  # 구버전 호환용
                    'stories_by_id': data.get('stories', {}),  # 구버전 호환용
                    'sample_dialogues': data.get('sample_dialogues', []),
                    'dialogues': self.dialogues.get(char_id, {'기본': []}),
                    'ai_cache': ai_cache,
                    'scale': data.get('scale', 100),
                    'bubble_color': data.get('bubble_color', '#A8D5BA'),
                    'bubble_size': data.get('bubble_size', 100),
                    'facing_direction': data.get('facing_direction', 'right'),
                    'is_active': data.get('is_active', True)
                }
                
                # JSON 파일로 저장
                json_path = os.path.join(backup_folder, "data.json")
                with open(json_path, 'w', encoding='utf-8') as f:
                    json.dump(backup_data, f, ensure_ascii=False, indent=2)
                
                backup_count += 1
            
            # 마지막 백업 폴더 경로 저장
            try:
                config_data = {}
                if os.path.exists(self.config_file):
                    with open(self.config_file, 'r', encoding='utf-8') as f:
                        config_data = json.load(f)
                config_data['last_backup_folder'] = folder
                with open(self.config_file, 'w', encoding='utf-8') as f:
                    json.dump(config_data, f, ensure_ascii=False, indent=2)
            except Exception as e:
                print(f"백업 경로 저장 실패: {e}")
            
            QMessageBox.information(self, "백업 완료", 
                f"백업이 완료되었습니다!\n\n"
                f"📁 저장 위치: {folder}")
        
        except Exception as e:
            QMessageBox.warning(self, "백업 실패", f"백업 중 오류가 발생했습니다:\n{str(e)}")
    
    def show_credit_dialog(self):
        """크레딧 다이얼로그 표시"""
        from PyQt5.QtSvg import QSvgRenderer
        
        dialog = QDialog(self)
        dialog.setWindowFlags(Qt.FramelessWindowHint | Qt.Dialog)
        dialog.setAttribute(Qt.WA_TranslucentBackground)
        dialog.setFixedWidth(371)  # 331 + padding
        
        # 메인 컨테이너
        container = QWidget()
        container.setStyleSheet("""
            QWidget#creditContainer {
                background-color: white;
                border-radius: 20px;
                border: 1px solid #C5E8D8;
            }
        """)
        container.setObjectName("creditContainer")
        
        layout = QVBoxLayout(container)
        layout.setContentsMargins(20, 16, 20, 20)
        layout.setSpacing(0)
        
        # 닫기 버튼 (왼쪽 상단)
        close_btn = QPushButton()
        close_btn.setFixedSize(20, 20)
        close_btn.setCursor(Qt.PointingHandCursor)
        close_btn.clicked.connect(dialog.close)
        
        # X 아이콘 SVG
        close_svg = '''<svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M1.25 18.75L18.75 1.25M18.75 18.75L1.25 1.25" stroke="#8ECFB5" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>'''
        
        renderer = QSvgRenderer(close_svg.encode('utf-8'))
        if renderer.isValid():
            pixmap = QPixmap(20, 20)
            pixmap.fill(Qt.transparent)
            painter = QPainter(pixmap)
            renderer.render(painter)
            painter.end()
            close_btn.setIcon(QIcon(pixmap))
            close_btn.setIconSize(QSize(20, 20))
        
        close_btn.setStyleSheet("""
            QPushButton {
                background-color: transparent;
                border: none;
            }
            QPushButton:hover {
                background-color: rgba(142, 207, 181, 0.2);
                border-radius: 4px;
            }
        """)
        
        # 닫기 버튼 오른쪽 정렬
        close_layout = QHBoxLayout()
        close_layout.setContentsMargins(0, 0, 0, 10)
        close_layout.addStretch()
        close_layout.addWidget(close_btn)
        layout.addLayout(close_layout)
        
        # Kiwipet 타이틀 로고 (SVG 사용)
        kiwipet_title_svg = '''<svg width="150" height="76" viewBox="0 0 150 76" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M46.6403 43.9567C47.0397 43.9567 47.347 44.1411 47.5621 44.5098C47.8079 44.8785 47.9308 45.3854 47.9308 46.0306C47.9308 47.2289 47.6389 48.1814 47.0551 48.8881C45.5803 50.6701 44.0901 52.0527 42.5846 53.0359C41.0791 53.9884 39.2971 54.4646 37.2385 54.4646C34.9649 54.4646 33.106 53.804 31.6619 52.4829C30.2179 51.131 28.866 49.0417 27.6063 46.215C26.6845 44.1872 25.9164 42.6816 25.3019 41.6984C24.7181 40.6845 24.1344 39.9779 23.5506 39.5784C22.9668 39.1483 22.2294 38.8871 21.3384 38.7949L20.8314 42.2054C20.1862 46.5991 18.9265 49.7637 17.0523 51.6994C15.2088 53.635 12.6586 54.6029 9.4018 54.6029C7.28179 54.6029 5.39221 54.0959 3.73307 53.082C2.10465 52.0374 0.967833 50.7162 0.322611 49.1185C0.107537 48.5654 0 47.9663 0 47.3211C0 46.3993 0.215074 45.6005 0.645222 44.9246C1.07537 44.2486 1.62842 43.9106 2.30436 43.9106C2.70379 43.9106 3.04176 44.0182 3.31828 44.2332C3.59481 44.4176 3.85597 44.7556 4.10177 45.2472C5.05424 47.0292 5.88381 48.2736 6.59048 48.9802C7.32787 49.6869 8.23426 50.0402 9.30963 50.0402C10.5386 50.0402 11.5833 49.4872 12.4436 48.3811C13.3346 47.2443 13.9644 45.5083 14.3331 43.1732L14.9784 38.7949H14.241C13.5343 38.7949 12.9812 38.5952 12.5818 38.1958C12.1824 37.7964 11.9827 37.2433 11.9827 36.5367C11.9827 35.7378 12.1824 35.108 12.5818 34.6471C13.012 34.1555 13.5343 33.9097 14.1488 33.9097H15.6697C15.8847 32.4042 16.0384 31.3595 16.1305 30.7758L17.5592 20.4061C16.7604 20.314 16.0076 20.2679 15.301 20.2679C12.6894 20.2679 10.7076 20.7287 9.35571 21.6505C8.00382 22.5415 7.32787 23.8319 7.32787 25.5218C7.32787 26.2899 7.40469 26.9198 7.55831 27.4114C7.74266 27.8723 7.9731 28.3946 8.24962 28.9784C8.37252 29.2242 8.43397 29.5007 8.43397 29.8079C8.43397 30.4839 8.11136 31.083 7.46614 31.6053C6.85164 32.0969 6.16033 32.3427 5.39221 32.3427C4.40902 32.3427 3.68698 31.9126 3.22611 31.0523C2.30436 29.4239 1.84349 27.6726 1.84349 25.7983C1.84349 23.8627 2.36581 22.096 3.41046 20.4983C4.48583 18.9006 6.09888 17.6255 8.24962 16.6731C10.4004 15.6899 13.0581 15.1983 16.2227 15.1983C17.6053 15.1983 18.8651 15.2751 20.0019 15.4287C21.1694 15.5823 22.4445 15.8742 23.8271 16.3044C25.3326 16.7652 26.0854 17.6255 26.0854 18.8853C26.0854 20.5751 25.3634 21.42 23.9193 21.42L22.1219 33.8175C25.7167 33.4488 28.6356 31.9126 30.8785 29.2088C33.1521 26.4743 35.0417 22.7719 36.5472 18.1018C36.8237 17.2415 37.2846 16.5809 37.9298 16.12C38.6058 15.6591 39.4507 15.4287 40.4646 15.4287C41.3249 15.4287 41.9855 15.6284 42.4464 16.0278C42.938 16.3965 43.1838 16.9342 43.1838 17.6409C43.1838 17.856 43.1223 18.2093 42.9994 18.7009C41.4632 23.7705 39.2663 27.7955 36.4089 30.7758C33.5515 33.7561 30.433 35.7378 27.0532 36.721C28.2208 36.9975 29.1732 37.4123 29.9106 37.9654C30.6788 38.5184 31.324 39.2097 31.8463 40.0393C32.3686 40.8381 32.9678 41.9596 33.6437 43.4037C34.5962 45.4315 35.4872 46.8756 36.3168 47.7359C37.1463 48.5654 38.1142 48.9802 39.2203 48.9802C40.2035 48.9802 41.1406 48.6576 42.0316 48.0124C42.9226 47.3365 44.0441 46.1996 45.396 44.6019C45.7646 44.1718 46.1794 43.9567 46.6403 43.9567Z" fill="#4FB98F"/>
<path d="M48.8305 29.7158C47.5401 29.7158 46.5723 29.4239 45.927 28.8401C45.2818 28.2256 44.9592 27.3807 44.9592 26.3053C44.9592 25.2299 45.374 24.3389 46.2036 23.6322C47.0639 22.8948 48.1239 22.5261 49.3836 22.5261C50.5204 22.5261 51.4421 22.8027 52.1488 23.3557C52.8555 23.9088 53.2088 24.6922 53.2088 25.7062C53.2088 26.9352 52.8094 27.9184 52.0106 28.6558C51.2117 29.3624 50.1517 29.7158 48.8305 29.7158ZM48.4618 54.4646C46.4647 54.4646 45.0053 53.7579 44.0835 52.3446C43.1925 50.9313 42.747 49.057 42.747 46.722C42.747 45.3393 42.916 43.5727 43.254 41.4219C43.6227 39.2405 44.0835 37.2126 44.6366 35.3384C44.9131 34.3552 45.2818 33.6793 45.7427 33.3106C46.2036 32.9419 46.941 32.7575 47.9549 32.7575C49.5218 32.7575 50.3053 33.2798 50.3053 34.3245C50.3053 35.0926 50.0134 36.8746 49.4297 39.6706C48.6923 43.0503 48.3236 45.3393 48.3236 46.5376C48.3236 47.4594 48.4465 48.166 48.6923 48.6576C48.9381 49.1492 49.3529 49.395 49.9366 49.395C50.4897 49.395 51.181 49.011 52.0106 48.2428C52.8401 47.4747 53.9462 46.2611 55.3288 44.6019C55.6975 44.1718 56.1123 43.9567 56.5732 43.9567C56.9726 43.9567 57.2799 44.1411 57.4949 44.5098C57.7407 44.8785 57.8636 45.3854 57.8636 46.0306C57.8636 47.2596 57.5718 48.2121 56.988 48.8881C53.9462 52.6058 51.1042 54.4646 48.4618 54.4646Z" fill="#4FB98F"/>
<path d="M87.5834 40.2237C87.6756 40.1929 87.8292 40.1776 88.0443 40.1776C88.5052 40.1776 88.8585 40.3312 89.1043 40.6384C89.3501 40.9457 89.473 41.3605 89.473 41.8828C89.473 42.8353 89.2887 43.588 88.92 44.1411C88.5513 44.6634 87.9982 45.0475 87.2608 45.2932C85.8475 45.7541 84.342 45.9846 82.7443 45.9846C81.3924 45.9846 80.1173 45.8002 78.919 45.4315C78.028 46.8756 77.0448 48.3657 75.9694 49.902C74.7404 51.6533 73.6805 52.8516 72.7894 53.4968C71.9291 54.142 70.9459 54.4646 69.8398 54.4646C68.6108 54.4646 67.6737 53.9884 67.0285 53.0359C66.414 52.0834 66.03 50.5165 65.8763 48.335L65.6459 44.9706C64.6934 47.5515 63.8331 49.5179 63.065 50.8698C62.3276 52.2217 61.5749 53.1588 60.8067 53.6811C60.0693 54.2035 59.1937 54.4646 58.1798 54.4646C56.92 54.4646 55.9215 53.973 55.1841 52.9898C54.4774 52.0066 54.0319 50.455 53.8476 48.335C53.4789 44.0335 53.2945 40.2697 53.2945 37.0436V35.4306C53.3252 34.4167 53.6018 33.71 54.1241 33.3106C54.6464 32.9111 55.4299 32.7114 56.4745 32.7114C57.2734 32.7114 57.8572 32.8958 58.2259 33.2645C58.6253 33.6024 58.825 34.1862 58.825 35.0158C58.825 38.5491 59.0401 43.1425 59.4702 48.7959C61.5595 44.4022 63.4798 39.8242 65.2311 35.0619C65.5691 34.1401 65.9685 33.5256 66.4294 33.2184C66.921 32.8804 67.5048 32.7114 68.1807 32.7114C69.0103 32.7114 69.5787 32.8804 69.8859 33.2184C70.2239 33.5564 70.3929 34.1555 70.3929 35.0158C70.3929 38.5491 70.608 43.1425 71.0381 48.7959C72.8816 46.0614 74.2642 43.8799 75.186 42.2515C74.7251 41.3605 74.4947 40.3005 74.4947 39.0715C74.4947 38.0268 74.7251 37.0129 75.186 36.0297C75.6468 35.0465 76.2767 34.2477 77.0755 33.6332C77.8744 33.0187 78.7808 32.7114 79.7947 32.7114C80.6857 32.7114 81.4077 33.034 81.9608 33.6793C82.5138 34.2938 82.7904 35.2001 82.7904 36.3984C82.7904 37.781 82.4217 39.3634 81.6843 41.1454C82.8518 41.0839 84.4034 40.8535 86.3391 40.4541L87.5834 40.2237Z" fill="#4FB98F"/>
<path d="M90.1272 29.7158C88.8368 29.7158 87.869 29.4239 87.2237 28.8401C86.5785 28.2256 86.2559 27.3807 86.2559 26.3053C86.2559 25.2299 86.6707 24.3389 87.5003 23.6322C88.3606 22.8948 89.4206 22.5261 90.6803 22.5261C91.8171 22.5261 92.7389 22.8027 93.4455 23.3557C94.1522 23.9088 94.5055 24.6922 94.5055 25.7062C94.5055 26.9352 94.1061 27.9184 93.3073 28.6558C92.5084 29.3624 91.4484 29.7158 90.1272 29.7158ZM89.7585 54.4646C87.7614 54.4646 86.302 53.7579 85.3802 52.3446C84.4892 50.9313 84.0437 49.057 84.0437 46.722C84.0437 45.3393 84.2127 43.5727 84.5507 41.4219C84.9194 39.2405 85.3803 37.2126 85.9333 35.3384C86.2098 34.3552 86.5785 33.6793 87.0394 33.3106C87.5003 32.9419 88.2377 32.7575 89.2516 32.7575C90.8186 32.7575 91.602 33.2798 91.602 34.3245C91.602 35.0926 91.3101 36.8746 90.7264 39.6706C89.989 43.0503 89.6203 45.3393 89.6203 46.5376C89.6203 47.4594 89.7432 48.166 89.989 48.6576C90.2348 49.1492 90.6496 49.395 91.2333 49.395C91.7864 49.395 92.4777 49.011 93.3073 48.2428C94.1368 47.4747 95.2429 46.2611 96.6255 44.6019C96.9942 44.1718 97.409 43.9567 97.8699 43.9567C98.2693 43.9567 98.5766 44.1411 98.7916 44.5098C99.0374 44.8785 99.1603 45.3854 99.1603 46.0306C99.1603 47.2596 98.8685 48.2121 98.2847 48.8881C95.2429 52.6058 92.4009 54.4646 89.7585 54.4646Z" fill="#4FB98F"/>
<path d="M118.66 43.9567C119.059 43.9567 119.366 44.1411 119.581 44.5098C119.827 44.8785 119.95 45.3854 119.95 46.0306C119.95 47.2596 119.658 48.2121 119.074 48.8881C117.753 50.5165 116.324 51.853 114.788 52.8977C113.283 53.9423 111.562 54.4646 109.626 54.4646C107.998 54.4646 106.677 53.8808 105.663 52.7133C103.912 53.8501 102.084 54.4339 100.179 54.4646C99.7792 60.3945 98.8728 65.3412 97.4594 69.3047C96.0461 73.2989 93.9722 75.2961 91.2377 75.2961C89.5785 75.2961 88.3495 74.6969 87.5507 73.4987C86.7518 72.3004 86.3524 70.6412 86.3524 68.5212C86.3524 65.5102 87.0437 61.9922 88.4263 57.9672C89.8089 53.973 91.9443 49.564 94.8325 44.7402C94.8325 40.2544 94.8017 37.1358 94.7403 35.3845C94.7096 34.4935 95.0629 33.7868 95.8003 33.2645C96.5377 32.7422 97.4594 32.481 98.5655 32.481C99.2107 32.481 99.6716 32.6193 99.9481 32.8958C100.255 33.1416 100.424 33.6485 100.455 34.4167C100.455 35.1848 100.47 35.7532 100.501 36.1219C101.484 34.8929 102.452 34.0172 103.405 33.4949C104.357 32.9419 105.371 32.6653 106.446 32.6653C108.167 32.6653 109.565 33.3566 110.64 34.7393C111.746 36.1219 112.3 37.9347 112.3 40.1776C112.3 41.806 112.038 43.3883 111.516 44.9246C110.994 46.4608 110.272 47.8588 109.35 49.1185C109.995 49.3028 110.533 49.395 110.963 49.395C111.977 49.395 112.945 49.0263 113.866 48.2889C114.788 47.5515 115.971 46.3225 117.415 44.6019C117.784 44.1718 118.199 43.9567 118.66 43.9567ZM100.409 50.0402C101.515 49.7944 102.529 49.1953 103.451 48.2428C104.403 47.2596 105.156 46.0614 105.709 44.648C106.262 43.204 106.539 41.6984 106.539 40.1315C106.539 39.2097 106.354 38.5184 105.986 38.0576C105.617 37.566 105.125 37.3202 104.511 37.3202C103.405 37.3202 102.068 38.4877 100.501 40.8228C100.47 42.1747 100.455 44.1564 100.455 46.768C100.455 48.1814 100.44 49.2721 100.409 50.0402ZM91.6063 70.7795C92.4359 70.7795 93.1272 68.9667 93.6803 65.3412C94.2333 61.7464 94.5867 57.2606 94.7403 51.8837C93.4191 54.9562 92.3745 57.8904 91.6063 60.6864C90.8382 63.4824 90.4542 65.8328 90.4542 67.7378C90.4542 68.7209 90.5771 69.4737 90.8229 69.996C91.0379 70.5183 91.2991 70.7795 91.6063 70.7795Z" fill="#4FB98F"/>
<path d="M135.41 43.9567C135.809 43.9567 136.116 44.1411 136.332 44.5098C136.577 44.8785 136.7 45.3854 136.7 46.0306C136.7 47.2596 136.408 48.2121 135.825 48.8881C134.688 50.2707 133.075 51.5458 130.985 52.7133C128.927 53.8808 126.715 54.4646 124.349 54.4646C121.123 54.4646 118.619 53.589 116.837 51.8376C115.055 50.0863 114.164 47.6898 114.164 44.648C114.164 42.528 114.609 40.5616 115.5 38.7489C116.391 36.9054 117.62 35.4459 119.187 34.3706C120.785 33.2952 122.582 32.7575 124.579 32.7575C126.361 32.7575 127.79 33.2952 128.865 34.3706C129.941 35.4152 130.478 36.8439 130.478 38.6567C130.478 40.7767 129.71 42.6048 128.174 44.1411C126.669 45.6466 124.103 46.8449 120.478 47.7359C121.246 49.1492 122.705 49.8559 124.856 49.8559C126.238 49.8559 127.805 49.3797 129.557 48.4272C131.339 47.444 132.875 46.1689 134.165 44.6019C134.534 44.1718 134.949 43.9567 135.41 43.9567ZM123.796 37.2741C122.659 37.2741 121.691 37.9347 120.892 39.2558C120.124 40.577 119.74 42.1747 119.74 44.0489V44.1411C121.553 43.7109 122.982 43.0657 124.026 42.2054C125.071 41.3451 125.593 40.3466 125.593 39.2097C125.593 38.626 125.424 38.1651 125.086 37.8271C124.779 37.4584 124.349 37.2741 123.796 37.2741Z" fill="#4FB98F"/>
<path d="M139.169 37.1358C139.108 38.672 139.077 39.8703 139.077 40.7306C139.077 42.9428 139.185 44.6788 139.4 45.9385C139.646 47.1675 140.03 48.0585 140.552 48.6115C141.105 49.1339 141.858 49.395 142.81 49.395C143.302 49.395 143.886 49.2414 144.562 48.9341C145.238 48.6269 145.852 48.2275 146.405 47.7359C146.743 47.4286 147.081 47.275 147.419 47.275C147.788 47.275 148.08 47.4901 148.295 47.9202C148.541 48.3196 148.663 48.8112 148.663 49.395C148.663 49.9788 148.541 50.5472 148.295 51.1002C148.08 51.6533 147.742 52.1142 147.281 52.4829C145.683 53.804 143.87 54.4646 141.843 54.4646C138.924 54.4646 136.788 53.251 135.436 50.8237C134.085 48.3657 133.409 45.1704 133.409 41.2376C133.409 39.8857 133.455 38.5184 133.547 37.1358H131.749C130.828 37.1358 130.198 36.9668 129.86 36.6288C129.553 36.2909 129.399 35.7532 129.399 35.0158C129.399 33.2952 130.09 32.4349 131.473 32.4349H134.1C134.622 29.0552 135.421 25.9673 136.496 23.1714C137.572 20.3754 138.862 18.1479 140.368 16.4887C141.904 14.8296 143.548 14 145.299 14C146.59 14 147.603 14.5684 148.341 15.7052C149.078 16.842 149.447 18.2708 149.447 19.9913C149.447 24.7537 147.45 28.9015 143.456 32.4349H148.617C149.109 32.4349 149.462 32.5424 149.677 32.7575C149.892 32.9726 150 33.372 150 33.9558C150 36.0758 148.264 37.1358 144.792 37.1358H139.169ZM144.055 18.4244C143.594 18.4244 143.072 19.0081 142.488 20.1757C141.935 21.3125 141.397 22.9102 140.875 24.9688C140.383 26.9966 139.968 29.2549 139.63 31.7436C141.443 30.1766 142.795 28.4253 143.686 26.4896C144.608 24.5233 145.069 22.7412 145.069 21.1435C145.069 19.3308 144.731 18.4244 144.055 18.4244Z" fill="#4FB98F"/>
</svg>'''
        
        renderer = QSvgRenderer(kiwipet_title_svg.encode('utf-8'))
        if renderer.isValid():
            # 150x76 비율 유지하며 높이 38로 렌더링 (크레딧에 맞게 축소)
            title_pixmap = QPixmap(150, 76)
            title_pixmap.fill(Qt.transparent)
            painter = QPainter(title_pixmap)
            renderer.render(painter)
            painter.end()
            
            # 적당한 크기로 스케일
            title_pixmap = title_pixmap.scaledToHeight(38, Qt.SmoothTransformation)
            
            title_label = QLabel()
            title_label.setPixmap(title_pixmap)
            title_label.setAlignment(Qt.AlignCenter)
            title_label.setContentsMargins(0, 0, 0, 15)
            layout.addWidget(title_label)
        
        # 크레딧 내용 (각 줄을 개별 라벨로)
        credit_style = """
            QLabel {
                color: #349971;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                font-size: 14px;
                font-weight: 700;
                line-height: 19px;
                background: transparent;
                border: none;
            }
        """
        
        divider_style = """
            QLabel {
                color: #C5E8D8;
                font-size: 14px;
                background: transparent;
                border: none;
            }
        """

        small_gray_style = """
            QLabel {
                color: #cad6d1;
                font-family: 'Pretendard', 'Apple SD Gothic Neo', '맑은 고딕', sans-serif;
                font-size: 11px;
                background: transparent;
                border: none;
            }
        """

        def add_text(text, style=credit_style, margin_top=0, margin_bottom=0):
            label = QLabel(text)
            label.setAlignment(Qt.AlignCenter)
            label.setStyleSheet(style)
            label.setContentsMargins(0, margin_top, 0, margin_bottom)
            layout.addWidget(label)
        
        def add_divider():
            add_text("—", divider_style, 8, 8)
        
        # Version & Release
        add_text("Version 1.2.3")
        add_text("Release 2026.01.20", margin_bottom=0)
        
        add_divider()
        
        # Made by
        add_text("made by 키위캣(@kiwwwicat)")
        
        add_divider()
        
        # Used Tools
        add_text("Used Tools")
        add_text("Claude")
        add_text("Gemini API")
        
        add_divider()
        
        # UI 도움
        add_text("UI 도움")
        add_text("냐하(@nyahyanyahya)")

        add_divider()

        # Special Thanks
        add_text("Special Thanks to")
        add_text("관엽식물(@GWAN5ICK)")

        add_divider()

        # Contact
        add_text("Contact")
        add_text("Twitter(X): @kiwwwicat")
        add_text("Email: kiwwwicat@naver.com")
        
        add_divider()

        # License & Copyright
        add_text("© 2026 Kiwicat.")
        add_text("This program comes with no warranty.", small_gray_style)
        add_text("You may redistribute it under GNU GPL v3.", small_gray_style)
        add_text("https://www.gnu.org/licenses/gpl-3.0.html", small_gray_style, margin_bottom=15)
        
        # 하단 이미지 (kiwicat_kiwipet.svg) - 36x36
        kiwicat1_svg = '''<svg width="36" height="36" viewBox="0 0 36 36" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M13 5H12V6H13V5Z" fill="#349971"/>
<path d="M24 5H23V6H24V5Z" fill="#349971"/>
<path d="M12 6H11V7H12V6Z" fill="#349971"/>
<path d="M13 6H12V7H13V6Z" fill="#9DD4BA"/>
<path d="M14 6H13V7H14V6Z" fill="#349971"/>
<path d="M23 6H22V7H23V6Z" fill="#349971"/>
<path d="M24 6H23V7H24V6Z" fill="#9DD4BA"/>
<path d="M25 6H24V7H25V6Z" fill="#349971"/>
<path d="M11 7H10V9H11V7Z" fill="#349971"/>
<path d="M12 7H11V8H12V7Z" fill="#9DD4BA"/>
<path d="M13 7H12V8H13V7Z" fill="#E3EBE2"/>
<path d="M14 7H13V8H14V7Z" fill="#9DD4BA"/>
<path d="M15 7H14V8H15V7Z" fill="#349971"/>
<path d="M22 7H21V8H22V7Z" fill="#349971"/>
<path d="M23 7H22V8H23V7Z" fill="#9DD4BA"/>
<path d="M24 7H23V8H24V7Z" fill="#E3EBE2"/>
<path d="M25 7H24V8H25V7Z" fill="#9DD4BA"/>
<path d="M26 7H25V9H26V7Z" fill="#349971"/>
<path d="M15 8H11V9H15V8Z" fill="#1C8C7F"/>
<path d="M21 8H15V9H21V8Z" fill="#349971"/>
<path d="M25 8H21V9H25V8Z" fill="#1C8C7F"/>
<path d="M10 9H9V10H10V9Z" fill="#349971"/>
<path d="M26 9H10V15H26V9Z" fill="#9DD4BA"/>
<path d="M27 9H26V10H27V9Z" fill="#349971"/>
<path d="M9 10H8V11H9V10Z" fill="#349971"/>
<path d="M10 10H9V16H10V10Z" fill="#9DD4BA"/>
<path d="M27 10H26V16H27V10Z" fill="#9DD4BA"/>
<path d="M28 10H27V11H28V10Z" fill="#349971"/>
<path d="M8 11H7V12H8V11Z" fill="#349971"/>
<path d="M9 11H8V26H9V11Z" fill="#9DD4BA"/>
<path d="M28 11H27V26H28V11Z" fill="#9DD4BA"/>
<path d="M29 11H28V12H29V11Z" fill="#349971"/>
<path d="M7 12H6V14H7V12Z" fill="#349971"/>
<path d="M8 12H7V25H8V12Z" fill="#9DD4BA"/>
<path d="M29 12H28V25H29V12Z" fill="#9DD4BA"/>
<path d="M30 12H29V14H30V12Z" fill="#349971"/>
<path d="M6 14H5V24H6V14Z" fill="#349971"/>
<path d="M7 14H6V24H7V14Z" fill="#9DD4BA"/>
<path d="M30 14H29V24H30V14Z" fill="#9DD4BA"/>
<path d="M31 14H30V24H31V14Z" fill="#349971"/>
<path d="M13 15H10V16H13V15Z" fill="#9DD4BA"/>
<path d="M14 15H13V16H14V15Z" fill="#14655B"/>
<path d="M22 15H14V17H22V15Z" fill="#9DD4BA"/>
<path d="M23 15H22V16H23V15Z" fill="#14655B"/>
<path d="M26 15H23V16H26V15Z" fill="#9DD4BA"/>
<path d="M11 16H9V17H11V16Z" fill="#1C8C7F"/>
<path d="M14 16H11V25H14V16Z" fill="#9DD4BA"/>
<path d="M25 16H22V25H25V16Z" fill="#9DD4BA"/>
<path d="M27 16H25V17H27V17Z" fill="#1C8C7F"/>
<path d="M11 17H9V27H11V17Z" fill="#9DD4BA"/>
<path d="M17 17H14V18H17V17Z" fill="#9DD4BA"/>
<path d="M19 17H17V18H19V17Z" fill="#14655B"/>
<path d="M22 17H19V18H22V17Z" fill="#9DD4BA"/>
<path d="M27 17H25V27H27V17Z" fill="#9DD4BA"/>
<path d="M15 18H14V24H15V18Z" fill="#9DD4BA"/>
<path d="M17 18H15V19H17V18Z" fill="#14655B"/>
<path d="M19 18H17V24H19V18Z" fill="#9DD4BA"/>
<path d="M21 18H19V19H21V18Z" fill="#14655B"/>
<path d="M22 18H21V24H22V18Z" fill="#9DD4BA"/>
<path d="M17 19H15V24H17V19Z" fill="#9DD4BA"/>
<path d="M21 19H19V24H21V19Z" fill="#9DD4BA"/>
<path d="M7 24H6V25H7V24Z" fill="#349971"/>
<path d="M22 24H14V29H22V24Z" fill="#E3EBE2"/>
<path d="M30 24H29V25H30V24Z" fill="#349971"/>
<path d="M8 25H7V26H8V25Z" fill="#349971"/>
<path d="M12 25H11V26H12V25Z" fill="#9DD4BA"/>
<path d="M14 25H12V28H14V25Z" fill="#E3EBE2"/>
<path d="M24 25H22V28H24V25Z" fill="#E3EBE2"/>
<path d="M25 25H24V26H25V25Z" fill="#9DD4BA"/>
<path d="M29 25H28V26H29V25Z" fill="#349971"/>
<path d="M9 26H8V27H9V26Z" fill="#349971"/>
<path d="M12 26H11V28H12V26Z" fill="#E3EBE2"/>
<path d="M25 26H24V28H25V26Z" fill="#E3EBE2"/>
<path d="M28 26H27V27H28V26Z" fill="#349971"/>
<path d="M11 27H9V28H11V27Z" fill="#349971"/>
<path d="M27 27H25V28H27V27Z" fill="#349971"/>
<path d="M13 28H11V29H13V28Z" fill="#349971"/>
<path d="M14 28H13V29H14V28Z" fill="#E3EBE2"/>
<path d="M23 28H22V29H23V28Z" fill="#E3EBE2"/>
<path d="M25 28H23V29H25V28Z" fill="#349971"/>
<path d="M23 29H13V30H23V29Z" fill="#349971"/>
</svg>'''
        
        footer_renderer = QSvgRenderer(kiwicat1_svg.encode('utf-8'))
        if footer_renderer.isValid():
            footer_pixmap = QPixmap(36, 36)
            footer_pixmap.fill(Qt.transparent)
            painter = QPainter(footer_pixmap)
            footer_renderer.render(painter)
            painter.end()
            
            footer_label = QLabel()
            footer_label.setPixmap(footer_pixmap)
            footer_label.setAlignment(Qt.AlignCenter)
            footer_label.setStyleSheet("background: transparent; border: none;")
            layout.addWidget(footer_label)
        
        # 다이얼로그 레이아웃
        dialog_layout = QVBoxLayout(dialog)
        dialog_layout.setContentsMargins(0, 0, 0, 0)
        dialog_layout.addWidget(container)
        
        dialog.exec_()
    
    def dragEnterEvent(self, event):
        """드래그 진입 이벤트 - 이미지 파일만 허용"""
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                file_path = url.toLocalFile()
                if file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                    event.acceptProposedAction()
                    return
        event.ignore()
    
    def dropEvent(self, event):
        """드롭 이벤트 - 이미지 파일로 캐릭터 추가"""
        for url in event.mimeData().urls():
            file_path = url.toLocalFile()
            if file_path.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')):
                # 캐릭터 추가
                self.add_character_from_path(file_path)
                event.acceptProposedAction()
                return
        event.ignore()
    
    def add_character_from_path(self, file_path):
        """파일 경로로 캐릭터 추가 (드래그 앤 드롭용)"""
        try:
            # 방향 선택 다이얼로그
            direction_dialog = DirectionDialog(self)
            if direction_dialog.exec_() != QDialog.Accepted:
                return
            direction = direction_dialog.get_direction()
            
            # 빈 캐릭터 번호 찾기
            used_ids = set(self.character_data.keys())
            new_char_id = self.char_id_counter
            for i in range(self.char_id_counter):
                if i not in used_ids:
                    new_char_id = i
                    break
            
            # 캐릭터 위젯 생성
            char_widget = CharacterWidget(file_path, new_char_id, direction, 100, '#A8D5BA', 100)
            self.characters.append(char_widget)
            
            # 캐릭터 데이터 저장
            self.character_data[new_char_id] = {
                'name': f'캐릭터 {new_char_id + 1}',
                'scale': 100,
                'bubble_color': '#A8D5BA',
                'bubble_size': 100,
                'facing_direction': direction,
                'image_path': file_path,
                'is_active': True,
                'personality': '',
                'nicknames': {},
                'stories': {},
                'background_story': '',
                'sample_dialogues': [],
                'catchphrase': '',
                'ai_auto_generate': True  # AI 자동생성 기본값
            }
            
            # 대사 초기화
            if new_char_id not in self.dialogues:
                self.dialogues[new_char_id] = {'기본': []}
            char_widget.dialogues = self.dialogues.get(new_char_id, {'기본': []})
            
            # 카드 생성
            card = CharacterCard(new_char_id, file_path, is_active=True)
            card.remove_clicked.connect(self.remove_character)
            card.change_image_clicked.connect(self.change_character_image)
            card.change_scale_clicked.connect(self.change_character_scale)
            card.change_bubble_color_clicked.connect(self.change_bubble_color)
            card.change_relationships_clicked.connect(self.change_relationships)
            card.change_dialogues_clicked.connect(self.change_dialogues)
            card.change_personality_clicked.connect(self.change_personality)
            card.name_changed.connect(self.update_character_name)
            card.catchphrase_changed.connect(self.update_character_catchphrase)
            card.toggle_active.connect(self.toggle_character_active)
            card.batch_toggle_clicked.connect(self.show_batch_active_dialog)
            
            self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, card)
            
            # char_id_counter 업데이트
            if new_char_id >= self.char_id_counter:
                self.char_id_counter = new_char_id + 1
            
            # 저장
            self.save_characters()
            
            print(f"[드래그앤드롭] 캐릭터 {new_char_id} 추가됨: {file_path}")
            QMessageBox.information(self, "성공", "캐릭터가 추가되었습니다!")
            
        except Exception as e:
            print(f"[오류] 캐릭터 추가 실패: {e}")
            import traceback
            traceback.print_exc()
    
    def closeEvent(self, event):
        # 복원 후에는 저장하지 않음 (복원된 파일 보호)
        if not getattr(self, '_skip_save_on_close', False):
            self.save_characters()
        self.collision_timer.stop()
        for char in self.characters:
            char.close()
        event.accept()


def main():
    app = QApplication(sys.argv)
    app.setApplicationName("Kiwipet")

    # Pretendard 폰트 로드 시도
    pretendard_loaded = load_pretendard_font()

    if pretendard_loaded:
        # Pretendard 폰트 사용 (DemiBold weight)
        font = QFont('Pretendard', 10)
        font.setWeight(QFont.Bold)  # 700
        print(f"[폰트] Pretendard Bold 적용")
    else:
        # Fallback: 시스템 폰트
        if platform.system() == 'Darwin':
            font = QFont("Apple SD Gothic Neo", 10)
        else:
            font = QFont("맑은 고딕", 10)
        print("[폰트] 시스템 폰트 사용")

    app.setFont(font)
    
    # 앱 아이콘 설정 (모든 윈도우에 적용)
    app_icon = load_app_icon()
    if app_icon:
        app.setWindowIcon(app_icon)
    
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec_())



def load_app_icon():
    """앱 아이콘 로드 (kiwipet_6 SVG 내장)"""
    try:
        from PyQt5.QtSvg import QSvgRenderer

        # kiwipet_6 SVG (내장)
        kiwipet_svg = '''<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M10 7H11V8H13V7H14V6H18V7H19V8H20V13H19V14H18V15H17V16H16V17H15V18H14V19H13V20H11V19H10V18H9V17H8V16H7V15H6V14H5V13H4V8H5V7H6V6H10V7Z" fill="#D5E8DF"/>
<path d="M13 20V21H11V20H13Z" fill="#9DD4BA"/>
<path d="M11 20H10V19H11V20Z" fill="#9DD4BA"/>
<path d="M14 20H13V19H14V20Z" fill="#9DD4BA"/>
<path d="M10 19H9V18H10V19Z" fill="#9DD4BA"/>
<path d="M15 19H14V18H15V19Z" fill="#9DD4BA"/>
<path d="M9 18H8V17H9V18Z" fill="#9DD4BA"/>
<path d="M16 18H15V17H16V18Z" fill="#9DD4BA"/>
<path d="M8 17H7V16H8V17Z" fill="#9DD4BA"/>
<path d="M17 17H16V16H17V17Z" fill="#9DD4BA"/>
<path d="M7 16H6V15H7V16Z" fill="#9DD4BA"/>
<path d="M18 16H17V15H18V16Z" fill="#9DD4BA"/>
<path d="M6 15H5V14H6V15Z" fill="#9DD4BA"/>
<path d="M19 15H18V14H19V15Z" fill="#9DD4BA"/>
<path d="M5 14H4V13H5V14Z" fill="#9DD4BA"/>
<path d="M20 14H19V13H20V14Z" fill="#9DD4BA"/>
<path d="M4 13H3V8H4V13Z" fill="#9DD4BA"/>
<path d="M21 13H20V8H21V13Z" fill="#9DD4BA"/>
<path d="M5 8H4V7H5V8Z" fill="#9DD4BA"/>
<path d="M13 8H11V7H13V8Z" fill="#9DD4BA"/>
<path d="M20 8H19V7H20V8Z" fill="#9DD4BA"/>
<path d="M6 7H5V6H6V7Z" fill="#9DD4BA"/>
<path d="M11 7H10V6H11V7Z" fill="#9DD4BA"/>
<path d="M14 7H13V6H14V7Z" fill="#9DD4BA"/>
<path d="M19 7H18V6H19V7Z" fill="#9DD4BA"/>
<path d="M10 6H6V5H10V6Z" fill="#9DD4BA"/>
<path d="M18 6H14V5H18V6Z" fill="#9DD4BA"/>
<path d="M13 13H14V14H10V13H11V12H13V13Z" fill="#63BA91"/>
<path d="M9 12H8V10H9V12Z" fill="#63BA91"/>
<path d="M15 10H16V12H15V10Z" fill="#63BA91"/>
</svg>'''

        icon = QIcon()

        # SVG 렌더러 생성
        renderer = QSvgRenderer(kiwipet_svg.encode('utf-8'))

        if renderer.isValid():
            # 여러 크기로 렌더링
            for size in [16, 24, 32, 48, 64, 128, 256]:
                pixmap = QPixmap(size, size)
                pixmap.fill(QColor(0, 0, 0, 0))  # 투명 배경

                painter = QPainter(pixmap)
                renderer.render(painter)
                painter.end()

                icon.addPixmap(pixmap)

            print("[앱 아이콘] kiwipet_6 SVG 로드 성공")
            return icon
        else:
            print("[앱 아이콘] SVG 렌더링 실패, 기본 아이콘 사용")
            return create_default_app_icon()

    except Exception as e:
        print(f"[앱 아이콘 오류] {e}")
        return create_default_app_icon()


def create_settings_icon(size=24, color="#8ECFB5"):
    """톱니바퀴 설정 아이콘 생성 (SVG 기반)"""
    try:
        # SVG 템플릿 (색상만 변경 가능)
        svg_template = '''<svg width="140" height="140" viewBox="0 0 140 140" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M50.7958 139.167L48.0125 116.9C46.5049 116.32 45.0854 115.624 43.754 114.813C42.4226 114.001 41.1168 113.131 39.8365 112.203L19.1354 120.901L0 87.849L17.9177 74.2802C17.8017 73.4684 17.7438 72.6868 17.7438 71.9353V67.2384C17.7438 66.4822 17.8017 65.6983 17.9177 64.8865L0 51.3177L19.1354 18.2656L39.8365 26.9635C41.1122 26.0358 42.4458 25.166 43.8375 24.3542C45.2292 23.5424 46.6208 22.8465 48.0125 22.2667L50.7958 0H89.0667L91.85 22.2667C93.3576 22.8465 94.7795 23.5424 96.1155 24.3542C97.4515 25.166 98.755 26.0358 100.026 26.9635L120.727 18.2656L139.862 51.3177L121.945 64.8865C122.061 65.6983 122.119 66.4822 122.119 67.2384V71.9283C122.119 72.6844 122.003 73.4684 121.771 74.2802L139.689 87.849L120.553 120.901L100.026 112.203C98.7504 113.131 97.4167 114.001 96.025 114.813C94.6333 115.624 93.2417 116.32 91.85 116.9L89.0667 139.167H50.7958ZM70.2792 93.9375C77.0056 93.9375 82.7462 91.5601 87.501 86.8052C92.2559 82.0504 94.6333 76.3097 94.6333 69.5833C94.6333 62.8569 92.2559 57.1163 87.501 52.3615C82.7462 47.6066 77.0056 45.2292 70.2792 45.2292C63.4368 45.2292 57.666 47.6066 52.9668 52.3615C48.2676 57.1163 45.9204 62.8569 45.925 69.5833C45.9296 76.3097 48.2792 82.0504 52.9738 86.8052C57.6683 91.5601 63.4368 93.9375 70.2792 93.9375Z" fill="{color}"/>
</svg>'''
        
        svg_data = svg_template.format(color=color)
        
        # SVG를 QPixmap으로 변환
        from PyQt5.QtSvg import QSvgRenderer
        renderer = QSvgRenderer(svg_data.encode('utf-8'))
        
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.transparent)
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)
        renderer.render(painter)
        painter.end()
        
        return QIcon(pixmap)
    except Exception as e:
        print(f"[설정 아이콘] SVG 렌더링 실패, fallback 사용: {e}")
        # Fallback: 간단한 톱니바퀴 그리기
        pixmap = QPixmap(size, size)
        pixmap.fill(Qt.transparent)
        
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        
        pen = QPen(QColor(color))
        pen.setWidth(max(2, size // 10))
        pen.setCapStyle(Qt.RoundCap)
        painter.setPen(pen)
        painter.setBrush(Qt.NoBrush)
        
        center = size / 2
        outer_r = size * 0.4
        inner_r = size * 0.25
        
        # 중앙 원
        painter.drawEllipse(QPointF(center, center), inner_r * 0.6, inner_r * 0.6)
        # 바깥 원
        painter.drawEllipse(QPointF(center, center), outer_r * 0.7, outer_r * 0.7)
        # 톱니 8개
        for i in range(8):
            angle = (i * 360 / 8) - 90
            rad = math.radians(angle)
            x1 = center + outer_r * math.cos(rad)
            y1 = center + outer_r * math.sin(rad)
            x2 = center + inner_r * math.cos(rad)
            y2 = center + inner_r * math.sin(rad)
            painter.drawLine(QPointF(x1, y1), QPointF(x2, y2))
        
        painter.end()
        return QIcon(pixmap)


def create_default_app_icon():
    """기본 앱 아이콘 생성 - 하트 모양 (SVG 실패 시 fallback)"""
    try:
        icon = QIcon()
        
        # 여러 크기로 아이콘 생성
        for size in [16, 24, 32, 48, 64, 128]:
            pixmap = QPixmap(size, size)
            pixmap.fill(QColor(0, 0, 0, 0))  # 완전 투명 배경
            
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # 스케일 계산
            scale = size / 25.0
            
            # 하트 모양 그리기 (민트색)
            path = QPainterPath()
            # 하트 곡선
            cx, cy = 12.5 * scale, 10 * scale
            path.moveTo(cx, cy + 3 * scale)
            # 왼쪽 반원
            path.cubicTo(cx - 6 * scale, cy - 3 * scale, 
                        cx - 10 * scale, cy + 5 * scale,
                        cx, cy + 12 * scale)
            # 오른쪽 반원
            path.cubicTo(cx + 10 * scale, cy + 5 * scale,
                        cx + 6 * scale, cy - 3 * scale,
                        cx, cy + 3 * scale)
            
            painter.setBrush(QColor("#AAC9B8"))
            painter.setPen(Qt.NoPen)
            painter.drawPath(path)
            
            painter.end()
            icon.addPixmap(pixmap)
        
        return icon
    except Exception as e:
        print(f"[기본 아이콘 생성 오류] {e}")
        return None


if __name__ == '__main__':
    main()
